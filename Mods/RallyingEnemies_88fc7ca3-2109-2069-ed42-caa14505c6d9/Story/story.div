//Story header automatically generated. Do not modify!
option compile_trace
option debug_trace

//Registered types:
// type {INTEGER, 1} // osiris predefined type
// type {INTEGER64, 2} // osiris predefined type
// type {REAL, 3} // osiris predefined type
// type {STRING, 4} // osiris predefined type
// type {GUIDSTRING, 5} // osiris predefined type
alias_type {CHARACTERGUID, 6, 5}
alias_type {ITEMGUID, 7, 5}
alias_type {TRIGGERGUID, 8, 5}
alias_type {SPLINEGUID, 9, 5}
alias_type {LEVELTEMPLATEGUID, 10, 5}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////Built-in calls and queries/////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

syscall SysCompleteGoal((STRING)_GoalTitle)		(1,0,0,0)
syscall SysActivateGoal((STRING)_GoalTitle)		(2,0,0,0)
syscall SysSetGoalSleeping((STRING)_GoalTitle)		(3,0,0,0)
syscall SysClear((STRING)_Predicate,(INTEGER)_Arity)		(5,0,0,0)
syscall SysLog((STRING)_Predicate,(INTEGER)_Arity)		(4,0,0,0)


// _Status can have these values:
//	INTERNAL_QUERY_GoalStatus_Sleeping	1	// goal is not yet active, but can become so
//	INTERNAL_QUERY_GoalStatus_Active	2	// goal is active
//	INTERNAL_QUERY_GoalStatus_Completed	3	// goal is completed (hence, not active)
sysquery SysStatus([in](STRING)_GoalTitle,[out](INTEGER)_Status)		(100,0,0,0)
sysquery SysIsCompleted([in](STRING)_GoalTitle)		(101,0,0,0)
sysquery SysIsActive([in](STRING)_GoalTitle)		(102,0,0,0)
sysquery SysIsSleeping([in](STRING)_GoalTitle)		(103,0,0,0)
// Was... functions are only valid if WasDefined() is true.
sysquery SysWasCompleted([in](STRING)_GoalTitle)		(104,0,0,0)
sysquery SysWasActive([in](STRING)_GoalTitle)		(105,0,0,0)
sysquery SysWasSleeping([in](STRING)_GoalTitle)		(106,0,0,0)
sysquery SysWasDefined([in](STRING)_GoalTitle)		(107,0,0,0)
sysquery SysCount([in](STRING)_Predicate,[in](INTEGER)_Arity,[out](INTEGER)_Count)		(108,0,0,0)
sysquery SysStoryVersion([out](INTEGER)_Major,[out](INTEGER)_Minor,[out](INTEGER)_V3,[out](INTEGER)_V4)		(109,0,0,0)

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

query IntegerSum([in](INTEGER)_A, [in](INTEGER)_B, [out](INTEGER)_Sum) (2,0,0,1)
query IntegerSubtract([in](INTEGER)_A, [in](INTEGER)_B, [out](INTEGER)_Result) (2,0,1,1)
query IntegerProduct([in](INTEGER)_A, [in](INTEGER)_B, [out](INTEGER)_Product) (2,0,2,1)
query IntegerDivide([in](INTEGER)_A, [in](INTEGER)_B, [out](INTEGER)_Quotient) (2,0,3,1)
query IntegerMin([in](INTEGER)_A, [in](INTEGER)_B, [out](INTEGER)_Minimum) (2,0,4,1)
query IntegerMax([in](INTEGER)_A, [in](INTEGER)_B, [out](INTEGER)_Maximum) (2,0,5,1)
query IntegerModulo([in](INTEGER)_Num, [in](INTEGER)_Mod, [out](INTEGER)_Return) (2,0,6,1)
query RealSum([in](REAL)_A, [in](REAL)_B, [out](REAL)_Sum) (2,0,7,1)
query RealSubtract([in](REAL)_A, [in](REAL)_B, [out](REAL)_Result) (2,0,8,1)
query RealProduct([in](REAL)_A, [in](REAL)_B, [out](REAL)_Product) (2,0,9,1)
query RealDivide([in](REAL)_A, [in](REAL)_B, [out](REAL)_Quotient) (2,0,10,1)
query RealMin([in](REAL)_A, [in](REAL)_B, [out](REAL)_Minimum) (2,0,11,1)
query RealMax([in](REAL)_A, [in](REAL)_B, [out](REAL)_Maximum) (2,0,12,1)
query Integer([in](REAL)_R, [out](INTEGER)_I) (2,0,13,1)
query Real([in](INTEGER)_I, [out](REAL)_R) (2,0,14,1)
query Random([in](INTEGER)_Modulo, [out](INTEGER)_Random) (2,0,15,1)
query CharacterHasTalent([in](CHARACTERGUID)_Character, [in](STRING)_Talent, [out](INTEGER)_Bool) (2,0,16,1)
call CharacterAddTalent((CHARACTERGUID)_Character, (STRING)_Talent) (1,0,17,1)
call CharacterRemoveTalent((CHARACTERGUID)_Character, (STRING)_Talent) (1,0,18,1)
query CharacterGetLevel([in](CHARACTERGUID)_Character, [out](INTEGER)_Level) (2,0,19,1)
query CharacterCanFight([in](CHARACTERGUID)_Character, [out](INTEGER)_Bool) (2,0,20,1)
call CharacterFreeze((CHARACTERGUID)_Character) (1,0,21,1)
call CharacterUnfreeze((CHARACTERGUID)_Character) (1,0,22,1)
call CharacterCreateAtTrigger((TRIGGERGUID)_Trigger, (STRING)_TemplateId, (INTEGER)_PlaySpawn) (1,0,23,1)
call TemporaryCharacterCreateAtTrigger((TRIGGERGUID)_Trigger, (STRING)_TemplateId, (INTEGER)_PlaySpawn) (1,0,24,1)
query CharacterCreateAtPosition([in](REAL)_X, [in](REAL)_Y, [in](REAL)_Z, [in](STRING)_TemplateId, [in](INTEGER)_PlaySpawn, [out](CHARACTERGUID)_Created) (2,0,25,1)
query TemporaryCharacterCreateAtPosition([in](REAL)_X, [in](REAL)_Y, [in](REAL)_Z, [in](STRING)_TemplateId, [in](INTEGER)_PlaySpawn, [out](CHARACTERGUID)_Created) (2,0,26,1)
query CharacterCreateAtPositionOutOfSightTo([in](REAL)_X, [in](REAL)_Y, [in](REAL)_Z, [in](STRING)_TemplateId, [in](INTEGER)_Angle, [in](INTEGER)_PlaySpawn, [in](STRING)_Event, [out](CHARACTERGUID)_Created) (2,0,27,1)
query TemporaryCharacterCreateAtPositionOutOfSightTo([in](REAL)_X, [in](REAL)_Y, [in](REAL)_Z, [in](STRING)_TemplateId, [in](INTEGER)_Angle, [in](INTEGER)_PlaySpawn, [in](STRING)_Event, [out](CHARACTERGUID)_Created) (2,0,28,1)
query CharacterCreateOutOfSightToObject([in](STRING)_TemplateId, [in](CHARACTERGUID)_ToTarget, [in](GUIDSTRING)_FromObject, [in](INTEGER)_PlaySpawn, [in](STRING)_Event, [out](CHARACTERGUID)_Created) (2,0,29,1)
query TemporaryCharacterCreateOutOfSightToObject([in](STRING)_TemplateId, [in](CHARACTERGUID)_ToTarget, [in](GUIDSTRING)_FromObject, [in](INTEGER)_PlaySpawn, [in](STRING)_Event, [out](CHARACTERGUID)_Created) (2,0,30,1)
call OpenMessageBox((CHARACTERGUID)_Character, (STRING)_Message) (1,0,31,1)
call OpenMessageBoxYesNo((CHARACTERGUID)_Character, (STRING)_Message) (1,0,32,1)
call OpenMessageBoxChoice((CHARACTERGUID)_Character, (STRING)_Message, (STRING)_Choice_1, (STRING)_Choice_2) (1,0,33,1)
call ShowCredits((CHARACTERGUID)_Character) (1,0,34,1)
call TeleportToPosition((GUIDSTRING)_SourceObject, (REAL)_X, (REAL)_Y, (REAL)_Z, (STRING)_Event, (INTEGER)_TeleportLinkedCharacters, (INTEGER)_ExcludePartyFollowers) (1,0,35,1)
call TeleportTo((GUIDSTRING)_SourceObject, (GUIDSTRING)_TargetObject, (STRING)_Event, (INTEGER)_TeleportLinkedCharacters, (INTEGER)_ExcludePartyFollowers, (INTEGER)_LeaveCombat) (1,0,36,1)
call CharacterMoveToPosition((CHARACTERGUID)_Character, (REAL)_X, (REAL)_Y, (REAL)_Z, (INTEGER)_Running, (STRING)_Event) (1,0,37,1)
call CharacterMoveTo((CHARACTERGUID)_Character, (GUIDSTRING)_Target, (INTEGER)_Running, (STRING)_Event, (INTEGER)_IncreaseSpeed) (1,0,38,1)
call CharacterLookFromTrigger((CHARACTERGUID)_Character, (TRIGGERGUID)_Trigger, (INTEGER)_SnapToTarget) (1,0,39,1)
call CharacterEquipItem((CHARACTERGUID)_Character, (ITEMGUID)_Item) (1,0,40,1)
call TransferItemsToCharacter((CHARACTERGUID)_Character, (CHARACTERGUID)_ToCharacter) (1,0,41,1)
call TransferItemsToParty((CHARACTERGUID)_Character) (1,0,42,1)
call TransferItemsToUser((CHARACTERGUID)_Character) (1,0,43,1)
call CharacterUnequipItem((CHARACTERGUID)_Character, (ITEMGUID)_Item) (1,0,44,1)
call CharacterFollowCharacter((CHARACTERGUID)_Character, (CHARACTERGUID)_ToCharacter) (1,0,45,1)
call CharacterStopFollow((CHARACTERGUID)_Character) (1,0,46,1)
call CharacterTeleportPartiesToTriggerWithMovie((TRIGGERGUID)_Trigger, (STRING)_Event, (STRING)_Movie) (1,0,47,1)
call CharacterTeleportPartiesToTriggerWithMovieRequestCallback((TRIGGERGUID)_Trigger, (STRING)_Event) (1,0,48,1)
call CharacterSetTeleportMovie((INTEGER)_UserId, (STRING)_Movie) (1,0,49,1)
call CharacterTeleportPartiesToTrigger((TRIGGERGUID)_Trigger, (STRING)_Event) (1,0,50,1)
call CharacterClearTradeGeneratedItems((CHARACTERGUID)_Character) (1,0,51,1)
call CharacterSetCustomTradeTreasure((CHARACTERGUID)_Character, (STRING)_Treasure) (1,0,52,1)
call GenerateItems((CHARACTERGUID)_Player, (CHARACTERGUID)_Trader) (1,0,53,1)
call CharacterGiveReward((CHARACTERGUID)_Player, (STRING)_Treasure, (INTEGER)_Identified) (1,0,54,1)
call CharacterGiveQuestReward((CHARACTERGUID)_Player, (STRING)_Quest, (STRING)_RewardState) (1,0,55,1)
call CharacterDie((CHARACTERGUID)_Character, (INTEGER)_GenerateTreasure, (STRING)_DeathType, (GUIDSTRING)_Source) (1,0,56,1)
call CharacterDieImmediate((CHARACTERGUID)_Character, (INTEGER)_GenerateTreasure, (STRING)_DeathType, (GUIDSTRING)_Source) (1,0,57,1)
call CharacterAddSkill((CHARACTERGUID)_Character, (STRING)_Skill, (INTEGER)_ShowNotification) (1,0,58,1)
call CharacterRemoveSkill((CHARACTERGUID)_Character, (STRING)_Skill) (1,0,59,1)
query CharacterHasSkill([in](CHARACTERGUID)_Character, [in](STRING)_Skill, [out](INTEGER)_Bool) (2,0,60,1)
call CharacterAddAttributePoint((CHARACTERGUID)_Character, (INTEGER)_Amount) (1,0,61,1)
query CharacterGetAttributePoints([in](CHARACTERGUID)_Character, [out](INTEGER)_Amount) (2,0,62,1)
call CharacterAddAbilityPoint((CHARACTERGUID)_Character, (INTEGER)_Amount) (1,0,63,1)
call CharacterAddCivilAbilityPoint((CHARACTERGUID)_Character, (INTEGER)_Amount) (1,0,64,1)
call CharacterAddActionPoints((CHARACTERGUID)_Character, (INTEGER)_Amount) (1,0,65,1)
query CharacterGetAbilityPoints([in](CHARACTERGUID)_Character, [out](INTEGER)_Amount) (2,0,66,1)
query CharacterGetCivilAbilityPoints([in](CHARACTERGUID)_Character, [out](INTEGER)_Amount) (2,0,67,1)
call CharacterAddTalentPoint((CHARACTERGUID)_Character, (INTEGER)_Amount) (1,0,68,1)
query CharacterGetTalentPoints([in](CHARACTERGUID)_Character, [out](INTEGER)_Amount) (2,0,69,1)
query CharacterGetBaseSourcePoints([in](CHARACTERGUID)_Character, [out](INTEGER)_Amount) (2,0,70,1)
query CharacterGetSourcePoints([in](CHARACTERGUID)_Character, [out](INTEGER)_Amount) (2,0,71,1)
query CharacterGetMaxSourcePoints([in](CHARACTERGUID)_Character, [out](INTEGER)_Amount) (2,0,72,1)
call CharacterResurrect((CHARACTERGUID)_Character) (1,0,73,1)
call CharacterResurrectAndResetXPReward((CHARACTERGUID)_Character) (1,0,74,1)
call CharacterResurrectCustom((CHARACTERGUID)_Character, (STRING)_ResurrectAnimation) (1,0,75,1)
query CharacterGetReservedUserID([in](CHARACTERGUID)_Character, [out](INTEGER)_User) (2,0,76,1)
query GetCurrentCharacter([in](INTEGER)_User, [out](CHARACTERGUID)_Character) (2,0,77,1)
query CharacterIsControlled([in](CHARACTERGUID)_Character, [out](INTEGER)_IsControlled) (2,0,78,1)
query CharacterGetGold([in](CHARACTERGUID)_Character, [out](INTEGER)_Count) (2,0,79,1)
call CharacterAddGold((CHARACTERGUID)_Character, (INTEGER)_Count) (1,0,80,1)
call PartyAddGold((CHARACTERGUID)_Character, (INTEGER)_Count) (1,0,81,1)
query PartyGetGold([in](CHARACTERGUID)_Character, [out](INTEGER)_Gold) (2,0,82,1)
call UserAddGold((CHARACTERGUID)_Character, (INTEGER)_Count) (1,0,83,1)
query UserGetGold([in](CHARACTERGUID)_Character, [out](INTEGER)_Gold) (2,0,84,1)
call CharacterIncreaseSocialStat((CHARACTERGUID)_Character, (STRING)_Id) (1,0,85,1)
call CharacterDecreaseSocialStat((CHARACTERGUID)_Character, (STRING)_Id) (1,0,86,1)
call CharacterSetSpectating((CHARACTERGUID)_Character, (INTEGER)_Spectating) (1,0,87,1)
query CharacterIsSpectating([in](CHARACTERGUID)_Character, [out](INTEGER)_Bool) (2,0,88,1)
query CharacterCanSee([in](CHARACTERGUID)_Character, [in](GUIDSTRING)_Target, [out](INTEGER)_Bool) (2,0,89,1)
call CharacterSetCustomName((CHARACTERGUID)_Character, (STRING)_Text) (1,0,90,1)
call CharacterAppear((CHARACTERGUID)_Character, (INTEGER)_PlaySpawn, (STRING)_Event) (1,0,91,1)
call CharacterAppearCustom((CHARACTERGUID)_Character, (STRING)_Animation, (STRING)_Event) (1,0,92,1)
call CharacterAppearAt((CHARACTERGUID)_Character, (GUIDSTRING)_Target, (INTEGER)_PlaySpawn, (STRING)_Event) (1,0,93,1)
call CharacterAppearAtCustom((CHARACTERGUID)_Character, (GUIDSTRING)_Target, (STRING)_Animation, (STRING)_Event) (1,0,94,1)
call CharacterAppearAtPosition((CHARACTERGUID)_Character, (REAL)_X, (REAL)_Y, (REAL)_Z, (INTEGER)_PlaySpawn, (STRING)_Event) (1,0,95,1)
call CharacterAppearAtPositionCustom((CHARACTERGUID)_Character, (REAL)_X, (REAL)_Y, (REAL)_Z, (STRING)_Animation, (STRING)_Event) (1,0,96,1)
call CharacterAppearOutOfSightTo((CHARACTERGUID)_Character, (GUIDSTRING)_Target, (INTEGER)_Angle, (INTEGER)_PlaySpawn, (STRING)_Event) (1,0,97,1)
call CharacterAppearOutOfSightToCustom((CHARACTERGUID)_Character, (GUIDSTRING)_Target, (INTEGER)_Angle, (STRING)_Animation, (STRING)_Event) (1,0,98,1)
call CharacterAppearOutOfSightToObject((CHARACTERGUID)_Character, (GUIDSTRING)_Target, (GUIDSTRING)_Object, (INTEGER)_PlaySpawn, (STRING)_Event) (1,0,99,1)
call CharacterAppearOutOfSightToObjectCustom((CHARACTERGUID)_Character, (GUIDSTRING)_Target, (GUIDSTRING)_Object, (STRING)_Animation, (STRING)_Event) (1,0,100,1)
call CharacterAppearOnTrailOutOfSightTo((CHARACTERGUID)_Character, (CHARACTERGUID)_Target, (INTEGER)_Angle, (INTEGER)_PlaySpawn, (STRING)_Event) (1,0,101,1)
call CharacterAppearOnTrailOutOfSightToCustom((CHARACTERGUID)_Character, (CHARACTERGUID)_Target, (INTEGER)_Angle, (STRING)_Animation, (STRING)_Event) (1,0,102,1)
call CharacterAppearOnTrailOutOfSightToObject((CHARACTERGUID)_Character, (CHARACTERGUID)_Target, (GUIDSTRING)_Object, (INTEGER)_PlaySpawn, (STRING)_Event) (1,0,103,1)
call CharacterAppearOnTrailOutOfSightToObjectCustom((CHARACTERGUID)_Character, (CHARACTERGUID)_Target, (GUIDSTRING)_Object, (STRING)_Animation, (STRING)_Event) (1,0,104,1)
call CharacterAppearAtPositionOutOfSightTo((CHARACTERGUID)_Character, (REAL)_X, (REAL)_Y, (REAL)_Z, (INTEGER)_Angle, (INTEGER)_PlaySpawn, (STRING)_Event) (1,0,105,1)
call CharacterAppearAtPositionOutOfSightToCustom((CHARACTERGUID)_Character, (REAL)_X, (REAL)_Y, (REAL)_Z, (INTEGER)_Angle, (STRING)_Animation, (STRING)_Event) (1,0,106,1)
call CharacterAppearAtPositionOutOfSightToObject((CHARACTERGUID)_Character, (REAL)_X, (REAL)_Y, (REAL)_Z, (GUIDSTRING)_Object, (INTEGER)_PlaySpawn, (STRING)_Event) (1,0,107,1)
call CharacterAppearAtPositionOutOfSightToObjectCustom((CHARACTERGUID)_Character, (REAL)_X, (REAL)_Y, (REAL)_Z, (GUIDSTRING)_Object, (STRING)_Animation, (STRING)_Event) (1,0,108,1)
call CharacterDisappearOutOfSight((CHARACTERGUID)_Character, (INTEGER)_Angle, (INTEGER)_Running, (STRING)_Event, (INTEGER)_IncreaseSpeed) (1,0,109,1)
call CharacterDisappearOutOfSightToObject((CHARACTERGUID)_Character, (GUIDSTRING)_Object, (INTEGER)_Running, (STRING)_Event, (INTEGER)_IncreaseSpeed) (1,0,110,1)
call CharacterFleeOutOfSight((CHARACTERGUID)_Character, (STRING)_Event) (1,0,111,1)
call CharacterAttack((CHARACTERGUID)_Character, (GUIDSTRING)_Target) (1,0,112,1)
query CharacterAddToCharacterCreation([in](CHARACTERGUID)_Character, [in](INTEGER)_Respec, [out](INTEGER)_Success) (2,0,113,1)
query GameMasterAddToCharacterCreation([in](CHARACTERGUID)_Character, [in](INTEGER)_Respec, [out](INTEGER)_Success) (2,0,114,1)
call CharacterMakePlayer((CHARACTERGUID)_TargetCharacter, (CHARACTERGUID)_OwnerCharacter) (1,0,115,1)
call CharacterRecruitCharacter((CHARACTERGUID)_Character, (CHARACTERGUID)_Character) (1,0,116,1)
call CharacterAssign((INTEGER)_UserID) (1,0,117,1)
call CharacterAssignToUser((INTEGER)_UserID, (CHARACTERGUID)_Character) (1,0,118,1)
call CharacterMakeCompanion((CHARACTERGUID)_Character, (CHARACTERGUID)_Character) (1,0,119,1)
call CharacterMakeNPC((CHARACTERGUID)_Character) (1,0,120,1)
call CharacterAddToParty((CHARACTERGUID)_Character, (CHARACTERGUID)_Character) (1,0,121,1)
call CharacterRemoveFromParty((CHARACTERGUID)_Character) (1,0,122,1)
call CharacterAddToPlayerCharacter((CHARACTERGUID)_Character, (CHARACTERGUID)_Owner) (1,0,123,1)
call CharacterRemoveFromPlayerCharacter((CHARACTERGUID)_Character, (CHARACTERGUID)_Owner) (1,0,124,1)
call CharacterRemoveAllPartyFollowers((CHARACTERGUID)_Character) (1,0,125,1)
query CharacterIsPartyMember([in](CHARACTERGUID)_Character, [out](INTEGER)_Bool) (2,0,126,1)
query CharacterIsInPartyWith([in](CHARACTERGUID)_Character, [in](CHARACTERGUID)_Target, [out](INTEGER)_Bool) (2,0,127,1)
query CharacterGetRelationToCharacter([in](CHARACTERGUID)_Character, [in](CHARACTERGUID)_OtherCharacter, [out](INTEGER)_Relation) (2,0,128,1)
call CharacterSetRelationIndivFactionToIndivFaction((CHARACTERGUID)_Character, (CHARACTERGUID)_OtherCharacter, (INTEGER)_Relation) (1,0,129,1)
call CharacterSetRelationIndivFactionToFaction((CHARACTERGUID)_Character, (STRING)_OtherFaction, (INTEGER)_Relation) (1,0,130,1)
call CharacterSetRelationFactionToIndivFaction((STRING)_Faction, (CHARACTERGUID)_OtherCharacter, (INTEGER)_Relation) (1,0,131,1)
call CharacterSetRelationFactionToFaction((STRING)_Faction, (STRING)_otherFaction, (INTEGER)_Relation) (1,0,132,1)
call CharacterSetTemporaryHostileRelation((CHARACTERGUID)_Character, (CHARACTERGUID)_OtherCharacter) (1,0,133,1)
call CharacterSetReactionPriority((CHARACTERGUID)_Character, (STRING)_Reaction, (INTEGER)_Priority) (1,0,134,1)
query CharacterGetAttitudeTowardsPlayer([in](CHARACTERGUID)_Character, [in](CHARACTERGUID)_Player, [out](INTEGER)_Attitude) (2,0,135,1)
query CharacterGetHitpointsPercentage([in](CHARACTERGUID)_Character, [out](REAL)_Percentage) (2,0,136,1)
call CharacterSetHitpointsPercentage((CHARACTERGUID)_Character, (REAL)_Percentage) (1,0,137,1)
query CharacterGetArmorPercentage([in](CHARACTERGUID)_Character, [out](REAL)_Percentage) (2,0,138,1)
call CharacterSetArmorPercentage((CHARACTERGUID)_Character, (REAL)_Percentage) (1,0,139,1)
query CharacterGetMagicArmorPercentage([in](CHARACTERGUID)_Character, [out](REAL)_Percentage) (2,0,140,1)
call CharacterSetMagicArmorPercentage((CHARACTERGUID)_Character, (REAL)_Percentage) (1,0,141,1)
call CharacterLookAt((CHARACTERGUID)_Character, (GUIDSTRING)_Target, (INTEGER)_SnapToTarget) (1,0,142,1)
call CharacterLevelUp((CHARACTERGUID)_Character) (1,0,143,1)
call CharacterLevelUpTo((CHARACTERGUID)_Character, (INTEGER)_Level) (1,0,144,1)
call PartyAddActualExperience((CHARACTERGUID)_Character, (INTEGER)_XP) (1,0,145,1)
call PartyAddExperience((CHARACTERGUID)_Character, (INTEGER)_Act, (INTEGER)_ActPart, (INTEGER)_Gain) (1,0,146,1)
call PartyAddExplorationExperience((CHARACTERGUID)_Character, (INTEGER)_Act, (INTEGER)_ActPart, (INTEGER)_Gain) (1,0,147,1)
call CharacterAddExplorationExperience((CHARACTERGUID)_Character, (INTEGER)_Act, (INTEGER)_ActPart, (INTEGER)_Gain) (1,0,148,1)
call PartyAddCharismaExperience((CHARACTERGUID)_Character, (INTEGER)_Act, (INTEGER)_ActPart, (INTEGER)_Gain) (1,0,149,1)
call CharacterStatusText((CHARACTERGUID)_Character, (STRING)_Text) (1,0,150,1)
call CharacterEnteredSubRegion((CHARACTERGUID)_Character, (STRING)_Text) (1,0,151,1)
call CharacterDisplayTextWithParam((CHARACTERGUID)_Character, (STRING)_Text, (INTEGER)_Parameter) (1,0,152,1)
call CharacterSetImmortal((CHARACTERGUID)_Character, (INTEGER)_Bool) (1,0,153,1)
query CharacterGetHostCharacter([out](CHARACTERGUID)_Character) (2,0,154,1)
query CharacterGetDisplayName([in](CHARACTERGUID)_Character, [out](STRING)_stringHandle, [out](STRING)_referenceString) (2,0,155,1)
call CharacterFlushQueue((CHARACTERGUID)_Character) (1,0,156,1)
call CharacterPurgeQueue((CHARACTERGUID)_Character) (1,0,157,1)
call CharacterLaunchIterator((STRING)_Event) (1,0,158,1)
call CharacterLaunchIteratorAroundObject((GUIDSTRING)_Center, (REAL)_Radius, (STRING)_Event) (1,0,159,1)
call CharacterLaunchOsirisOnlyIterator((STRING)_Event) (1,0,160,1)
call CharacterSetCanTrade((CHARACTERGUID)_Trader, (INTEGER)_Bool) (1,0,161,1)
query CharacterCanTrade([in](CHARACTERGUID)_Trader, [out](INTEGER)_Bool) (2,0,162,1)
call CharacterSetStill((CHARACTERGUID)_Character) (1,0,163,1)
query CharacterIsInCombat([in](CHARACTERGUID)_Character, [out](INTEGER)_Bool) (2,0,164,1)
query CharacterIsMoving([in](CHARACTERGUID)_Character, [out](INTEGER)_Bool) (2,0,165,1)
query CharacterIsInFightMode([in](CHARACTERGUID)_Character, [out](INTEGER)_Bool) (2,0,166,1)
call CharacterSetFightMode((CHARACTERGUID)_Character, (INTEGER)_Enabled, (INTEGER)_Immediately) (1,0,167,1)
call CharacterMakeStoryNpc((CHARACTERGUID)_Character, (INTEGER)_Bool) (1,0,168,1)
call CharacterStopAllEffectsWithName((CHARACTERGUID)_Character, (STRING)_FxName) (1,0,169,1)
call CharacterPickupItem((CHARACTERGUID)_Character, (ITEMGUID)_Item, (STRING)_Event) (1,0,170,1)
call CharacterItemSetEvent((CHARACTERGUID)_Character, (ITEMGUID)_Item, (STRING)_Event) (1,0,171,1)
call CharacterCharacterSetEvent((CHARACTERGUID)_Character, (CHARACTERGUID)_Character, (STRING)_Event) (1,0,172,1)
call CharacterUseItem((CHARACTERGUID)_Character, (ITEMGUID)_Item, (STRING)_Event) (1,0,173,1)
call CharacterMoveItemToTrigger((CHARACTERGUID)_Character, (ITEMGUID)_Item, (TRIGGERGUID)_Trigger, (INTEGER)_Amount, (STRING)_Event) (1,0,174,1)
query CharacterConsume([in](CHARACTERGUID)_Character, [in](STRING)_Potion, [out](INTEGER64)_ConsumeHandle) (2,0,175,1)
call CharacterUnconsume((CHARACTERGUID)_Character, (INTEGER64)_ConsumeHandle) (1,0,176,1)
call CharacterAddAttribute((CHARACTERGUID)_Character, (STRING)_Attribute, (INTEGER)_Value) (1,0,177,1)
call CharacterRemoveAttribute((CHARACTERGUID)_Character, (STRING)_Attribute, (INTEGER)_Value) (1,0,178,1)
query CharacterGetBaseAttribute([in](CHARACTERGUID)_Character, [in](STRING)_Attribute, [out](INTEGER)_Value) (2,0,179,1)
query CharacterGetAttribute([in](CHARACTERGUID)_Character, [in](STRING)_Attribute, [out](INTEGER)_Value) (2,0,180,1)
call CharacterAddAbility((CHARACTERGUID)_Character, (STRING)_Ability, (INTEGER)_Value) (1,0,181,1)
call CharacterRemoveAbility((CHARACTERGUID)_Character, (STRING)_Ability, (INTEGER)_Value) (1,0,182,1)
query CharacterIsIncapacitated([in](CHARACTERGUID)_Character, [out](INTEGER)_Incapacitated) (2,0,183,1)
query CharacterGetAbility([in](CHARACTERGUID)_Character, [in](STRING)_Ability, [out](INTEGER)_Value) (2,0,184,1)
query CharacterGetBaseAbility([in](CHARACTERGUID)_Character, [in](STRING)_Ability, [out](INTEGER)_Value) (2,0,185,1)
query CharacterGetOwner([in](CHARACTERGUID)_Character, [out](CHARACTERGUID)_Owner) (2,0,186,1)
call ActivateTrade((CHARACTERGUID)_Player, (CHARACTERGUID)_Trader, (INTEGER)_CanRepair, (INTEGER)_CanIdentify, (INTEGER)_CanSell) (1,0,187,1)
call StartPickpocket((CHARACTERGUID)_Player, (CHARACTERGUID)_NPC, (INTEGER)_Success) (1,0,188,1)
call ExecuteDeal((CHARACTERGUID)_Character, (INTEGER)_Deal, (INTEGER)_AttitudeDiff) (1,0,189,1)
query CharacterGetEquippedWeapon([in](CHARACTERGUID)_Character, [out](GUIDSTRING)_ItemGUID) (2,0,190,1)
query CharacterGetEquippedShield([in](CHARACTERGUID)_Character, [out](GUIDSTRING)_ItemGUID) (2,0,191,1)
query CharacterGetEquippedItem([in](CHARACTERGUID)_Character, [in](STRING)_Slotname, [out](GUIDSTRING)_ItemGUID) (2,0,192,1)
call CharacterSetFollowCharacter((CHARACTERGUID)_Character, (CHARACTERGUID)_CharacterToFollow) (1,0,193,1)
call CharacterAttachToGroup((CHARACTERGUID)_Src, (CHARACTERGUID)_Target) (1,0,194,1)
call CharacterDetachFromGroup((CHARACTERGUID)_Character) (1,0,195,1)
query CharactersAreGrouped([in](CHARACTERGUID)_Character1, [in](CHARACTERGUID)_Character2, [out](INTEGER)_Bool) (2,0,196,1)
query CharacterGetInventoryGoldValue([in](CHARACTERGUID)_Character, [out](INTEGER)_Value) (2,0,197,1)
query CharacterGetItemTemplateCount([in](CHARACTERGUID)_Character, [in](STRING)_ItemTemplate, [out](INTEGER)_Value) (2,0,198,1)
call CharacterAddAttitudeTowardsPlayer((CHARACTERGUID)_Character, (CHARACTERGUID)_Player, (INTEGER)_Delta) (1,0,199,1)
query CharacterIsFemale([in](CHARACTERGUID)_Character, [out](INTEGER)_Bool) (2,0,200,1)
call CharacterSetCanSpotSneakers((CHARACTERGUID)_Character, (INTEGER)_CanSpotSneakers) (1,0,201,1)
query CharacterCanSpotSneakers([in](CHARACTERGUID)_Character, [out](INTEGER)_Bool) (2,0,202,1)
call CharacterMoveWeaponsToContainer((CHARACTERGUID)_Character, (ITEMGUID)_Container) (1,0,203,1)
call CharacterLockAbility((CHARACTERGUID)_Character, (STRING)_Ability) (1,0,204,1)
call CharacterUnlockAbility((CHARACTERGUID)_Character, (STRING)_Ability) (1,0,205,1)
call CharacterUnlockRecipe((CHARACTERGUID)_Character, (STRING)_RecipeID, (INTEGER)_ShowNotification) (1,0,206,1)
query CharacterHasRecipeUnlocked([in](CHARACTERGUID)_Character, [in](STRING)_RecipeID, [out](INTEGER)_Bool) (2,0,207,1)
query CharacterIsDead([in](CHARACTERGUID)_Character, [out](INTEGER)_Bool) (2,0,208,1)
query CharacterIsDeadOrFeign([in](CHARACTERGUID)_Character, [out](INTEGER)_Bool) (2,0,209,1)
call CharacterSetAnimationOverride((CHARACTERGUID)_Character, (STRING)_Animation) (1,0,210,1)
call CharacterSetAnimationSetOverride((CHARACTERGUID)_Character, (STRING)_AnimationSetResource) (1,0,211,1)
call PartySetIdentifyPriceModifier((CHARACTERGUID)_Character, (CHARACTERGUID)_PartyMember, (INTEGER)_Modifier) (1,0,212,1)
call PartySetRepairPriceModifier((CHARACTERGUID)_Character, (CHARACTERGUID)_PartyMember, (INTEGER)_Modifier) (1,0,213,1)
call PartySetShopPriceModifier((CHARACTERGUID)_Character, (CHARACTERGUID)_PartyMember, (INTEGER)_Modifier) (1,0,214,1)
call SetTagPriceModifier((CHARACTERGUID)_Character, (STRING)_Tag, (INTEGER)_Modifier) (1,0,215,1)
call CharacterResetCooldowns((CHARACTERGUID)_Character) (1,0,216,1)
call CharacterShowStoryElementUI((CHARACTERGUID)_Character, (INTEGER)_Type, (STRING)_UIInstance) (1,0,217,1)
call CharacterCloseStoryElementUI((CHARACTERGUID)_Character, (INTEGER)_Type, (STRING)_UIInstance) (1,0,218,1)
call CharacterSendGlobalCombatCounter((CHARACTERGUID)_Character, (INTEGER)_Turn) (1,0,219,1)
call CharacterPlayHUDSound((CHARACTERGUID)_Character, (STRING)_Sound) (1,0,220,1)
call CharacterPlayHUDSoundResource((CHARACTERGUID)_Character, (GUIDSTRING)_SoundResource) (1,0,221,1)
call CharacterRegisterCrime((CHARACTERGUID)_Player, (STRING)_CrimeType, (GUIDSTRING)_Evidence, (CHARACTERGUID)_Witness, (INTEGER)_CrimeID) (1,0,222,1)
call CharacterRegisterCrimeWithPosition((CHARACTERGUID)_Player, (STRING)_CrimeType, (GUIDSTRING)_Evidence, (CHARACTERGUID)_Witness, (REAL)_X, (REAL)_Y, (REAL)_Z, (INTEGER)_CrimeID) (1,0,223,1)
call CharacterStopCrime((CHARACTERGUID)_Player, (STRING)_CrimeType, (GUIDSTRING)_Evidence) (1,0,224,1)
call CharacterStopCrimeWithID((CHARACTERGUID)_Player, (INTEGER)_Crime) (1,0,225,1)
call CharacterIgnoreCharacterActiveCrimes((CHARACTERGUID)_Character, (CHARACTERGUID)_Player, (REAL)_Timer) (1,0,226,1)
query CharacterCanIgnoreActiveCrimes([in](CHARACTERGUID)_Character, [out](INTEGER)_Bool) (2,0,227,1)
query CharacterIgnoreActiveCrimes([in](CHARACTERGUID)_Character, [out](INTEGER)_Bool) (2,0,228,1)
call CharacterRemoveSummons((CHARACTERGUID)_Character, (INTEGER)_Die) (1,0,229,1)
call CharacterLinkGhost((CHARACTERGUID)_Character, (CHARACTERGUID)_Ghost) (1,0,230,1)
call CharacterUnlinkGhost((CHARACTERGUID)_Character, (CHARACTERGUID)_Ghost) (1,0,231,1)
call DestroyGhost((CHARACTERGUID)_Ghost) (1,0,232,1)
call CharacterUseSkill((CHARACTERGUID)_Character, (STRING)_SkillID, (GUIDSTRING)_Target, (INTEGER)_ForceResetCooldown, (INTEGER)_IgnoreHasSkill, (INTEGER)_IgnoreChecks) (1,0,233,1)
call CharacterUseSkillAtPosition((CHARACTERGUID)_Character, (STRING)_SkillID, (REAL)_X, (REAL)_Y, (REAL)_Z, (INTEGER)_ForceResetCooldown, (INTEGER)_IgnoreHasSkill) (1,0,234,1)
call CharacterDisableCrime((CHARACTERGUID)_Character, (STRING)_Crime) (1,0,235,1)
query CharacterIsCrimeEnabled([in](CHARACTERGUID)_Character, [in](STRING)_Crime, [out](INTEGER)_Bool) (2,0,236,1)
query CharacterGetCrimeRegion([in](CHARACTERGUID)_Character, [out](STRING)_Region) (2,0,237,1)
call CharacterEnableCrime((CHARACTERGUID)_Character, (STRING)_Crime) (1,0,238,1)
call CharacterDisableAllCrimes((CHARACTERGUID)_Character) (1,0,239,1)
call CharacterEnableAllCrimes((CHARACTERGUID)_Character) (1,0,240,1)
call CharacterEnableCrimeWarnings((CHARACTERGUID)_Character, (INTEGER)_Enable) (1,0,241,1)
query CharacterGetCrimeDialog([in](CHARACTERGUID)_Character, [out](INTEGER)_InstanceID) (2,0,242,1)
call CharacterRemoveTension((CHARACTERGUID)_Player) (1,0,243,1)
query CharacterIsEnemy([in](CHARACTERGUID)_Character, [in](CHARACTERGUID)_OtherCharacter, [out](INTEGER)_Bool) (2,0,244,1)
query CharacterIsAlly([in](CHARACTERGUID)_Character, [in](CHARACTERGUID)_OtherCharacter, [out](INTEGER)_Bool) (2,0,245,1)
query CharacterIsNeutral([in](CHARACTERGUID)_Character, [in](CHARACTERGUID)_OtherCharacter, [out](INTEGER)_Bool) (2,0,246,1)
call CharacterAddSourcePoints((CHARACTERGUID)_Character, (INTEGER)_Amount) (1,0,247,1)
call CharacterOverrideMaxSourcePoints((CHARACTERGUID)_Character, (INTEGER)_Amount) (1,0,248,1)
call CharacterRemoveMaxSourcePointsOverride((CHARACTERGUID)_Character) (1,0,249,1)
call CharacterApplyPreset((CHARACTERGUID)_Character, (STRING)_Preset) (1,0,250,1)
call CharacterApplyHenchmanPreset((CHARACTERGUID)_Character, (STRING)_Preset) (1,0,251,1)
call CharacterApplyRacePreset((CHARACTERGUID)_Character, (STRING)_Preset) (1,0,252,1)
call CharacterMoveToAndTalk((CHARACTERGUID)_Character, (GUIDSTRING)_Target, (STRING)_DialogID, (INTEGER)_IsAutomated, (STRING)_MoveID, (INTEGER)_Running, (REAL)_Timeout) (1,0,253,1)
call CharacterMoveToAndTalkRequestDialogFailed((CHARACTERGUID)_Character, (GUIDSTRING)_Target, (STRING)_MoveId) (1,0,254,1)
call CharacterEnableWaypointUsage((CHARACTERGUID)_Character, (INTEGER)_Bool) (1,0,255,1)
query CharacterCanUseWaypoints([in](CHARACTERGUID)_Character, [out](INTEGER)_Bool) (2,0,256,1)
query CharacterCanSeeGhost([in](CHARACTERGUID)_Character, [in](GUIDSTRING)_Ghost, [out](INTEGER)_Bool) (2,0,257,1)
query CharacterIsSummon([in](CHARACTERGUID)_Character, [out](INTEGER)_Bool) (2,0,258,1)
query CharacterIsPartyFollower([in](CHARACTERGUID)_Character, [out](INTEGER)_Bool) (2,0,259,1)
query CharacterIsPolymorphedInto([in](CHARACTERGUID)_Character, [in](STRING)_TargetRace, [out](INTEGER)_Bool) (2,0,260,1)
query CharacterIsPolymorphInteractionDisabled([in](CHARACTERGUID)_Character, [out](INTEGER)_Bool) (2,0,261,1)
query CharacterGameMaster([in](CHARACTERGUID)_Character, [out](INTEGER)_Bool) (2,0,262,1)
query CharacterIsPlayer([in](CHARACTERGUID)_Character, [out](INTEGER)_Bool) (2,0,263,1)
query CharacterHasLinkedGhost([in](CHARACTERGUID)_Character, [out](INTEGER)_Bool) (2,0,264,1)
call CharacterReservePolymorphShape((CHARACTERGUID)_Character, (STRING)_Race) (1,0,265,1)
call CharacterSetForceSynch((CHARACTERGUID)_Character, (INTEGER)_Bool) (1,0,266,1)
call CharacterSetForceUpdate((CHARACTERGUID)_Character, (INTEGER)_Bool) (1,0,267,1)
call CharacterTransform((CHARACTERGUID)_Character, (STRING)_ObjectTemplate, (INTEGER)_ReplaceScripts, (INTEGER)_ReplaceScale, (INTEGER)_ReplaceStats, (INTEGER)_ReplaceEquipment, (INTEGER)_ReplaceSkills, (INTEGER)_UseCustomLooks, (INTEGER)_ReleasePlayerData) (1,0,268,1)
call CharacterTransformFromCharacter((CHARACTERGUID)_Target, (CHARACTERGUID)_Source, (INTEGER)_ReplaceScripts, (INTEGER)_ReplaceScale, (INTEGER)_ReplaceStats, (INTEGER)_ReplaceEquipment, (INTEGER)_ReplaceSkills, (INTEGER)_UseCustomLooks, (INTEGER)_ReleasePlayerData) (1,0,269,1)
call CharacterTransformAppearanceTo((CHARACTERGUID)_Character, (CHARACTERGUID)_Target, (INTEGER)_CopyEquipment, (INTEGER)_CopyDisplayNameAndIcon) (1,0,270,1)
call CharacterTransformAppearanceToWithEquipmentSet((CHARACTERGUID)_Character, (CHARACTERGUID)_Target, (STRING)_EquipmentSet, (INTEGER)_CopyDisplayNameAndIcon) (1,0,271,1)
query CharacterCanSpotCrimes([in](CHARACTERGUID)_Character, [out](INTEGER)_Bool) (2,0,272,1)
query CharacterCanReactToCrime([in](CHARACTERGUID)_Character, [in](STRING)_CrimeType, [out](INTEGER)_Bool) (2,0,273,1)
call CharacterReceivedTag((CHARACTERGUID)_Character, (STRING)_Tag) (1,0,274,1)
call CharacterAddPreferredAiTargetTag((CHARACTERGUID)_Character, (STRING)_Tag) (1,0,275,1)
call CharacterRemovePreferredAiTargetTag((CHARACTERGUID)_Character, (STRING)_Tag) (1,0,276,1)
query CharacterGetRace([in](CHARACTERGUID)_Player, [in](INTEGER)_CanPolymorphOverride, [out](STRING)_Race) (2,0,277,1)
query CharacterGetOrigin([in](CHARACTERGUID)_Player, [in](INTEGER)_CanPolymorphOverride, [out](STRING)_Origin) (2,0,278,1)
query CharacterGetInstrument([in](CHARACTERGUID)_Player, [out](STRING)_Instrument) (2,0,279,1)
query CharacterGetHenchmanPresetPrice([in](CHARACTERGUID)_Owner, [in](STRING)_Preset, [out](INTEGER)_Price) (2,0,280,1)
call CharacterOriginIntroStopped((CHARACTERGUID)_Character) (1,0,281,1)
call CharacterSetDoNotFaceFlag((CHARACTERGUID)_Character, (INTEGER)_Value) (1,0,282,1)
call CharacterSetReadyCheckBlocked((CHARACTERGUID)_Character, (INTEGER)_Value) (1,0,283,1)
call CharacterSetCorpseLootable((CHARACTERGUID)_Character, (INTEGER)_Value) (1,0,284,1)
call CharacterSetDetached((CHARACTERGUID)_Character, (INTEGER)_Value) (1,0,285,1)
call CharacterCloneSkillsTo((CHARACTERGUID)_From, (CHARACTERGUID)_To, (INTEGER)_MemorizedOnly) (1,0,286,1)
event CharacterDied((CHARACTERGUID)_Character) (3,0,287,1)
event CharacterResurrected((CHARACTERGUID)_Character) (3,0,288,1)
event CharacterPrecogDying((CHARACTERGUID)_Character) (3,0,289,1)
event CharacterDying((CHARACTERGUID)_Character) (3,0,290,1)
event CharacterTemplateDied((STRING)_TemplateName) (3,0,291,1)
event CharacterStatusAttempt((CHARACTERGUID)_Character, (STRING)_Status, (GUIDSTRING)_Causee) (3,0,292,1)
event CharacterStatusApplied((CHARACTERGUID)_Character, (STRING)_Status, (GUIDSTRING)_Causee) (3,0,293,1)
event CharacterStatusRemoved((CHARACTERGUID)_Character, (STRING)_Status, (GUIDSTRING)_Causee) (3,0,294,1)
event CharacterUsedItem((CHARACTERGUID)_Character, (ITEMGUID)_Item) (3,0,295,1)
event CharacterUsedItemTemplate((CHARACTERGUID)_Character, (STRING)_Template, (ITEMGUID)_Item) (3,0,296,1)
event CharacterUsedItemFailed((CHARACTERGUID)_Character, (ITEMGUID)_Item) (3,0,297,1)
event CharacterPreMovedItem((CHARACTERGUID)_Character, (ITEMGUID)_Item) (3,0,298,1)
event CharacterMovedItem((CHARACTERGUID)_Character, (ITEMGUID)_Item) (3,0,299,1)
event CharacterMovedItemTemplate((CHARACTERGUID)_Character, (STRING)_Template) (3,0,300,1)
event CharacterEnteredRegion((CHARACTERGUID)_Character, (STRING)_Region) (3,0,301,1)
event CharacterLeftRegion((CHARACTERGUID)_Character, (STRING)_Region) (3,0,302,1)
event CharacterSawCharacter((CHARACTERGUID)_Character, (CHARACTERGUID)_OtherCharacter) (3,0,303,1)
event CharacterSawSneakingCharacter((CHARACTERGUID)_Character, (CHARACTERGUID)_OtherCharacter) (3,0,304,1)
event CharacterLostSightOfCharacter((CHARACTERGUID)_Character, (CHARACTERGUID)_OtherCharacter) (3,0,305,1)
event CharacterBlockedBy((CHARACTERGUID)_Defender, (CHARACTERGUID)_AttackOwner, (CHARACTERGUID)_Attacker) (3,0,306,1)
event CharacterMissedBy((CHARACTERGUID)_Defender, (CHARACTERGUID)_AttackOwner, (CHARACTERGUID)_Attacker) (3,0,307,1)
event CharacterCriticalHitBy((CHARACTERGUID)_Defender, (CHARACTERGUID)_AttackOwner, (CHARACTERGUID)_Attacker) (3,0,308,1)
event CharacterKilledBy((CHARACTERGUID)_Defender, (CHARACTERGUID)_AttackOwner, (CHARACTERGUID)_Attacker) (3,0,309,1)
event CharacterTemplateKilledByCharacter((STRING)_CharacterTemplate, (CHARACTERGUID)_Killer) (3,0,310,1)
event CharacterStartAttackObject((GUIDSTRING)_Defender, (CHARACTERGUID)_AttackOwner, (CHARACTERGUID)_Attacker) (3,0,311,1)
event CharacterStartAttackPosition((REAL)_x, (REAL)_y, (REAL)_z, (CHARACTERGUID)_AttackOwner, (CHARACTERGUID)_Attacker) (3,0,312,1)
event CharacterChangedAlginmentToCharacter((CHARACTERGUID)_Character, (CHARACTERGUID)_OtherCharacter, (INTEGER)_NewRelation) (3,0,313,1)
event CharacterEnteredTrigger((CHARACTERGUID)_Character, (TRIGGERGUID)_Trigger) (3,0,314,1)
event CharacterReceivedDamage((CHARACTERGUID)_Character, (INTEGER)_Percentage, (GUIDSTRING)_Source) (3,0,315,1)
event CharacterVitalityChanged((CHARACTERGUID)_Character, (INTEGER)_Percentage) (3,0,316,1)
event CharacterLeftTrigger((CHARACTERGUID)_Character, (TRIGGERGUID)_Trigger) (3,0,317,1)
event CharacterPickpocketSuccess((CHARACTERGUID)_Player, (CHARACTERGUID)_NPC, (ITEMGUID)_Item, (INTEGER)_Amount) (3,0,318,1)
event CharacterAttitudeTowardsPlayerChanged((CHARACTERGUID)_Character, (CHARACTERGUID)_Player, (INTEGER)_NewAttitude) (3,0,319,1)
event ItemSendToHomesteadEvent((CHARACTERGUID)_Player, (ITEMGUID)_Item) (3,0,320,1)
event CharacterItemEvent((CHARACTERGUID)_Character, (ITEMGUID)_Item, (STRING)_Event) (3,0,321,1)
event CharacterUsedSkill((CHARACTERGUID)_Character, (STRING)_Skill, (STRING)_SkillType, (STRING)_SkillElement) (3,0,322,1)
event CharacterUsedSkillAtPosition((CHARACTERGUID)_Character, (REAL)_X, (REAL)_Y, (REAL)_Z, (STRING)_Skill, (STRING)_SkillType, (STRING)_SkillElement) (3,0,323,1)
event CharacterUsedSkillOnTarget((CHARACTERGUID)_Character, (GUIDSTRING)_Target, (STRING)_Skill, (STRING)_SkillType, (STRING)_SkillElement) (3,0,324,1)
event CharacterUsedSkillOnZoneWithTarget((CHARACTERGUID)_Character, (GUIDSTRING)_Target, (STRING)_Skill, (STRING)_SkillType, (STRING)_SkillElement) (3,0,325,1)
event CharacterUsedSkillInTrigger((CHARACTERGUID)_Character, (STRING)_Skill, (STRING)_SkillType, (STRING)_SkillElement, (TRIGGERGUID)_Trigger) (3,0,326,1)
event CharacterLearnedSkill((CHARACTERGUID)_Character, (STRING)_Skill) (3,0,327,1)
event SkillCast((CHARACTERGUID)_Character, (STRING)_Skill, (STRING)_SkillType, (STRING)_SkillElement) (3,0,328,1)
event RequestPickpocket((CHARACTERGUID)_Player, (CHARACTERGUID)_NPC) (3,0,329,1)
event CharacterPickpocketFailed((CHARACTERGUID)_Player, (CHARACTERGUID)_NPC) (3,0,330,1)
event CharacterLootedCharacterCorpse((CHARACTERGUID)_Player, (CHARACTERGUID)_Corpse) (3,0,331,1)
event RequestTrade((CHARACTERGUID)_Character, (CHARACTERGUID)_Trader) (3,0,332,1)
event HappyWithDeal((CHARACTERGUID)_Character, (CHARACTERGUID)_Trader, (INTEGER)_CharacterValue, (INTEGER)_TraderValue) (3,0,333,1)
event TradeEnds((CHARACTERGUID)_Character, (CHARACTERGUID)_Trader) (3,0,334,1)
event CharacterScriptFrameFinished((CHARACTERGUID)_Character, (STRING)_FrameID) (3,0,335,1)
event CharacterCharacterEvent((CHARACTERGUID)_Character1, (CHARACTERGUID)_Character2, (STRING)_Event) (3,0,336,1)
event CharacterRelationChangedTo((CHARACTERGUID)_Character, (CHARACTERGUID)_OtherCharacter, (INTEGER)_Attitude) (3,0,337,1)
event CharacterDestroyedItem((CHARACTERGUID)_Character, (ITEMGUID)_Item) (3,0,338,1)
event CharacterDestroyedItemTemplate((CHARACTERGUID)_Character, (STRING)_ItemTemplate) (3,0,339,1)
event CharacterDisplayTextEnded((CHARACTERGUID)_Character, (STRING)_DisplayText) (3,0,340,1)
event CharacterSetTemporaryRelationsFailed((CHARACTERGUID)_Character1, (CHARACTERGUID)_Character2) (3,0,341,1)
event CharacterMadePlayer((CHARACTERGUID)_Character) (3,0,342,1)
event CharacterLeveledUp((CHARACTERGUID)_Character) (3,0,343,1)
event CharacterUnlockedTalent((CHARACTERGUID)_Character, (STRING)_Talent) (3,0,344,1)
event CharacterLockedTalent((CHARACTERGUID)_Character, (STRING)_Talent) (3,0,345,1)
event CharacterBaseAbilityChanged((CHARACTERGUID)_Character, (STRING)_Ability, (INTEGER)_OldBaseValue, (INTEGER)_NewBaseValue) (3,0,346,1)
event MessageBoxClosed((CHARACTERGUID)_Character, (STRING)_Message) (3,0,347,1)
event MessageBoxYesNoClosed((CHARACTERGUID)_Character, (STRING)_Message, (INTEGER)_Result) (3,0,348,1)
event MessageBoxChoiceClosed((CHARACTERGUID)_Character, (STRING)_Message, (STRING)_ResultChoice) (3,0,349,1)
event TutorialBoxClosed((CHARACTERGUID)_Character, (STRING)_Message) (3,0,350,1)
event CharacterTraitChanged((CHARACTERGUID)_Character, (STRING)_Trait) (3,0,351,1)
event CharacterGuarded((CHARACTERGUID)_Character) (3,0,352,1)
event CharacterWentOnStage((CHARACTERGUID)_Character, (INTEGER)_Bool) (3,0,353,1)
event CharacterReservedUserIDChanged((CHARACTERGUID)_Character, (INTEGER)_OldUserID, (INTEGER)_NewUserID) (3,0,354,1)
event CharacterAddedToGroup((CHARACTERGUID)_Character) (3,0,355,1)
event CharacterDetachedFromGroup((CHARACTERGUID)_Character) (3,0,356,1)
event CharacterStartLockpickingItem((CHARACTERGUID)_Character, (ITEMGUID)_Item) (3,0,357,1)
event CharacterStoppedLockpickingItem((CHARACTERGUID)_Character, (ITEMGUID)_Item) (3,0,358,1)
event CharacterStoppedUsingItem((CHARACTERGUID)_Character, (ITEMGUID)_Item) (3,0,359,1)
event CharacterStoppedCombiningItems((CHARACTERGUID)_Character, (ITEMGUID)_ItemA, (ITEMGUID)_ItemB, (ITEMGUID)_ItemC, (ITEMGUID)_ItemD, (ITEMGUID)_ItemE) (3,0,360,1)
event CharacterTurnedToGhost((CHARACTERGUID)_Character, (CHARACTERGUID)_Ghost) (3,0,361,1)
event CharacterGhostDestroyed((CHARACTERGUID)_Character, (CHARACTERGUID)_Ghost) (3,0,362,1)
event CharacterGhostRevealed((CHARACTERGUID)_Character, (CHARACTERGUID)_Ghost) (3,0,363,1)
event CharacterOnCrimeSensibleActionNotification((CHARACTERGUID)_Character, (STRING)_CrimeRegion, (INTEGER)_CrimeID, (STRING)_PriortiyName, (STRING)_PrimaryDialog, (CHARACTERGUID)_Criminal1, (CHARACTERGUID)_Criminal2, (CHARACTERGUID)_Criminal3, (CHARACTERGUID)_Criminal4, (INTEGER)_IsPrimary) (3,0,364,1)
event CharacterSelectedAsBestUnavailableFallbackLead((CHARACTERGUID)_Character, (STRING)_CrimeRegion, (INTEGER)_UnavailableForCrimeID, (INTEGER)_BusyCrimeID, (CHARACTERGUID)_Criminal1, (CHARACTERGUID)_Criminal2, (CHARACTERGUID)_Criminal3, (CHARACTERGUID)_Criminal4) (3,0,365,1)
event CrimeIsRegistered((CHARACTERGUID)_Victim, (STRING)_CrimeType, (INTEGER)_CrimeID, (GUIDSTRING)_Evidence, (CHARACTERGUID)_Criminal1, (CHARACTERGUID)_Criminal2, (CHARACTERGUID)_Criminal3, (CHARACTERGUID)_Criminal4) (3,0,366,1)
event CharacterSelectedInCharCreation((CHARACTERGUID)_Character, (INTEGER)_UserID) (3,0,367,1)
event CharacterStartOriginIntroduction((CHARACTERGUID)_Character, (INTEGER)_UserID, (STRING)_Origin) (3,0,368,1)
event CharacterStopOriginIntroduction((CHARACTERGUID)_Character, (INTEGER)_UserID) (3,0,369,1)
event CharacterCreatedInArena((CHARACTERGUID)_Character, (INTEGER)_Team) (3,0,370,1)
event CharacterUsedSourcePoint((CHARACTERGUID)_Character) (3,0,371,1)
event SkillAdded((CHARACTERGUID)_Character, (STRING)_Skill, (INTEGER)_Learned) (3,0,372,1)
event SkillActivated((CHARACTERGUID)_Character, (STRING)_Skill) (3,0,373,1)
event SkillDeactivated((CHARACTERGUID)_Character, (STRING)_Skill) (3,0,374,1)
event CharacterTeleported((CHARACTERGUID)_Target, (CHARACTERGUID)_Cause, (REAL)_OldX, (REAL)_OldY, (REAL)_OldZ, (REAL)_NewX, (REAL)_NewY, (REAL)_NewZ, (STRING)_Skill) (3,0,375,1)
event CharacterMoveToAndTalkFailed((CHARACTERGUID)_Character, (GUIDSTRING)_Target, (STRING)_MoveID) (3,0,376,1)
event CharacterMoveToAndTalkRequestDialog((CHARACTERGUID)_Character, (GUIDSTRING)_Target, (STRING)_DialogID, (INTEGER)_IsAutomated, (STRING)_MoveID) (3,0,377,1)
event CharacterMoveToAndTalkRequestDialogFailedEvent((CHARACTERGUID)_Character, (GUIDSTRING)_Target, (STRING)_MoveId) (3,0,378,1)
event CharacterJoinedParty((CHARACTERGUID)_Character) (3,0,379,1)
event CharacterLeftParty((CHARACTERGUID)_Character) (3,0,380,1)
event CharacterLoadedInPreset((CHARACTERGUID)_Character) (3,0,381,1)
event CharacterPolymorphedInto((CHARACTERGUID)_Character, (STRING)_Race) (3,0,382,1)
event CharacterStoppedPolymorph((CHARACTERGUID)_Character) (3,0,383,1)
event CharacterTeleportToPyramid((CHARACTERGUID)_Character, (ITEMGUID)_Pyramid) (3,0,384,1)
event CharacterTeleportToWaypoint((CHARACTERGUID)_Character, (TRIGGERGUID)_Trigger) (3,0,385,1)
event CharacterTeleportToFleeWaypoint((CHARACTERGUID)_Character, (TRIGGERGUID)_Trigger) (3,0,386,1)
event CharacterStoleItem((CHARACTERGUID)_Character, (ITEMGUID)_Item, (REAL)_X, (REAL)_Y, (REAL)_Z, (CHARACTERGUID)_OldOwner, (ITEMGUID)_SrcContainer, (INTEGER)_Amount) (3,0,387,1)
event CharacterRequestsHomestead((CHARACTERGUID)_Character) (3,0,388,1)
event CharacterUnlockedRecipe((CHARACTERGUID)_Character, (STRING)_Recipe) (3,0,389,1)
call ItemDragToTrigger((ITEMGUID)_Item, (TRIGGERGUID)_Trigger) (1,0,390,1)
call ItemDragToPosition((ITEMGUID)_Item, (REAL)_X, (REAL)_Y, (REAL)_Z) (1,0,391,1)
call ItemMoveToTrigger((ITEMGUID)_Item, (TRIGGERGUID)_Trigger, (REAL)_Speed, (REAL)_Acceleration, (INTEGER)_UseRotation, (STRING)_Event, (INTEGER)_DoHits) (1,0,392,1)
call ItemMoveToPosition((ITEMGUID)_Item, (REAL)_X, (REAL)_Y, (REAL)_Z, (REAL)_Speed, (REAL)_Acceleration, (STRING)_Event, (INTEGER)_DoHits) (1,0,393,1)
call ItemToTransform((GUIDSTRING)_UUID, (REAL)_X, (REAL)_Y, (REAL)_Z, (REAL)_Pitch, (REAL)_Yaw, (REAL)_Roll, (INTEGER)_Amount, (CHARACTERGUID)_OwnerCharacter) (1,0,394,1)
call ItemToInventory((ITEMGUID)_Item, (GUIDSTRING)_TargetObject, (INTEGER)_Amount, (INTEGER)_ShowNotification, (INTEGER)_ClearOriginalOwner) (1,0,395,1)
call ItemTemplateDropFromCharacter((STRING)_ItemTemplate, (CHARACTERGUID)_Character, (INTEGER)_Count) (1,0,396,1)
call ItemScatterAt((ITEMGUID)_Item, (REAL)_X, (REAL)_Y, (REAL)_Z) (1,0,397,1)
call ItemTemplateRemoveFrom((STRING)_ItemTemplate, (GUIDSTRING)_Object, (INTEGER)_Count) (1,0,398,1)
call ItemTemplateRemoveFromParty((STRING)_ItemTemplate, (CHARACTERGUID)_Character, (INTEGER)_Count) (1,0,399,1)
call ItemTemplateRemoveFromUser((STRING)_ItemTemplate, (CHARACTERGUID)_Character, (INTEGER)_Count) (1,0,400,1)
call ItemTemplateAddTo((STRING)_ItemTemplate, (GUIDSTRING)_Object, (INTEGER)_Count, (INTEGER)_ShowNotification) (1,0,401,1)
query CreateItemTemplateAtPosition([in](STRING)_ItemTemplate, [in](REAL)_X, [in](REAL)_Y, [in](REAL)_Z, [out](ITEMGUID)_Item) (2,0,402,1)
query GetDebugItem([in](INTEGER)_Index, [out](STRING)_Template) (2,0,403,1)
call ItemDrop((ITEMGUID)_Item) (1,0,404,1)
call ItemRemove((ITEMGUID)_Item) (1,0,405,1)
call MoveAllItemsTo((GUIDSTRING)_FromObject, (GUIDSTRING)_ToObject, (INTEGER)_MoveEquippedArmor, (INTEGER)_MoveEquippedWeapons, (INTEGER)_ClearOriginalOwner) (1,0,406,1)
call ContainerIdentifyAll((ITEMGUID)_FromContainer) (1,0,407,1)
query ItemIsInCharacterInventory([in](ITEMGUID)_Item, [in](CHARACTERGUID)_Character, [out](INTEGER)_Bool) (2,0,408,1)
query ItemIsInPartyInventory([in](ITEMGUID)_Item, [in](CHARACTERGUID)_Character, [in](INTEGER)_MoveAndReport, [out](INTEGER)_Bool) (2,0,409,1)
query ItemIsInUserInventory([in](ITEMGUID)_Item, [in](CHARACTERGUID)_Character, [in](INTEGER)_MoveAndReport, [out](INTEGER)_Bool) (2,0,410,1)
query ItemIsInInventory([in](ITEMGUID)_Item, [out](INTEGER)_Bool) (2,0,411,1)
query ItemTemplateIsInCharacterInventory([in](CHARACTERGUID)_Character, [in](STRING)_Template, [out](INTEGER)_Count) (2,0,412,1)
query ItemTagIsInCharacterInventory([in](CHARACTERGUID)_Character, [in](STRING)_Tag, [out](INTEGER)_Count) (2,0,413,1)
query ItemTemplateTagIsInCharacterInventory([in](CHARACTERGUID)_Character, [in](STRING)_Template, [in](STRING)_Tag, [out](INTEGER)_Count) (2,0,414,1)
query ItemTemplateIsInPartyInventory([in](CHARACTERGUID)_Character, [in](STRING)_Template, [in](INTEGER)_MoveAndReport, [out](INTEGER)_Count) (2,0,415,1)
query ItemTemplateIsInUserInventory([in](CHARACTERGUID)_Character, [in](STRING)_Template, [in](INTEGER)_MoveAndReport, [out](INTEGER)_Count) (2,0,416,1)
query ItemTemplateGetDisplayString([in](GUIDSTRING)_Template, [out](STRING)_stringHandle, [out](STRING)_referenceString) (2,0,417,1)
query ItemTemplateIsInContainer([in](ITEMGUID)_Item, [in](STRING)_Template, [out](INTEGER)_Count) (2,0,418,1)
call ItemLock((ITEMGUID)_Item, (STRING)_Key) (1,0,419,1)
call ItemUnLock((ITEMGUID)_Item) (1,0,420,1)
query ItemIsOpened([in](ITEMGUID)_Item, [out](INTEGER)_Opened) (2,0,421,1)
query DoorIsOpening([in](ITEMGUID)_Door, [out](INTEGER)_Opening) (2,0,422,1)
query ItemIsClosed([in](ITEMGUID)_Item, [out](INTEGER)_Closed) (2,0,423,1)
query DoorIsClosing([in](ITEMGUID)_Door, [out](INTEGER)_Closing) (2,0,424,1)
query ItemIsLocked([in](ITEMGUID)_Item, [out](INTEGER)_Locked) (2,0,425,1)
query ItemIsContainer([in](ITEMGUID)_Item, [out](INTEGER)_IsContainer) (2,0,426,1)
query ItemHasOnUse([in](ITEMGUID)_Item, [in](STRING)_OnUse, [out](INTEGER)_Bool) (2,0,427,1)
call ItemLockUnEquip((ITEMGUID)_Item, (INTEGER)_lock) (1,0,428,1)
call ItemIsPoisoned((CHARACTERGUID)_Item, (INTEGER)_IsPoisoned) (1,0,429,1)
query ItemIsTorch([in](ITEMGUID)_Item, [out](INTEGER)_Bool) (2,0,430,1)
query ItemIsEquipable([in](ITEMGUID)_Item, [out](INTEGER)_Bool) (2,0,431,1)
call ItemOpen((ITEMGUID)_Item) (1,0,432,1)
call ItemClose((ITEMGUID)_Item) (1,0,433,1)
call ItemDestroy((ITEMGUID)_Item) (1,0,434,1)
query ItemIsDestroyed([in](ITEMGUID)_Item, [out](INTEGER)_Destroyed) (2,0,435,1)
call ItemClearOwner((ITEMGUID)_Item) (1,0,436,1)
query ItemGetOwner([in](ITEMGUID)_Item, [out](CHARACTERGUID)_Character) (2,0,437,1)
query ItemGetOriginalOwner([in](ITEMGUID)_Item, [out](CHARACTERGUID)_Character) (2,0,438,1)
query GetInventoryOwner([in](ITEMGUID)_Item, [out](GUIDSTRING)_Owner) (2,0,439,1)
call ItemSetCanInteract((ITEMGUID)_Item, (INTEGER)_bool) (1,0,440,1)
query ItemGetUseRemotely([in](ITEMGUID)_Item, [out](INTEGER)_bool) (2,0,441,1)
call ItemSetUseRemotely((ITEMGUID)_Item, (INTEGER)_bool) (1,0,442,1)
call ItemSetCanPickUp((ITEMGUID)_Item, (INTEGER)_bool) (1,0,443,1)
call ItemSetCanMove((ITEMGUID)_Item, (INTEGER)_bool) (1,0,444,1)
call ItemSetOwner((ITEMGUID)_Item, (CHARACTERGUID)_NewOwner) (1,0,445,1)
call ItemSetOriginalOwner((ITEMGUID)_Item, (CHARACTERGUID)_NewOwner) (1,0,446,1)
call ItemSetOnlyOwnerCanUse((ITEMGUID)_Item, (INTEGER)_bool) (1,0,447,1)
call ItemSetStoryItem((ITEMGUID)_Item, (INTEGER)_bool) (1,0,448,1)
call ItemLaunchIterator((STRING)_Event) (1,0,449,1)
query ItemIsStoryItem([in](ITEMGUID)_Item, [out](INTEGER)_Bool) (2,0,450,1)
call ItemCreateAtTrigger((TRIGGERGUID)_Trigger, (STRING)_TemplateId) (1,0,451,1)
call CreateKickstarterMessageInABottleItemAtTrigger((TRIGGERGUID)_Trigger, (STRING)_TemplateId) (1,0,452,1)
call ItemRotateY((ITEMGUID)_Item, (REAL)_Angle, (REAL)_Speed) (1,0,453,1)
call ItemRotateToAngleY((ITEMGUID)_Item, (REAL)_Angle, (REAL)_Speed) (1,0,454,1)
call ItemAddCharges((ITEMGUID)_Item, (INTEGER)_Charges) (1,0,455,1)
query ItemGetCharges([in](ITEMGUID)_Item, [out](INTEGER)_Charges) (2,0,456,1)
call ItemResetChargesToMax((ITEMGUID)_Item) (1,0,457,1)
query ItemGetMaxCharges([in](ITEMGUID)_Item, [out](INTEGER)_InitialCharges) (2,0,458,1)
call ItemSetDurability((ITEMGUID)_Item, (INTEGER)_Durability) (1,0,459,1)
query ItemGetDurability([in](ITEMGUID)_Item, [out](INTEGER)_Durability) (2,0,460,1)
query ItemGetAmount([in](ITEMGUID)_Item, [out](INTEGER)_Amount) (2,0,461,1)
query ItemGetHealthPoints([in](ITEMGUID)_Item, [out](INTEGER)_HP) (2,0,462,1)
query ItemIsDestructible([in](ITEMGUID)_Item, [out](INTEGER)_Bool) (2,0,463,1)
query ItemCanSitOn([in](ITEMGUID)_Item, [out](INTEGER)_Bool) (2,0,464,1)
query ItemIsLadder([in](ITEMGUID)_Item, [out](INTEGER)_Bool) (2,0,465,1)
query ItemTemplateCanSitOn([in](STRING)_Template, [out](INTEGER)_Bool) (2,0,466,1)
query ContainerGetGoldValue([in](ITEMGUID)_Container, [out](INTEGER)_Value) (2,0,467,1)
query ItemGetGoldValue([in](ITEMGUID)_Item, [out](INTEGER)_Value) (2,0,468,1)
call ItemSetForceSynch((ITEMGUID)_Item, (INTEGER)_Bool) (1,0,469,1)
call ItemSetKnown((ITEMGUID)_Item, (INTEGER)_Bool) (1,0,470,1)
query GetItemForItemTemplateInInventory([in](CHARACTERGUID)_Character, [in](STRING)_Template, [out](ITEMGUID)_Item) (2,0,471,1)
query GetItemForItemTemplateInPartyInventory([in](CHARACTERGUID)_Character, [in](STRING)_Template, [out](ITEMGUID)_Item) (2,0,472,1)
query CharacterFindTaggedItem([in](CHARACTERGUID)_Character, [in](STRING)_Tag, [out](ITEMGUID)_Item) (2,0,473,1)
query PartyFindTaggedItem([in](CHARACTERGUID)_Character, [in](STRING)_Tag, [in](INTEGER)_MoveAndReport, [out](ITEMGUID)_Item) (2,0,474,1)
query UserFindTaggedItem([in](CHARACTERGUID)_Character, [in](STRING)_Tag, [in](INTEGER)_MoveAndReport, [out](ITEMGUID)_Item) (2,0,475,1)
query CharacterRemoveTaggedLocalItems([in](CHARACTERGUID)_Character, [in](STRING)_Tag, [in](INTEGER)_Amount, [out](INTEGER)_AmountRemoved) (2,0,476,1)
query PartyRemoveTaggedLocalItems([in](CHARACTERGUID)_Character, [in](STRING)_Tag, [in](INTEGER)_Amount, [out](INTEGER)_AmountRemoved) (2,0,477,1)
query UserRemoveTaggedLocalItems([in](CHARACTERGUID)_Character, [in](STRING)_Tag, [in](INTEGER)_Amount, [out](INTEGER)_AmountRemoved) (2,0,478,1)
query UserTransferTaggedLocalItems([in](CHARACTERGUID)_Character, [in](GUIDSTRING)_ToObject, [in](STRING)_Tag, [in](INTEGER)_Amount, [out](INTEGER)_AmountTransfered) (2,0,479,1)
query ItemIsPublicDomain([in](ITEMGUID)_Item, [out](INTEGER)_Bool) (2,0,480,1)
event ItemAddedToCharacter((ITEMGUID)_Item, (CHARACTERGUID)_Character) (3,0,481,1)
event ItemOpened((ITEMGUID)_Item) (3,0,482,1)
event ItemTemplateOpening((STRING)_ItemTemplate, (ITEMGUID)_Item, (CHARACTERGUID)_Character) (3,0,483,1)
event ItemDestroying((ITEMGUID)_Item) (3,0,484,1)
event ItemDestroyed((ITEMGUID)_Item) (3,0,485,1)
event ItemTemplateDestroyed((STRING)_TemplateID, (ITEMGUID)_Item) (3,0,486,1)
event ItemCreatedAtTrigger((TRIGGERGUID)_Trigger, (STRING)_TemplateID, (ITEMGUID)_Item) (3,0,487,1)
event ItemClosed((ITEMGUID)_Item) (3,0,488,1)
event ItemDropped((ITEMGUID)_Item) (3,0,489,1)
event ItemEnteredTrigger((ITEMGUID)_Item, (TRIGGERGUID)_Trigger, (CHARACTERGUID)_Mover) (3,0,490,1)
event ItemTemplateEnteredTrigger((STRING)_ItemTemplate, (ITEMGUID)_Item, (TRIGGERGUID)_Trigger, (CHARACTERGUID)_Owner, (CHARACTERGUID)_Mover) (3,0,491,1)
event ItemLeftTrigger((ITEMGUID)_Item, (TRIGGERGUID)_Trigger, (CHARACTERGUID)_Mover) (3,0,492,1)
event ItemTemplateLeftTrigger((STRING)_ItemTemplate, (ITEMGUID)_Item, (TRIGGERGUID)_Trigger, (CHARACTERGUID)_Owner, (CHARACTERGUID)_Mover) (3,0,493,1)
event ItemAddedToContainer((ITEMGUID)_Item, (ITEMGUID)_Container) (3,0,494,1)
event ItemTemplateAddedToCharacter((GUIDSTRING)_ItemTemplate, (ITEMGUID)_Item, (CHARACTERGUID)_Character) (3,0,495,1)
event ItemTemplateAddedToContainer((STRING)_ItemTemplate, (ITEMGUID)_Item, (ITEMGUID)_Container) (3,0,496,1)
event ItemRemovedFromCharacter((ITEMGUID)_Item, (CHARACTERGUID)_Character) (3,0,497,1)
event ItemTemplateRemovedFromCharacter((STRING)_ItemTemplate, (ITEMGUID)_Item, (CHARACTERGUID)_Character) (3,0,498,1)
event ItemRemovedFromContainer((ITEMGUID)_Item, (ITEMGUID)_Container) (3,0,499,1)
event ItemTemplateRemovedFromContainer((STRING)_ItemTemplate, (ITEMGUID)_Item, (ITEMGUID)_Container) (3,0,500,1)
event ItemEquipped((ITEMGUID)_Item, (CHARACTERGUID)_Character) (3,0,501,1)
event ItemUnEquipped((ITEMGUID)_Item, (CHARACTERGUID)_Character) (3,0,502,1)
event ItemTemplateEquipped((STRING)_ItemTemplate, (CHARACTERGUID)_Character) (3,0,503,1)
event ItemTemplateUnEquipped((STRING)_ItemTemplate, (CHARACTERGUID)_Character) (3,0,504,1)
event ItemMoved((ITEMGUID)_Item) (3,0,505,1)
event ItemTemplateMoved((STRING)_ItemTemplate, (ITEMGUID)_Item) (3,0,506,1)
event ItemDisplayTextEnded((ITEMGUID)_Item, (STRING)_DisplayText) (3,0,507,1)
event ItemTemplateCombinedWithItemTemplate((STRING)_FirstItemTemplate, (STRING)_SecondItemTemplate, (STRING)_ThirdItemTemplate, (STRING)_ForthItemTemplate, (STRING)_FifthItemTemplate, (CHARACTERGUID)_Character, (ITEMGUID)_NewItem) (3,0,508,1)
event ItemStatusAttempt((ITEMGUID)_Item, (STRING)_Status, (GUIDSTRING)_Causee) (3,0,509,1)
event ItemStatusChange((ITEMGUID)_Item, (STRING)_Status, (GUIDSTRING)_Causee) (3,0,510,1)
event ItemStatusRemoved((ITEMGUID)_Item, (STRING)_Status, (GUIDSTRING)_Causee) (3,0,511,1)
event ItemStackedWith((ITEMGUID)_Item, (ITEMGUID)_StackedWithItem) (3,0,512,1)
event ItemMovedFromTo((ITEMGUID)_Item, (GUIDSTRING)_FromObject, (GUIDSTRING)_ToObject, (INTEGER)_IsTrade) (3,0,513,1)
event ItemsScatteredAt((REAL)_X, (REAL)_Y, (REAL)_Z) (3,0,514,1)
event TradeGenerationStarted((CHARACTERGUID)_Trader) (3,0,515,1)
event TradeGenerationEnded((CHARACTERGUID)_Trader) (3,0,516,1)
event ItemUnlocked((ITEMGUID)_Item, (CHARACTERGUID)_Character, (ITEMGUID)_Key) (3,0,517,1)
event ItemUnEquipFailed((ITEMGUID)_Item, (CHARACTERGUID)_Character) (3,0,518,1)
event ItemReceivedDamage((ITEMGUID)_Item) (3,0,519,1)
event ItemWentOnStage((GUIDSTRING)_Item, (INTEGER)_Bool) (3,0,520,1)
event ItemGhostRevealed((ITEMGUID)_Item) (3,0,521,1)
event ItemEnteredRegion((ITEMGUID)_Item, (STRING)_Region) (3,0,522,1)
event ItemLeftRegion((ITEMGUID)_Item, (STRING)_Region) (3,0,523,1)
call ItemLevelUp((ITEMGUID)_Item) (1,0,524,1)
call ItemLevelUpTo((ITEMGUID)_Item, (INTEGER)_Level) (1,0,525,1)
event RuneInserted((CHARACTERGUID)_Character, (ITEMGUID)_Item, (STRING)_RuneItemTemplate, (INTEGER)_Slot) (3,0,526,1)
event RuneRemoved((CHARACTERGUID)_Character, (ITEMGUID)_Item, (ITEMGUID)_Rune, (INTEGER)_Slot) (3,0,527,1)
query ItemGetRuneItemTemplate([in](ITEMGUID)_Item, [in](INTEGER)_Slot, [out](STRING)_Template) (2,0,528,1)
call ItemInsertRune((CHARACTERGUID)_Character, (ITEMGUID)_Item, (STRING)_RuneTemplate, (INTEGER)_Slot) (1,0,529,1)
query ItemRemoveRune([in](CHARACTERGUID)_Character, [in](ITEMGUID)_Item, [in](INTEGER)_Slot, [out](ITEMGUID)_Rune) (2,0,530,1)
call ItemAddDeltaModifier((ITEMGUID)_Item, (STRING)_Boost) (1,0,531,1)
query ItemHasDeltaModifier([in](ITEMGUID)_Item, [in](STRING)_Boost, [out](INTEGER)_Count) (2,0,532,1)
call DialogRequestStopForDialog((STRING)_Dialog, (GUIDSTRING)_Speaker) (1,0,533,1)
call DialogRequestStop((GUIDSTRING)_Speaker) (1,0,534,1)
query DialogGetNumberOfInvolvedPlayers([in](INTEGER)_InstanceID, [out](INTEGER)_Count) (2,0,535,1)
query DialogGetInvolvedPlayer([in](INTEGER)_InstanceID, [in](INTEGER)_Index, [out](GUIDSTRING)_Player) (2,0,536,1)
query DialogGetCategory([in](INTEGER)_InstanceID, [out](STRING)_Category) (2,0,537,1)
query DialogGetNumberOfInvolvedNPCs([in](INTEGER)_InstanceID, [out](INTEGER)_NumberOfNPCs) (2,0,538,1)
query DialogGetInvolvedNPC([in](INTEGER)_InstanceID, [in](INTEGER)_Index, [out](GUIDSTRING)_NPC) (2,0,539,1)
call GlobalSetFlag((STRING)_Flag) (1,0,540,1)
call GlobalClearFlag((STRING)_Flag) (1,0,541,1)
query GlobalGetFlag([in](STRING)_Flag, [out](INTEGER)_FlagState) (2,0,542,1)
call ObjectSetFlag((GUIDSTRING)_Target, (STRING)_Flag, (INTEGER)_DialogInstance) (1,0,543,1)
call ObjectShareFlag((GUIDSTRING)_Target, (STRING)_Flag) (1,0,544,1)
call GlobalShareFlag((STRING)_Flag) (1,0,545,1)
call ObjectClearFlag((GUIDSTRING)_Target, (STRING)_Flag, (INTEGER)_DialogInstance) (1,0,546,1)
query ObjectGetFlag([in](GUIDSTRING)_Target, [in](STRING)_Flag, [out](INTEGER)_FlagState) (2,0,547,1)
call ObjectSetDialogFlag((GUIDSTRING)_Target, (STRING)_Flag, (INTEGER)_DialogInstance) (1,0,548,1)
call ObjectClearDialogFlag((GUIDSTRING)_Target, (STRING)_Flag, (INTEGER)_DialogInstance) (1,0,549,1)
query ObjectGetDialogFlag([in](GUIDSTRING)_Target, [in](STRING)_Flag, [out](INTEGER)_FlagState) (2,0,550,1)
call UserSetFlag((CHARACTERGUID)_Character, (STRING)_Flag, (INTEGER)_DialogInstance) (1,0,551,1)
call UserClearFlag((CHARACTERGUID)_Character, (STRING)_Flag, (INTEGER)_DialogInstance) (1,0,552,1)
query UserGetFlag([in](CHARACTERGUID)_Character, [in](STRING)_Flag, [out](INTEGER)_FlagState) (2,0,553,1)
call PartySetFlag((CHARACTERGUID)_Character, (STRING)_Flag, (INTEGER)_DialogInstance) (1,0,554,1)
call PartyClearFlag((CHARACTERGUID)_Character, (STRING)_Flag, (INTEGER)_DialogInstance) (1,0,555,1)
query PartyGetFlag([in](CHARACTERGUID)_Character, [in](STRING)_Flag, [out](INTEGER)_FlagState) (2,0,556,1)
query DialogGetLocalFlag([in](INTEGER)_DialogInstance, [in](STRING)_LocalEvent, [out](INTEGER)_Value) (2,0,557,1)
call AddFeedbackString((CHARACTERGUID)_Character, (STRING)_Location, (STRING)_Question, (STRING)_Answer) (1,0,558,1)
call SaveFeedback() (1,0,559,1)
event DialogStarted((STRING)_Dialog, (INTEGER)_InstanceID) (3,0,560,1)
event AutomatedDialogStarted((STRING)_Dialog, (INTEGER)_InstanceID) (3,0,561,1)
event DualDialogStart((STRING)_Dialog, (INTEGER)_InstanceID) (3,0,562,1)
event AutomatedDialogEnded((STRING)_Dialog, (INTEGER)_InstanceID) (3,0,563,1)
event DialogEnded((STRING)_Dialog, (INTEGER)_InstanceID) (3,0,564,1)
event DialogRequestFailed((STRING)_Dialog, (INTEGER)_InstanceID) (3,0,565,1)
event DialogActorJoined((STRING)_Dialog, (INTEGER)_InstanceID, (GUIDSTRING)_Actor) (3,0,566,1)
event DialogActorLeft((STRING)_Dialog, (INTEGER)_InstanceID, (GUIDSTRING)_Actor) (3,0,567,1)
event AutomatedDialogRequestFailed((STRING)_Dialog, (INTEGER)_InstanceID) (3,0,568,1)
event DialogStartRequested((GUIDSTRING)_Target, (GUIDSTRING)_Player) (3,0,569,1)
event GlobalFlagSet((STRING)_FlagName) (3,0,570,1)
event GlobalFlagCleared((STRING)_FlagName) (3,0,571,1)
event ObjectFlagSet((STRING)_FlagName, (GUIDSTRING)_Speaker, (INTEGER)_DialogInstance) (3,0,572,1)
event ObjectFlagShared((STRING)_FlagName, (GUIDSTRING)_Speaker, (INTEGER)_NewValue) (3,0,573,1)
event ObjectFlagCleared((STRING)_FlagName, (GUIDSTRING)_Speaker, (INTEGER)_DialogInstance) (3,0,574,1)
event PersuasionResult((CHARACTERGUID)_Character, (INTEGER)_Success, (STRING)_Dialog) (3,0,575,1)
query ObjectIsCharacter([in](GUIDSTRING)_Object, [out](INTEGER)_Bool) (2,0,576,1)
query GetStatString([in](GUIDSTRING)_Object, [out](STRING)_Statname) (2,0,577,1)
query ObjectExists([in](GUIDSTRING)_Object, [out](INTEGER)_Exists) (2,0,578,1)
query ObjectIsGlobal([in](GUIDSTRING)_Object, [out](INTEGER)_IsGlobal) (2,0,579,1)
query ObjectIsItem([in](GUIDSTRING)_Object, [out](INTEGER)_Bool) (2,0,580,1)
query ObjectIsInTrigger([in](GUIDSTRING)_Object, [in](TRIGGERGUID)_Trigger, [out](INTEGER)_Bool) (2,0,581,1)
query PositionIsInTrigger([in](REAL)_x, [in](REAL)_Y, [in](REAL)_Z, [in](TRIGGERGUID)_Trigger, [out](INTEGER)_Bool) (2,0,582,1)
query ObjectIsOnStage([in](GUIDSTRING)_Object, [out](INTEGER)_Bool) (2,0,583,1)
query FindValidPosition([in](REAL)_SourceX, [in](REAL)_SourceY, [in](REAL)_SourceZ, [in](REAL)_Radius, [in](GUIDSTRING)_Object, [out](REAL)_ValidPositionX, [out](REAL)_ValidPositionY, [out](REAL)_ValidPositionZ) (2,0,584,1)
query HasLineOfSight([in](GUIDSTRING)_Source, [in](GUIDSTRING)_Target, [out](INTEGER)_Bool) (2,0,585,1)
call PlayEffect((GUIDSTRING)_Object, (STRING)_FxName, (STRING)_Bone) (1,0,586,1)
query PlayLoopEffect([in](GUIDSTRING)_Object, [in](STRING)_FxName, [in](STRING)_BoneName, [out](INTEGER64)_FxHandle) (2,0,587,1)
call PlayBeamEffect((GUIDSTRING)_Object, (GUIDSTRING)_Target, (STRING)_FxName, (STRING)_SourceBone, (STRING)_TargetBone) (1,0,588,1)
query PlayLoopBeamEffect([in](GUIDSTRING)_Object, [in](GUIDSTRING)_Target, [in](STRING)_FxName, [in](STRING)_SourceBone, [in](STRING)_TargetBone, [out](INTEGER64)_FxHandle) (2,0,589,1)
call PlaySound((GUIDSTRING)_Object, (STRING)_SoundEvent) (1,0,590,1)
call PlaySoundResource((GUIDSTRING)_Object, (GUIDSTRING)_SoundResource) (1,0,591,1)
call DebugText((GUIDSTRING)_Object, (STRING)_Text) (1,0,592,1)
call DisplayText((GUIDSTRING)_Object, (STRING)_Text) (1,0,593,1)
call SetOnStage((GUIDSTRING)_Object, (INTEGER)_Bool) (1,0,594,1)
call SetVisible((GUIDSTRING)_Object, (INTEGER)_Bool) (1,0,595,1)
call ShowMapMarker((CHARACTERGUID)_Character, (STRING)_MarkerID, (INTEGER)_Show) (1,0,596,1)
call MapMarkerChangeLevel((STRING)_MarkerID, (STRING)_NewRegionID) (1,0,597,1)
call SetCameraDistanceOverride((REAL)_Distance) (1,0,598,1)
query GetMaxCameraDistance([out](REAL)_Distance) (2,0,599,1)
call TimerLaunch((STRING)_Timer, (INTEGER)_Time) (1,0,600,1)
call TimerCancel((STRING)_Timer) (1,0,601,1)
call TimerPause((STRING)_Timer) (1,0,602,1)
call TimerUnpause((STRING)_Timer) (1,0,603,1)
call MusicPlayForPeer((CHARACTERGUID)_Character, (STRING)_EventName) (1,0,604,1)
call MusicPlayForPeerWithInstrument((CHARACTERGUID)_Character, (CHARACTERGUID)_Character, (STRING)_EventName) (1,0,605,1)
call MusicPlayOnCharacter((CHARACTERGUID)_Character, (STRING)_EventName) (1,0,606,1)
call MusicPlayGeneral((STRING)_EventName) (1,0,607,1)
call MoviePlay((CHARACTERGUID)_Character, (STRING)_Event) (1,0,608,1)
call PlayMovieForDialog((CHARACTERGUID)_Character, (STRING)_DialogName, (STRING)_NodePrefix) (1,0,609,1)
call CameraActivate((CHARACTERGUID)_Character, (STRING)_Name, (REAL)_Time, (INTEGER)_HideUI, (INTEGER)_Smooth, (INTEGER)_HideShroud) (1,0,610,1)
call SetSelectorCameraMode((CHARACTERGUID)_Character, (INTEGER)_Bool) (1,0,611,1)
call QuestUpdate((CHARACTERGUID)_Character, (STRING)_Quest, (STRING)_Status) (1,0,612,1)
call QuestReceiveSharedUpdate((CHARACTERGUID)_SrcCharacter, (CHARACTERGUID)_Character, (STRING)_Quest, (STRING)_Status) (1,0,613,1)
query QuestUpdateExists([in](STRING)_Quest, [in](STRING)_Status, [out](INTEGER)_Result) (2,0,614,1)
call QuestAdd((CHARACTERGUID)_Character, (STRING)_Quest) (1,0,615,1)
query QuestAccepted([in](CHARACTERGUID)_Character, [in](STRING)_Quest, [out](INTEGER)_Bool) (2,0,616,1)
call QuestClose((CHARACTERGUID)_Character, (STRING)_Quest) (1,0,617,1)
call QuestCloseAll((STRING)_Quest) (1,0,618,1)
query QuestIsShared([in](CHARACTERGUID)_Character, [in](STRING)_Quest, [out](INTEGER)_Bool) (2,0,619,1)
query QuestIsSubquestEntry([in](STRING)_QuestID, [in](STRING)_StateID, [out](INTEGER)_Bool) (2,0,620,1)
query QuestIsMysteryEntry([in](STRING)_QuestID, [in](STRING)_StateID, [out](INTEGER)_Bool) (2,0,621,1)
call QuestAddSubquest((CHARACTERGUID)_Character, (STRING)_SubquestID, (STRING)_ParentQuestID) (1,0,622,1)
call SetInArena((GUIDSTRING)_Target, (INTEGER)_InArena) (1,0,623,1)
query IsInArena([in](GUIDSTRING)_Target, [out](INTEGER)_Bool) (2,0,624,1)
call SendArenaNotification((INTEGER)_NotificationType, (STRING)_StringParam, (INTEGER)_InNumberOfRounds) (1,0,625,1)
query QuestIsClosed([in](CHARACTERGUID)_Character, [in](STRING)_Quest, [out](INTEGER)_Bool) (2,0,626,1)
query QuestGetBroadcastLevel([in](STRING)_Quest, [out](STRING)_Level) (2,0,627,1)
call QuestSetCategory((STRING)_Quest, (STRING)_CategoryID) (1,0,628,1)
call QuestArchive((CHARACTERGUID)_Character, (STRING)_Quest, (INTEGER)_DoArchive) (1,0,629,1)
query QuestHasUpdate([in](CHARACTERGUID)_Character, [in](STRING)_Quest, [in](STRING)_Update, [out](INTEGER)_Bool) (2,0,630,1)
call QuestArchiveCategory((CHARACTERGUID)_Character, (STRING)_CategoryID, (INTEGER)_DoArchive) (1,0,631,1)
call AddSecret((CHARACTERGUID)_Character, (STRING)_Secret) (1,0,632,1)
call UnlockJournalRecipe((STRING)_RecipeID) (1,0,633,1)
call UnlockJournalMystery((CHARACTERGUID)_Character, (STRING)_MysteryID) (1,0,634,1)
call CloseJournalMystery((CHARACTERGUID)_Character, (STRING)_MysteryID) (1,0,635,1)
call GameEnd() (1,0,636,1)
call GameEndWithMovie((STRING)_Movie) (1,0,637,1)
call GameEndWithMovieRequestCallback((STRING)_CallbackID) (1,0,638,1)
call EnqueueGameEndMovie((INTEGER)_UserID, (STRING)_Movie, (STRING)_Music) (1,0,639,1)
call EnqueueGameEndDialogMovie((CHARACTERGUID)_Character, (STRING)_DialogName, (STRING)_PlaylistId, (STRING)_Music) (1,0,640,1)
call FinalizeGameEndMovieQueue((INTEGER)_UserID) (1,0,641,1)
call SetGameEndMovie((INTEGER)_UserID, (STRING)_Movie) (1,0,642,1)
call ShroudRender((INTEGER)_Enable) (1,0,643,1)
call DebugBreak((STRING)_Message) (1,0,644,1)
call FadeToBlack((CHARACTERGUID)_Character, (REAL)_Seconds, (INTEGER)_ToBlack, (STRING)_FadeID) (1,0,645,1)
call FadeToWhite((CHARACTERGUID)_Character, (REAL)_Seconds, (INTEGER)_ToWhite, (STRING)_FadeID) (1,0,646,1)
call FadeOutBlack((CHARACTERGUID)_Character, (REAL)_Seconds, (STRING)_FadeID) (1,0,647,1)
call FadeOutWhite((CHARACTERGUID)_Character, (REAL)_Seconds, (STRING)_FadeID) (1,0,648,1)
call FadeIn((CHARACTERGUID)_Character, (REAL)_Seconds, (STRING)_FadeID) (1,0,649,1)
call OpenCustomBookUI((CHARACTERGUID)_Character, (STRING)_Bookname) (1,0,650,1)
call AddEntryToCustomBook((STRING)_Bookname, (STRING)_Entryname) (1,0,651,1)
call RemoveEntryFromCustomBook((STRING)_Bookname, (STRING)_Entryname) (1,0,652,1)
call OpenWaypointUI((CHARACTERGUID)_Character, (STRING)_CurrentWaypoint, (ITEMGUID)_Item, (INTEGER)_IsFleeing) (1,0,653,1)
call CloseUI((CHARACTERGUID)_Character, (STRING)_UIName) (1,0,654,1)
call OpenCraftUI((CHARACTERGUID)_Character, (ITEMGUID)_Item) (1,0,655,1)
call UnlockWaypoint((STRING)_WaypointName, (TRIGGERGUID)_Trigger, (CHARACTERGUID)_Character) (1,0,656,1)
call LockWaypoint((STRING)_WaypointName, (CHARACTERGUID)_Character) (1,0,657,1)
call RegisterWaypoint((STRING)_WaypointName, (ITEMGUID)_Item) (1,0,658,1)
call UnlockSecretRegion((TRIGGERGUID)_SecretRegionTrigger) (1,0,659,1)
call LockSecretRegion((TRIGGERGUID)_SecretRegionTrigger) (1,0,660,1)
call CreateSurface((GUIDSTRING)_Source, (STRING)_SurfaceType, (REAL)_Radius, (REAL)_Lifetime) (1,0,661,1)
call CreateSurfaceAtPosition((REAL)_x, (REAL)_Y, (REAL)_Z, (STRING)_SurfaceType, (REAL)_Radius, (REAL)_Lifetime) (1,0,662,1)
call RemoveSurfaceLayer((GUIDSTRING)_Source, (INTEGER)_SurfaceLayer, (REAL)_Radius) (1,0,663,1)
call RemoveSurfaceLayerAtPosition((REAL)_x, (REAL)_Y, (REAL)_Z, (INTEGER)_SurfaceLayer, (REAL)_Radius) (1,0,664,1)
call CreatePuddle((GUIDSTRING)_Source, (STRING)_SurfaceType, (INTEGER)_CellAmountMin, (INTEGER)_CellAmountMax, (INTEGER)_GrowAmountMin, (INTEGER)_GrowAmountMax, (REAL)_GrowTime) (1,0,665,1)
call TransformSurface((GUIDSTRING)_Source, (STRING)_TransformType, (STRING)_TransformLayer, (REAL)_Radius, (REAL)_Lifetime, (GUIDSTRING)_Owner) (1,0,666,1)
call TransformSurfaceAtPosition((REAL)_X, (REAL)_Y, (REAL)_Z, (STRING)_TransformType, (STRING)_TransformLayer, (REAL)_Radius, (REAL)_Lifetime, (GUIDSTRING)_Owner) (1,0,667,1)
query GetSurfaceGroundAt([in](GUIDSTRING)_Target, [out](STRING)_Surface) (2,0,668,1)
query GetSurfaceCloudAt([in](GUIDSTRING)_Target, [out](STRING)_Surface) (2,0,669,1)
query GetSurfaceGroundOwnerAt([in](GUIDSTRING)_Target, [out](CHARACTERGUID)_OwnerCharacter, [out](ITEMGUID)_OwnerItem) (2,0,670,1)
query GetSurfaceCloudOwnerAt([in](GUIDSTRING)_Target, [out](GUIDSTRING)_OwnerCharacter, [out](GUIDSTRING)_OwnerItem) (2,0,671,1)
query GetSurfaceTypeIndex([in](STRING)_Surface, [out](INTEGER)_Index) (2,0,672,1)
query GetSurfaceNameByTypeIndex([in](INTEGER)_SurfaceIndex, [out](STRING)_SurfaceName) (2,0,673,1)
query DrawSurfaceOnPath([in](GUIDSTRING)_OwnerObject, [in](GUIDSTRING)_FollowObject, [in](STRING)_SurfaceType, [in](REAL)_Radius, [in](REAL)_LifeTime, [out](INTEGER64)_SurfaceActionHandle) (2,0,674,1)
call StopDrawSurfaceOnPath((INTEGER64)_SurfaceActionHandle) (1,0,675,1)
query GetSurfaceSize([in](GUIDSTRING)_Target, [in](INTEGER)_SurfaceLayer, [out](INTEGER)_SurfaceSize) (2,0,676,1)
query GetSurfaceTurns([in](GUIDSTRING)_Target, [in](INTEGER)_SurfaceLayer, [out](INTEGER)_SurfaceTurns) (2,0,677,1)
call PlayEffectAtPosition((STRING)_FxName, (REAL)_X, (REAL)_Y, (REAL)_Z) (1,0,678,1)
call PlayEffectAtPositionAndRotation((STRING)_FxName, (REAL)_X, (REAL)_Y, (REAL)_Z, (REAL)_Yangle) (1,0,679,1)
call PlayScaledEffectAtPosition((STRING)_FxName, (REAL)_Scale, (REAL)_X, (REAL)_Y, (REAL)_Z) (1,0,680,1)
query PlayLoopEffectAtPosition([in](STRING)_FxName, [in](REAL)_X, [in](REAL)_Y, [in](REAL)_Z, [out](INTEGER64)_FxHandle) (2,0,681,1)
query PlayScaledLoopEffectAtPosition([in](STRING)_FxName, [in](REAL)_Scale, [in](REAL)_X, [in](REAL)_Y, [in](REAL)_Z, [out](INTEGER64)_FxHandle) (2,0,682,1)
call EndCombat((INTEGER)_CombatID) (1,0,683,1)
call StopLoopEffect((INTEGER64)_FxHandle) (1,0,684,1)
call MakePlayerActive((CHARACTERGUID)_Target) (1,0,685,1)
query CombatGetNumberOfInvolvedPlayers([in](INTEGER)_CombatID, [out](INTEGER)_NumPlayers) (2,0,686,1)
query CombatGetNumberOfInvolvedPartyMembers([in](INTEGER)_CombatID, [out](INTEGER)_NumPartyMembers) (2,0,687,1)
query CombatGetInvolvedPlayer([in](INTEGER)_CombatID, [in](INTEGER)_PlayerIndex, [out](CHARACTERGUID)_Player) (2,0,688,1)
query CombatGetInvolvedPartyMember([in](INTEGER)_CombatID, [in](INTEGER)_PartyMemberIndex, [out](CHARACTERGUID)_PartyMember) (2,0,689,1)
query CombatGetIDForCharacter([in](CHARACTERGUID)_Player, [out](INTEGER)_CombatID) (2,0,690,1)
query IsCombatActive([in](INTEGER)_CombatID, [out](INTEGER)_Active) (2,0,691,1)
query CombatGetActiveEntity([in](INTEGER)_CombatID, [out](GUIDSTRING)_CurrentEntity) (2,0,692,1)
call CreateExplosion((GUIDSTRING)_Target, (STRING)_SkillID, (INTEGER)_CasterLevel) (1,0,693,1)
call CreateExplosionAtPosition((REAL)_X, (REAL)_Y, (REAL)_Z, (STRING)_SkillID, (INTEGER)_CasterLevel) (1,0,694,1)
call CreateProjectileStrikeAt((GUIDSTRING)_Target, (STRING)_SkillID, (INTEGER)_CasterLevel) (1,0,695,1)
call CreateProjectileStrikeAtPosition((REAL)_X, (REAL)_Y, (REAL)_Z, (STRING)_SkillID, (INTEGER)_CasterLevel) (1,0,696,1)
query GetMultiplayerCharacter([in](CHARACTERGUID)_Character, [out](CHARACTERGUID)_MultiplayerCharacter) (2,0,697,1)
call AutoSave() (1,0,698,1)
call ShowGameOverMenu() (1,0,699,1)
call OnCompanionDismissed((CHARACTERGUID)_Character) (1,0,700,1)
call ShowNotification((CHARACTERGUID)_Character, (STRING)_Text) (1,0,701,1)
call ShowError((CHARACTERGUID)_Character, (STRING)_Error) (1,0,702,1)
call ShowTutorial((CHARACTERGUID)_Character, (STRING)_Text, (STRING)_Category, (STRING)_Title, (INTEGER)_ControllerType, (INTEGER)_ModalType, (INTEGER)_Duration, (INTEGER)_Priority, (INTEGER)_Flags, (INTEGER)_MinimumPlaytimeInMinutes) (1,0,703,1)
call CompleteTutorial((CHARACTERGUID)_Character, (STRING)_Text) (1,0,704,1)
call UnlockAchievement((STRING)_AchievementID, (CHARACTERGUID)_Character) (1,0,705,1)
call ProgressAchievement((STRING)_AchievementID, (CHARACTERGUID)_Character, (INTEGER)_Progress) (1,0,706,1)
call SetAchievementProgress((STRING)_AchievementID, (INTEGER)_Value) (1,0,707,1)
call SetHomesteadKeyState((INTEGER)_State, (CHARACTERGUID)_Character) (1,0,708,1)
call EnableSendToHomestead((INTEGER)_Bool) (1,0,709,1)
call KillCombatFor((CHARACTERGUID)_Character) (1,0,710,1)
query HasKickstarterDialogReward([out](INTEGER)_Bool) (2,0,711,1)
query IsHardcoreMode([out](INTEGER)_Bool) (2,0,712,1)
query CharacterHasDLC([in](CHARACTERGUID)_Character, [in](STRING)_DLCName, [out](INTEGER)_HasDLC) (2,0,713,1)
query GetUserCount([out](INTEGER)_UserCount) (2,0,714,1)
call GenerateTreasure((ITEMGUID)_Item, (STRING)_TreasureID, (INTEGER)_Level, (CHARACTERGUID)_Character) (1,0,715,1)
call PlayAnimation((GUIDSTRING)_SourceObject, (STRING)_Animation, (STRING)_Event) (1,0,716,1)
query GetVarObject([in](GUIDSTRING)_Source, [in](STRING)_VarName, [out](GUIDSTRING)_UUID) (2,0,717,1)
call SetVarObject((GUIDSTRING)_Source, (STRING)_VarName, (GUIDSTRING)_Object) (1,0,718,1)
call ClearVarObject((GUIDSTRING)_Source, (STRING)_VarName) (1,0,719,1)
call SetScriptframe((GUIDSTRING)_Target, (STRING)_Scriptframe) (1,0,720,1)
call ClearScriptframe((GUIDSTRING)_Target) (1,0,721,1)
call SetTag((GUIDSTRING)_Source, (STRING)_Tag) (1,0,722,1)
call ClearTag((GUIDSTRING)_Source, (STRING)_Tag) (1,0,723,1)
query GetVarInteger([in](GUIDSTRING)_Source, [in](STRING)_VarName, [out](INTEGER)_VarValue) (2,0,724,1)
query GetVarFloat([in](GUIDSTRING)_Source, [in](STRING)_VarName, [out](REAL)_VarValue) (2,0,725,1)
query GetVarString([in](GUIDSTRING)_Source, [in](STRING)_VarName, [out](STRING)_VarValue) (2,0,726,1)
query GetVarFixedString([in](GUIDSTRING)_Source, [in](STRING)_VarName, [out](STRING)_VarValue) (2,0,727,1)
call SetVarInteger((GUIDSTRING)_Target, (STRING)_VarName, (INTEGER)_VarValue) (1,0,728,1)
call SetVarFloat((GUIDSTRING)_Target, (STRING)_VarName, (REAL)_VarValue) (1,0,729,1)
call SetVarString((GUIDSTRING)_Target, (STRING)_VarName, (STRING)_VarValue) (1,0,730,1)
call SetVarFixedString((GUIDSTRING)_Target, (STRING)_VarName, (STRING)_VarValue) (1,0,731,1)
call SetVarFloat3((GUIDSTRING)_Target, (STRING)_VarName, (REAL)_X, (REAL)_Y, (REAL)_Z) (1,0,732,1)
query GetVarFloat3([in](GUIDSTRING)_Target, [in](STRING)_VarName, [out](REAL)_X, [out](REAL)_Y, [out](REAL)_Z) (2,0,733,1)
query IsTagged([in](GUIDSTRING)_Target, [in](STRING)_Tag, [out](INTEGER)_Bool) (2,0,734,1)
call RemoveStatus((GUIDSTRING)_Target, (STRING)_Status) (1,0,735,1)
call RemoveHarmfulStatuses((GUIDSTRING)_Target) (1,0,736,1)
query HasActiveStatus([in](GUIDSTRING)_Target, [in](STRING)_Status, [out](INTEGER)_Bool) (2,0,737,1)
query HasAppliedStatus([in](GUIDSTRING)_Target, [in](STRING)_Status, [out](INTEGER)_Bool) (2,0,738,1)
query GetUUID([in](GUIDSTRING)_Target, [out](STRING)_UUID) (2,0,739,1)
query GetPosition([in](GUIDSTRING)_Target, [out](REAL)_X, [out](REAL)_Y, [out](REAL)_Z) (2,0,740,1)
query GetRotation([in](GUIDSTRING)_Target, [out](REAL)_X, [out](REAL)_Y, [out](REAL)_Z) (2,0,741,1)
query GetClosestPlayer([in](GUIDSTRING)_Target, [out](CHARACTERGUID)_Player, [out](REAL)_Distance) (2,0,742,1)
query GetClosestPlayerWithTalent([in](GUIDSTRING)_Target, [in](STRING)_Talent, [out](CHARACTERGUID)_Player, [out](REAL)_Distance) (2,0,743,1)
query GetClosestAlivePlayer([in](GUIDSTRING)_Target, [out](CHARACTERGUID)_Player, [out](REAL)_Distance) (2,0,744,1)
query GetClosestAliveUserPlayer([in](GUIDSTRING)_Target, [in](INTEGER)_UserID, [out](CHARACTERGUID)_Player, [out](REAL)_Distance) (2,0,745,1)
query GetClosestPlayerToPosition([in](REAL)_X, [in](REAL)_Y, [in](REAL)_Z, [out](CHARACTERGUID)_Player, [out](REAL)_Distance) (2,0,746,1)
call Transform((GUIDSTRING)_Object, (STRING)_ObjectTemplate, (INTEGER)_ReplaceScripts, (INTEGER)_ReplaceScale, (INTEGER)_ReplaceStats) (1,0,747,1)
call ApplyStatus((GUIDSTRING)_Object, (STRING)_Status, (REAL)_Duration, (INTEGER)_Force, (GUIDSTRING)_Source) (1,0,748,1)
query GetRegion([in](GUIDSTRING)_Object, [out](STRING)_Region) (2,0,749,1)
call SetStoryEvent((GUIDSTRING)_Object, (STRING)_Event) (1,0,750,1)
call RequestProcessed((CHARACTERGUID)_Character, (INTEGER)_RequestId, (INTEGER)_RequestAccepted) (1,0,751,1)
call IterateParty((CHARACTERGUID)_Character, (STRING)_Event) (1,0,752,1)
call IterateParties((STRING)_Event) (1,0,753,1)
call IterateUsers((STRING)_Event) (1,0,754,1)
query GetUserName([in](INTEGER)_UserId, [out](STRING)_UserName) (2,0,755,1)
query GetUserProfileID([in](INTEGER)_UserId, [out](STRING)_UserProfileID) (2,0,756,1)
call LoadGame((STRING)_Savegame) (1,0,757,1)
call LeaveParty((INTEGER)_UserId) (1,0,758,1)
call AddToParty((INTEGER)_Source, (INTEGER)_Target) (1,0,759,1)
call LoadPartyPreset((STRING)_Preset, (GUIDSTRING)_TeleportToTarget) (1,0,760,1)
query CrimeGetType([in](INTEGER)_CrimeID, [out](STRING)_Type) (2,0,761,1)
query CrimeGetDetectionRange([in](INTEGER)_CrimeID, [out](REAL)_Range) (2,0,762,1)
query CrimeGetTension([in](INTEGER)_CrimeID, [out](INTEGER)_Tension) (2,0,763,1)
query CrimeGetNewID([out](INTEGER)_CrimeID) (2,0,764,1)
query CrimeIsTensionOverWarningTreshold([in](CHARACTERGUID)_Character, [out](INTEGER)_Bool) (2,0,765,1)
call CrimeClearAll() (1,0,766,1)
query CrimeFindEvidence([in](INTEGER)_CrimeID, [in](CHARACTERGUID)_Searcher, [in](CHARACTERGUID)_Criminal1, [in](CHARACTERGUID)_Criminal2, [in](CHARACTERGUID)_Criminal3, [in](CHARACTERGUID)_Criminal4, [out](INTEGER)_EvidenceFoundForCurrentCrime, [out](INTEGER)_EvidenceFound, [out](INTEGER)_GuiltyFound) (2,0,767,1)
call CrimeInterrogationDone((INTEGER)_CrimeID, (CHARACTERGUID)_Interrogator, (INTEGER)_FoundEvidence, (CHARACTERGUID)_Criminal1, (CHARACTERGUID)_Criminal2, (CHARACTERGUID)_Criminal3, (CHARACTERGUID)_Criminal4) (1,0,768,1)
call CrimeConfrontationDone((INTEGER)_CrimeID, (CHARACTERGUID)_Interrogator) (1,0,769,1)
query CrimeGetLeadInvestigator([in](INTEGER)_CrimeID, [out](CHARACTERGUID)_LeadInvestigator) (2,0,770,1)
call SetCanFight((GUIDSTRING)_Target, (INTEGER)_Enabled) (1,0,771,1)
call SetCanJoinCombat((GUIDSTRING)_Target, (INTEGER)_Enabled) (1,0,772,1)
call InventoryLaunchIterator((GUIDSTRING)_InventoryHolder, (STRING)_Event, (STRING)_CompletionEvent) (1,0,773,1)
call InventoryLaunchTagIterator((GUIDSTRING)_InventoryHolder, (STRING)_TagA, (STRING)_OptionalTagB, (STRING)_Event, (STRING)_CompletionEvent) (1,0,774,1)
call InventoryLaunchTemplateIterator((GUIDSTRING)_InventoryHolder, (STRING)_Template, (STRING)_Event, (STRING)_CompletionEvent) (1,0,775,1)
call SetIsBoss((GUIDSTRING)_Target, (INTEGER)_Enabled) (1,0,776,1)
query IsBoss([in](GUIDSTRING)_Target, [out](INTEGER)_Bool) (2,0,777,1)
query GetDistanceTo([in](GUIDSTRING)_object1, [in](GUIDSTRING)_object2, [out](REAL)_Dist) (2,0,778,1)
query GetDistanceToPosition([in](GUIDSTRING)_Object, [in](REAL)_X, [in](REAL)_Y, [in](REAL)_Z, [out](REAL)_Dist) (2,0,779,1)
query GetAngleTo([in](REAL)_x0, [in](REAL)_z0, [in](REAL)_x1, [in](REAL)_z1, [out](INTEGER)_Angle) (2,0,780,1)
query GetWorldTransformFromLocal([in](GUIDSTRING)_Object, [in](REAL)_LocX, [in](REAL)_LocY, [in](REAL)_LocZ, [in](REAL)_LocRotX, [in](REAL)_LocRotY, [in](REAL)_LocRotZ, [out](REAL)_WorldX, [out](REAL)_WorldY, [out](REAL)_WorldZ, [out](REAL)_WorldRotX, [out](REAL)_WorldRotY, [out](REAL)_WorldRotZ) (2,0,781,1)
call SetCombatGroupID((GUIDSTRING)_Target, (STRING)_GroupID) (1,0,782,1)
call EndTurn((GUIDSTRING)_Target) (1,0,783,1)
call CrimeAreaSetTensionModifier((TRIGGERGUID)_CrimeArea, (INTEGER)_Modifier) (1,0,784,1)
query CrimeAreaGetTensionModifier([in](TRIGGERGUID)_CrimeArea, [out](INTEGER)_Modifier) (2,0,785,1)
call CrimeAreaResetTensionModifier((TRIGGERGUID)_CrimeArea) (1,0,786,1)
query CrimeGetVictim([in](INTEGER)_CrimeID, [out](CHARACTERGUID)_CrimeVictim) (2,0,787,1)
call CrimeTransferEvidenceTo((INTEGER)_CrimeID, (GUIDSTRING)_Target) (1,0,788,1)
query CrimeGetEvidence([in](INTEGER)_CrimeID, [in](INTEGER)_Index, [out](GUIDSTRING)_Evidence) (2,0,789,1)
query CrimeGetNumberOfEvidence([in](INTEGER)_CrimeID, [out](INTEGER)_NumEvidence) (2,0,790,1)
query CrimeIsContinuous([in](INTEGER)_CrimeID, [out](INTEGER)_Bool) (2,0,791,1)
call ShutdownCrimeSystem() (1,0,792,1)
query CrimeGetCriminals([in](INTEGER)_CrimeID, [out](CHARACTERGUID)_Criminal1, [out](CHARACTERGUID)_Criminal2, [out](CHARACTERGUID)_Criminal3, [out](CHARACTERGUID)_Criminal4) (2,0,793,1)
query CrimeIsAnyNPCGoingToReact([in](GUIDSTRING)_Criminal, [in](STRING)_CrimeType, [in](GUIDSTRING)_Victim, [in](REAL)_X, [in](REAL)_Y, [in](REAL)_Z, [out](INTEGER)_Bool) (2,0,794,1)
query CrimeTransferLeadershipTo([in](GUIDSTRING)_OldLead, [in](INTEGER)_CrimeID, [in](GUIDSTRING)_NewLead, [out](INTEGER)_Bool) (2,0,795,1)
call CrimeEnableInterrogation((GUIDSTRING)_NPC, (INTEGER)_Bool) (1,0,796,1)
call CrimeIgnoreAllCrimesForCriminal((GUIDSTRING)_Criminal, (GUIDSTRING)_NPC, (INTEGER)_IgnoreDuration) (1,0,797,1)
call CrimeResetInterrogationForCriminals((INTEGER)_CrimeID, (GUIDSTRING)_Criminal1, (GUIDSTRING)_Criminal2, (GUIDSTRING)_Criminal3, (GUIDSTRING)_Criminal4) (1,0,798,1)
call JumpToTurn((GUIDSTRING)_Target) (1,0,799,1)
call CrimeIgnoreCrime((INTEGER)_CrimeID, (GUIDSTRING)_NPC) (1,0,800,1)
query CrimeAddCriminal([in](INTEGER)_CrimeID, [in](GUIDSTRING)_Criminal, [out](INTEGER)_Bool) (2,0,801,1)
call NotifyCharacterCreationFinished() (1,0,802,1)
call SetHasDialog((GUIDSTRING)_Speaker, (INTEGER)_Dialog) (1,0,803,1)
call ShowArenaResult((INTEGER)_WinnerTeamId) (1,0,804,1)
call EnterCombat((GUIDSTRING)_Source, (GUIDSTRING)_Target) (1,0,805,1)
call LeaveCombat((GUIDSTRING)_Target) (1,0,806,1)
call SetFaction((GUIDSTRING)_Target, (STRING)_Faction) (1,0,807,1)
query GetFaction([in](GUIDSTRING)_Target, [out](STRING)_Faction) (2,0,808,1)
query GetTemplate([in](GUIDSTRING)_Target, [out](STRING)_Template) (2,0,809,1)
call SetInvulnerable_UseProcSetInvulnerable((GUIDSTRING)_Target, (INTEGER)_Bool) (1,0,810,1)
call UserRest((CHARACTERGUID)_Character, (STRING)_Restconsumable, (REAL)_PartyRadius, (REAL)_MinSafeDistance) (1,0,811,1)
call FireOsirisEvents() (1,0,812,1)
query IsSkillActive([in](GUIDSTRING)_Character, [in](STRING)_SkillID, [out](INTEGER)_Bool) (2,0,813,1)
call StartCameraSpline((SPLINEGUID)_Spline, (CHARACTERGUID)_Character, (REAL)_FadeTime, (INTEGER)_HideUI, (INTEGER)_Freeze, (INTEGER)_StartIndex) (1,0,814,1)
call StopCameraSpline((SPLINEGUID)_Spline, (CHARACTERGUID)_Character) (1,0,815,1)
call ApplyDamage((GUIDSTRING)_Object, (INTEGER)_Damage, (STRING)_DamageType, (GUIDSTRING)_Source) (1,0,816,1)
query IsSourceSkill([in](STRING)_SkillID, [out](INTEGER)_Bool) (2,0,817,1)
call MakePeace((CHARACTERGUID)_Source, (CHARACTERGUID)_Target, (INTEGER)_IgnoreVote) (1,0,818,1)
call MakeWar((CHARACTERGUID)_Source, (CHARACTERGUID)_Target, (INTEGER)_IgnoreVote) (1,0,819,1)
call ActivatePersistentLevelTemplateWithCombat((LEVELTEMPLATEGUID)_LevelTemplate) (1,0,820,1)
call ActivatePersistentLevelTemplate((LEVELTEMPLATEGUID)_LevelTemplate) (1,0,821,1)
query GetStatusType([in](STRING)_StatusID, [out](STRING)_StatusType) (2,0,822,1)
query GetStatusTurns([in](GUIDSTRING)_Source, [in](STRING)_StatusID, [out](INTEGER)_Turns) (2,0,823,1)
query GetHealStat([in](STRING)_StatusID, [out](STRING)_HealStat) (2,0,824,1)
call ReadyCheckStart((GUIDSTRING)_Player, (STRING)_Id) (1,0,825,1)
query IsGameLevel([in](STRING)_LevelName, [out](INTEGER)_Bool) (2,0,826,1)
query IsCharacterCreationLevel([in](STRING)_LevelName, [out](INTEGER)_Bool) (2,0,827,1)
query HasRecipeUnlockedWithIngredient([in](CHARACTERGUID)_Player, [in](GUIDSTRING)_ItemTemplate, [out](INTEGER)_Bool) (2,0,828,1)
query GetGlobalPriceModifier([out](INTEGER)_Modifier) (2,0,829,1)
call SetGlobalPriceModifier((INTEGER)_Modifier) (1,0,830,1)
query AttributeGetDifficultyLevelMappedValue([in](STRING)_Difficulty, [in](INTEGER)_Level, [out](INTEGER)_AttributeValue) (2,0,831,1)
call SonyRealtimeMultiplayerEvent((CHARACTERGUID)_Character, (STRING)_EventName) (1,0,832,1)
event TimerFinished((STRING)_Timer) (3,0,833,1)
event RegionStarted((STRING)_NewRegion) (3,0,834,1)
event GameStarted((STRING)_LevelName, (INTEGER)_IsEditorMode) (3,0,835,1)
event RegionEnded((STRING)_Region) (3,0,836,1)
event CreditsEnded() (3,0,837,1)
event DLCUpdated((STRING)_DLCName, (INTEGER)_UserID, (INTEGER)_Installed) (3,0,838,1)
event CharacterCreationStarted((STRING)_Level) (3,0,839,1)
event CharacterCreationFinished((CHARACTERGUID)_Character) (3,0,840,1)
event GameBookInterfaceClosed((ITEMGUID)_Item, (CHARACTERGUID)_Character) (3,0,841,1)
event SavegameLoaded((INTEGER)_Major, (INTEGER)_Minor, (INTEGER)_Revision, (INTEGER)_Build) (3,0,842,1)
event MovieFinished((STRING)_MovieName) (3,0,843,1)
event MoviePlaylistFinished((STRING)_MovieName) (3,0,844,1)
event DifficultyChanged((INTEGER)_DifficultyLevel) (3,0,845,1)
event GameModeStarted((STRING)_GameMode, (INTEGER)_IsEditorMode) (3,0,846,1)
event StoryEvent((GUIDSTRING)_Object, (STRING)_Event) (3,0,847,1)
event CanMoveItem((CHARACTERGUID)_Character, (ITEMGUID)_Item, (INTEGER)_RequestID) (3,0,848,1)
event CanPickupItem((CHARACTERGUID)_Character, (ITEMGUID)_Item, (INTEGER)_RequestID) (3,0,849,1)
event CanUseItem((CHARACTERGUID)_Character, (ITEMGUID)_Item, (INTEGER)_RequestID) (3,0,850,1)
event CanLockpickItem((CHARACTERGUID)_Character, (ITEMGUID)_Item, (INTEGER)_RequestID) (3,0,851,1)
event CanCombineItem((CHARACTERGUID)_Character, (ITEMGUID)_ItemA, (ITEMGUID)_ItemB, (ITEMGUID)_ItemC, (ITEMGUID)_ItemD, (ITEMGUID)_ItemE, (INTEGER)_RequestID) (3,0,852,1)
event UserConnected((INTEGER)_UserID, (STRING)_UserName, (STRING)_UserProfileID) (3,0,853,1)
event FadeOutDone((INTEGER)_UserID, (STRING)_FadeID) (3,0,854,1)
event FadeInDone((INTEGER)_UserID, (STRING)_FadeID) (3,0,855,1)
event FadeDone((INTEGER)_UserID, (STRING)_FadeID) (3,0,856,1)
event ClearFadeDone((INTEGER)_UserID, (STRING)_FadeID) (3,0,857,1)
event UserDisconnected((INTEGER)_UserID, (STRING)_UserName, (STRING)_UserProfileID) (3,0,858,1)
event UserEvent((INTEGER)_UserID, (STRING)_UserEvent) (3,0,859,1)
event UserMakeWar((INTEGER)_SourceUserID, (INTEGER)_TargetUserID, (INTEGER)_War) (3,0,860,1)
event AttackedByObject((GUIDSTRING)_Defender, (GUIDSTRING)_AttackerOwner, (GUIDSTRING)_Attacker, (STRING)_DamageType, (STRING)_DamageSource) (3,0,861,1)
event FleeCombat((CHARACTERGUID)_Character) (3,0,862,1)
event CrimeInterrogationRequest((STRING)_CrimeRegion, (INTEGER)_CrimeID, (CHARACTERGUID)_Interrogator, (CHARACTERGUID)_Criminal1, (CHARACTERGUID)_Criminal2, (CHARACTERGUID)_Criminal3, (CHARACTERGUID)_Criminal4, (STRING)_InterrogateDialog) (3,0,863,1)
event OnCrimeResolved((INTEGER)_CrimeID, (CHARACTERGUID)_Victim, (CHARACTERGUID)_Criminal1, (CHARACTERGUID)_Criminal2, (CHARACTERGUID)_Criminal3, (CHARACTERGUID)_Criminal4) (3,0,864,1)
event OnCrimeRemoved((INTEGER)_CrimeID, (CHARACTERGUID)_Victim, (CHARACTERGUID)_Criminal1, (CHARACTERGUID)_Criminal2, (CHARACTERGUID)_Criminal3, (CHARACTERGUID)_Criminal4) (3,0,865,1)
event OnCrimeConfrontationDone((INTEGER)_CrimeID, (CHARACTERGUID)_Investigator, (INTEGER)_WasLead, (CHARACTERGUID)_Criminal1, (CHARACTERGUID)_Criminal2, (CHARACTERGUID)_Criminal3, (CHARACTERGUID)_Criminal4) (3,0,866,1)
event OnCriminalMergedWithCrime((INTEGER)_CrimeID, (CHARACTERGUID)_Criminal) (3,0,867,1)
event OnCrimeMergedWith((INTEGER)_OldCrimeID, (INTEGER)_NewCrimeID) (3,0,868,1)
event OnCrimeSawCriminalInCombat((INTEGER)_CrimeID, (CHARACTERGUID)_Character, (CHARACTERGUID)_Criminal1) (3,0,869,1)
event OnMutatorEnabledAtTurn((STRING)_Mutator, (INTEGER)_Turn) (3,0,870,1)
event OnArenaRoundStarted((STRING)_ArenaMode) (3,0,871,1)
event OnArenaRoundForceEnded() (3,0,872,1)
event OnStageChanged((GUIDSTRING)_Object, (INTEGER)_Bool) (3,0,873,1)
event ObjectWasTagged((GUIDSTRING)_Object, (STRING)_Tag) (3,0,874,1)
event ObjectLostTag((GUIDSTRING)_Object, (STRING)_Tag) (3,0,875,1)
event ObjectEnteredCombat((GUIDSTRING)_Object, (INTEGER)_CombatID) (3,0,876,1)
event CombatStarted((INTEGER)_CombatID) (3,0,877,1)
event CombatRoundStarted((INTEGER)_CombatID, (INTEGER)_Round) (3,0,878,1)
event CombatEnded((INTEGER)_CombatID) (3,0,879,1)
event ObjectSwitchedCombat((GUIDSTRING)_Object, (INTEGER)_OldCombatID, (INTEGER)_NewCombatID) (3,0,880,1)
event ObjectLeftCombat((GUIDSTRING)_Object, (INTEGER)_CombatID) (3,0,881,1)
event ObjectReadyInCombat((GUIDSTRING)_Object, (INTEGER)_CombatID) (3,0,882,1)
event ObjectTurnStarted((GUIDSTRING)_Object) (3,0,883,1)
event ObjectTurnEnded((GUIDSTRING)_Object) (3,0,884,1)
event ObjectTransformed((GUIDSTRING)_Object, (GUIDSTRING)_ToTemplate) (3,0,885,1)
event CrimeDisabled((CHARACTERGUID)_Character, (STRING)_Crime) (3,0,886,1)
event CrimeEnabled((CHARACTERGUID)_Character, (STRING)_Crime) (3,0,887,1)
event GMCampaignModeStarted((STRING)_CampaignMode) (3,0,888,1)
event PartyPresetLoaded((STRING)_PartyPreset) (3,0,889,1)
event QuestShared((CHARACTERGUID)_Character, (STRING)_Quest, (INTEGER)_IsShared) (3,0,890,1)
event QuestCategoryChanged((STRING)_Quest, (STRING)_NewCategory) (3,0,891,1)
event MysteryUnlocked((CHARACTERGUID)_Character, (STRING)_MysteryID) (3,0,892,1)
event ReadyCheckPassed((STRING)_Id) (3,0,893,1)
event ReadyCheckFailed((STRING)_Id) (3,0,894,1)
event ObjectSourcePointAddRequest((GUIDSTRING)_Target, (INTEGER)_AddSP, (INTEGER)_WasSP) (3,0,895,1)
event TeleportRequestMovie((INTEGER)_UserId, (STRING)_EventId) (3,0,896,1)
event EndGameRequestMovie((INTEGER)_UserId, (STRING)_EventId) (3,0,897,1)
event CustomBookUIClosed((CHARACTERGUID)_Character, (STRING)_BookName) (3,0,898,1)
event PuzzleUIUsed((CHARACTERGUID)_Character, (STRING)_UIInstance, (INTEGER)_Type, (STRING)_Command, (INTEGER)_ElementId) (3,0,899,1)
event PuzzleUIClosed((CHARACTERGUID)_Character, (STRING)_UIInstance, (INTEGER)_Type) (3,0,900,1)
event CameraReachedNode((SPLINEGUID)_Spline, (CHARACTERGUID)_Character, (STRING)_event, (INTEGER)_index, (INTEGER)_last) (3,0,901,1)
call TriggerLaunchIterator((TRIGGERGUID)_Trigger, (STRING)_Event) (1,0,902,1)
call TriggerRemoveAllItemTemplates((TRIGGERGUID)_Trigger, (STRING)_ItemTemplate) (1,0,903,1)
call TriggerRegisterForCharacter((TRIGGERGUID)_Trigger, (CHARACTERGUID)_Character) (1,0,904,1)
call TriggerUnregisterForCharacter((TRIGGERGUID)_Trigger, (CHARACTERGUID)_Character) (1,0,905,1)
call TriggerRegisterForPlayers((TRIGGERGUID)_Trigger) (1,0,906,1)
call TriggerUnregisterForPlayers((TRIGGERGUID)_Trigger) (1,0,907,1)
call TriggerRegisterForItems((TRIGGERGUID)_Trigger) (1,0,908,1)
call TriggerUnregisterForItems((TRIGGERGUID)_Trigger) (1,0,909,1)
query CharacterTemplatesInTrigger([in](STRING)_Template, [in](TRIGGERGUID)_Trigger, [out](INTEGER)_Count) (2,0,910,1)
call TriggerSetAtmosphere((TRIGGERGUID)_Trigger, (STRING)_AtmosphereUUID) (1,0,911,1)
call TriggerResetAtmosphere((TRIGGERGUID)_Trigger) (1,0,912,1)
call TriggerSetSoundState((TRIGGERGUID)_Trigger, (STRING)_StateGroup, (STRING)_State, (INTEGER)_Recursive) (1,0,913,1)
call TriggerSetSoundRTPC((TRIGGERGUID)_Trigger, (STRING)_Name, (REAL)_Value, (INTEGER)_Recursive) (1,0,914,1)
call TriggerSetItemOwner((TRIGGERGUID)_AreaTrigger, (CHARACTERGUID)_Owner) (1,0,915,1)
call TriggerClearItemOwner((TRIGGERGUID)_AreaTrigger) (1,0,916,1)
call TriggerClearItemTemplateOwners((TRIGGERGUID)_Trigger, (STRING)_ItemTemplate) (1,0,917,1)
query GetRandomPositionInTrigger([in](TRIGGERGUID)_Trigger, [out](REAL)_X, [out](REAL)_Y, [out](REAL)_Z) (2,0,918,1)
query StringConcatenate([in](STRING)_StringA, [in](STRING)_StringB, [out](STRING)_Result) (2,0,919,1)
query StringContains([in](STRING)_StringA, [in](STRING)_StringB, [out](INTEGER)_Bool) (2,0,920,1)
query StringSub([in](STRING)_String, [in](INTEGER)_Start, [in](INTEGER)_Count, [out](STRING)_Result) (2,0,921,1)
query IntegertoString([in](INTEGER)_Integer, [out](STRING)_Result) (2,0,922,1)
query String([in](GUIDSTRING)_GUIDstring, [out](STRING)_Result) (2,0,923,1)
query StartDialog_Internal([in](STRING)_Dialog, [in](INTEGER)_MarkForInteractiveDialog, [in](GUIDSTRING)_Speaker1, [in](GUIDSTRING)_Speaker2, [in](GUIDSTRING)_Speaker3, [in](GUIDSTRING)_Speaker4, [in](GUIDSTRING)_Speaker5, [in](GUIDSTRING)_Speaker6, [out](INTEGER)_Success) (2,0,924,1)
query StartDialog_Internal_NoDeadCheck([in](STRING)_Dialog, [in](INTEGER)_MarkForInteractiveDialog, [in](GUIDSTRING)_Speaker1, [in](GUIDSTRING)_Speaker2, [in](GUIDSTRING)_Speaker3, [in](GUIDSTRING)_Speaker4, [in](GUIDSTRING)_Speaker5, [in](GUIDSTRING)_Speaker6, [out](INTEGER)_Success) (2,0,925,1)
query DialogStartCrimeDialog([in](INTEGER)_CrimeID, [in](STRING)_Dialog, [in](INTEGER)_MarkForInteractiveDialog, [in](GUIDSTRING)_NPC, [in](GUIDSTRING)_Criminal1, [in](GUIDSTRING)_Criminal2, [in](GUIDSTRING)_Criminal3, [in](GUIDSTRING)_Criminal4, [out](INTEGER)_success) (2,0,926,1)
query DialogIsCrimeDialog([in](INTEGER)_InstanceID, [out](INTEGER)_IsCrimeDialog) (2,0,927,1)
call DialogAddActor((INTEGER)_InstanceID, (GUIDSTRING)_Actor) (1,0,928,1)
call DialogAddActorAt((INTEGER)_InstanceID, (GUIDSTRING)_Actor, (INTEGER)_Index) (1,0,929,1)
query DialogRemoveActorFromDialog([in](INTEGER)_InstanceID, [in](GUIDSTRING)_Actor, [out](INTEGER)_success) (2,0,930,1)
query DialogStartPartyDialog([in](STRING)_Dialog, [in](INTEGER)_ParentInstanceID, [in](INTEGER)_NewInstanceID, [in](CHARACTERGUID)_Player1, [in](CHARACTERGUID)_Player2, [in](CHARACTERGUID)_Player3, [in](CHARACTERGUID)_Player4, [out](INTEGER)_success) (2,0,931,1)
query DialogStartChildDialog([in](STRING)_Dialog, [in](INTEGER)_ParentInstanceID, [in](INTEGER)_NewInstanceID, [in](CHARACTERGUID)_Player1, [in](CHARACTERGUID)_Player2, [in](CHARACTERGUID)_Player3, [in](CHARACTERGUID)_Player4, [out](INTEGER)_success) (2,0,932,1)
call DialogResume((INTEGER)_InstanceID) (1,0,933,1)
query IsSpeakerReserved([in](GUIDSTRING)_Speaker, [out](INTEGER)_success) (2,0,934,1)
call StartVoiceBark((STRING)_Bark, (CHARACTERGUID)_Source) (1,0,935,1)
event VoiceBarkStarted((STRING)_Bark, (INTEGER)_InstanceID) (3,0,936,1)
event VoiceBarkFailed((STRING)_Bark) (3,0,937,1)
event VoiceBarkEnded((STRING)_Bark, (INTEGER)_InstanceID) (3,0,938,1)
event DualDialogRequested((STRING)_Dialog, (INTEGER)_InstanceID, (INTEGER)_TargetInstanceID) (3,0,939,1)
event ChildDialogRequested((STRING)_Dialog, (INTEGER)_InstanceID, (INTEGER)_TargetInstanceID) (3,0,940,1)
call DialogSetVariableString((STRING)_Dialog, (STRING)_Variable, (STRING)_Value) (1,0,941,1)
call DialogSetVariableInt((STRING)_Dialog, (STRING)_Variable, (INTEGER)_Value) (1,0,942,1)
call DialogSetVariableFloat((STRING)_Dialog, (STRING)_Variable, (REAL)_Value) (1,0,943,1)
call DialogSetVariableFixedString((STRING)_Dialog, (STRING)_Variable, (STRING)_Value) (1,0,944,1)
call DialogSetVariableTranslatedString((STRING)_Dialog, (STRING)_Variable, (STRING)_StringHandleValue, (STRING)_ReferenceStringValue) (1,0,945,1)
call DialogSetVariableStringForInstance((INTEGER)_InstanceID, (STRING)_Variable, (STRING)_Value) (1,0,946,1)
call DialogSetVariableIntForInstance((INTEGER)_InstanceID, (STRING)_Variable, (INTEGER)_Value) (1,0,947,1)
call DialogSetVariableFloatForInstance((INTEGER)_InstanceID, (STRING)_Variable, (REAL)_Value) (1,0,948,1)
call DialogSetVariableFixedStringForInstance((INTEGER)_InstanceID, (STRING)_Variable, (STRING)_Value) (1,0,949,1)
call DialogSetVariableTranslatedStringForInstance((INTEGER)_InstanceID, (STRING)_Variable, (STRING)_StringHandleValue, (STRING)_ReferenceStringValue) (1,0,950,1)
query HasDefaultDialog([in](CHARACTERGUID)_Character, [out](INTEGER)_HasDefaultDialog) (2,0,951,1)
query StartDefaultDialog([in](CHARACTERGUID)_Character, [in](CHARACTERGUID)_Player, [out](STRING)_Dialog, [out](INTEGER)_Automated) (2,0,952,1)
event GameEventSet((STRING)_Event) (3,0,953,1)
event GameEventCleared((STRING)_Event) (3,0,954,1)
event TextEventSet((STRING)_Event) (3,0,955,1)
query GetTextEventParamString([in](INTEGER)_Number, [out](STRING)_Value) (2,0,956,1)
query GetTextEventParamInteger([in](INTEGER)_Number, [out](INTEGER)_Value) (2,0,957,1)
query GetTextEventParamReal([in](INTEGER)_Number, [out](REAL)_Value) (2,0,958,1)
query GetTextEventParamUUID([in](INTEGER)_Number, [out](GUIDSTRING)_Value) (2,0,959,1)


version "0.0.6.1"
Goal(1).Title("__AAA_Shared_FirstGoal");
Goal(1)
{
	INIT
	{
		
	}
	KB
	{
		// Needs to be first because otherwise you get into endless loops in case there is an ObjectFlagSet()
		// handler that clears the flag before the ones below get executed (as they would then set the flag
		// again, causing the clear to be re-triggered, etc)
		
		//REGION Dialogs in which flags are always shared across all shapeshift forms of everyone involved
		// Flag set in a shared flags dialog -> set for all shapeshift forms
		IF
		ObjectFlagSet(_Flag,_Char,_ID)
		AND
		DB_GLO_AllDialogObjectFlagsShared(_ID)
		THEN
		// Once shared, shared forever (also for clearing)
		DB_SharedObjectFlags(_Flag);
		ObjectSetFlag(_Char,_Flag);
		//END_REGION
		
		//REGION Object flag transfer to shapeshift forms
		IF
		ObjectFlagSet(_Flag,(CHARACTERGUID)_Player,_)
		AND
		DB_IsPlayer(_Player)
		AND
		DB_SharedObjectFlags(_Flag)
		THEN
		ObjectSetFlag(_Player,_Flag);
		
		IF
		ObjectFlagCleared(_Flag,(CHARACTERGUID)_Player,_)
		AND
		DB_IsPlayer(_Player)
		AND
		DB_SharedObjectFlags(_Flag)
		THEN
		ObjectClearFlag(_Player,_Flag);
		
		//END_REGION
		
	}
	EXIT
	{
		
	}
}
Goal(2).Title("__Combat");
Goal(2)
{
	INIT
	{
		
	}
	KB
	{
		PROC
		ProcClearPreviousCombat((GUIDSTRING)_Char)
		AND
		DB_WasInCombat(_Char,(INTEGER)_Combat)
		THEN
		NOT DB_WasInCombat(_Char,_Combat);
		
		PROC
		ProcRegionEnded(_)
		AND
		DB_WasInCombat(_Char,_Combat)
		THEN
		NOT DB_WasInCombat(_Char,_Combat);
		
		PROC
		ProcAddToCharacterCombatList((GUIDSTRING)_Char,(INTEGER)_Combat)
		AND
		DB_CombatCharacters((CHARACTERGUID)_Char,(INTEGER)_Old)
		THEN
		NOT DB_CombatCharacters((CHARACTERGUID)_Char,_Old);
		
		PROC
		ProcAddToCharacterCombatList((GUIDSTRING)_Char,(INTEGER)_Combat)
		AND
		ObjectIsCharacter(_Char,1)
		THEN
		DB_CombatCharacters((CHARACTERGUID)_Char,_Combat);
		
		IF
		ObjectEnteredCombat(_Character,_Combat)
		THEN
		ProcClearPreviousCombat((GUIDSTRING)_Character);
		DB_CombatObjects(_Character,_Combat);
		ProcAddToCharacterCombatList(_Character,_Combat);
		
		IF
		ObjectSwitchedCombat(_Character,_Old,_New)
		THEN
		NOT DB_CombatObjects(_Character,_Old);
		DB_CombatObjects(_Character,_New);
		ProcAddToCharacterCombatList(_Character,_New);
		
		PROC
		Proc_ObjectLeftCombat((GUIDSTRING)_Char,(INTEGER)_Combat)
		THEN
		DB_NOOP(1);
		
		IF
		ObjectLeftCombat(_Character,_Combat)
		THEN
		DB_WasInCombat(_Character,_Combat);
		NOT DB_CombatObjects(_Character,_Combat);
		NOT DB_CombatCharacters((CHARACTERGUID)_Character,_Combat);
		Proc_ObjectLeftCombat(_Character,_Combat);
		
		IF
		FleeCombat(_Player)
		AND
		DB_IsPlayer(_Player)
		AND
		NOT DB_BlockWaypointUsage(_Player)
		THEN
		PROC_OpenWaypointUIForFlee(_Player,"",NULL_00000000-0000-0000-0000-000000000000);
		
		QRY
		QRY_GLO_IsOrWasInCombat((GUIDSTRING)_Char, (INTEGER)_ID)
		AND
		DB_CombatObjects(_Char, _ID)
		THEN
		DB_NOOP(1);
		
		QRY
		QRY_GLO_IsOrWasInCombat((GUIDSTRING)_Char, (INTEGER)_ID)
		AND
		DB_WasInCombat(_Char, _ID)
		THEN
		DB_NOOP(1);
		
	}
	EXIT
	{
		
	}
}
Goal(3).Title("__GLO_Shovel");
Goal(3)
{
	INIT
	{
		DB_LizardFirstShovelUses(0);
		
	}
	KB
	{
		//REGION CHECK FOR TREASURE
		IF
		DB_ShovelArea((TRIGGERGUID)_Trigger,(STRING)_,(ITEMGUID)_)
		THEN
		ProcTriggerRegisterForPlayers(_Trigger);
		
		IF
		DB_ShovelRewardItemAppear(_,_Item,_)
		THEN
		SetOnStage(_Item,0);
		
		IF
		DB_ShovelRewardItemScatter(_,_Item)
		THEN
		SetOnStage(_Item,0);
		
		IF
		DB_ShovelRewardItemSpawn(_,_Item)
		THEN
		SetOnStage(_Item,0);
		
		IF
		DB_ShovelRewardCharacterAppear(_,_Character)
		THEN
		SetOnStage(_Character,0);
		
		//Dig while in a trigger
		IF
		CharacterUsedItem(_Player, _Shovel)
		AND
		ObjectExists(_Shovel,1)	//ignore consumables that were destroyed
		AND
		IsTagged(_Shovel, "SHOVEL", 1)
		AND
		DB_ShovelArea(_Trigger,_,_DirtPile)
		AND
		DB_InRegion(_Player,_Trigger)
		AND
		NOT DB_Shovelling_Mound(_,_DirtPile)
		AND
		CharacterIsInFightMode(_Player,_WasInFightMode)
		THEN
		DB_Shovelling_Mound(_Player,_DirtPile);
		CharacterSetFightMode(_Player,0,1);
		PlayAnimation(_Player,"use_dig","digmound");
		DB_Shovel_PlayerHadWeaponDrawn(_Player,_WasInFightMode);
		
		//Dig outside a trigger
		IF
		CharacterUsedItem(_Player, _Shovel)
		AND
		ObjectExists(_Shovel,1)	//ignore consumables that were destroyed
		AND
		IsTagged(_Shovel, "SHOVEL", 1)
		AND
		NOT DB_Shovelling_Mound(_Player,_)
		AND
		CharacterIsInFightMode(_Player,_WasInFightMode)
		THEN
		CharacterSetFightMode(_Player,0,1);
		PlayAnimation(_Player,"use_dig","digmound");
		DB_Shovel_PlayerHadWeaponDrawn(_Player,_WasInFightMode);
		
		//Dig by interacting with pile without a shovel
		
		IF
		CharacterUsedItem(_Player,_DirtPile)
		AND
		DB_ShovelArea(_,_,_DirtPile)
		AND
		NOT PartyFindTaggedItem(_Player, "SHOVEL", 0, _)
		AND
		IsTagged(_Player,"LIZARD",0)
		THEN
		Proc_StartDialog(1,"GLO_AD_ShovelRequired", _Player);
		
		IF
		CharacterUsedItem(_Player,_DirtPile)
		AND
		DB_ShovelArea(_,_,_DirtPile)
		AND
		NOT DB_Shovelling_Mound(_,_DirtPile)
		AND
		IsTagged(_Player,"LIZARD",1)
		AND
		CharacterIsInFightMode(_Player,_WasInFightMode)
		THEN
		DB_Shovelling_Mound(_Player,_DirtPile);
		CharacterSetFightMode(_Player,0,1);
		PlayAnimation(_Player,"use_dig","digmound");
		DB_Shovel_PlayerHadWeaponDrawn(_Player,_WasInFightMode);
		proc_LizardFirstShovelUse((CHARACTERGUID)_Player);
		
		//Dig by interacting with pile with a shovel
		IF
		CharacterUsedItem(_Player,_DirtPile)
		AND
		DB_ShovelArea(_,_,_DirtPile)
		AND
		NOT DB_Shovelling_Mound(_,_DirtPile)
		AND
		PartyFindTaggedItem(_Player, "SHOVEL", 1, _)
		AND
		CharacterIsInFightMode(_Player,_WasInFightMode)
		THEN
		DB_Shovelling_Mound(_Player,_DirtPile);
		CharacterSetFightMode(_Player,0,1);
		PlayAnimation(_Player,"use_dig","digmound");
		DB_Shovel_PlayerHadWeaponDrawn(_Player,_WasInFightMode);
		
		//After Dig
		IF
		StoryEvent(_Player,"digmound")
		AND
		NOT DB_Shovelling_Mound((CHARACTERGUID)_Player,_)
		THEN
		Proc_StartDialog(1,"GLO_AD_ShovelFailed", _Player);
		
		IF
		StoryEvent(_Player,"digmound")
		AND
		DB_Shovelling_Mound((CHARACTERGUID)_Player,_DirtMound)
		AND
		DB_ShovelArea(_Trigger,_Reward,_DirtMound)
		THEN
		NOT DB_ShovelArea(_Trigger,_Reward,_DirtMound);
		NOT DB_Shovelling_Mound(_Player,_DirtMound);
		SetOnStage(_DirtMound,0);
		ProcShovelRewards(_Player,_Reward);
		CharacterItemSetEvent(_Player,_DirtMound,"clearedMound");
		
		IF
		StoryEvent(_Player,"digmound")
		AND
		DB_Shovel_PlayerHadWeaponDrawn((CHARACTERGUID)_Player,1)
		THEN
		CharacterSetFightMode(_Player,1,0);
		
		IF
		StoryEvent(_Player,"digmound")
		AND
		DB_Shovel_PlayerHadWeaponDrawn((CHARACTERGUID)_Player,_Value)
		THEN
		NOT DB_Shovel_PlayerHadWeaponDrawn(_Player,_Value);
		
		//END_REGION
		
		//REGION Lizard Dig AD
		
		PROC
		proc_LizardFirstShovelUse((CHARACTERGUID)_Lizrd)
		AND
		IsTagged(_Lizrd,"LIZARD",1)
		AND
		DB_LizardFirstShovelUses(_Int)
		AND
		_Int < 3
		AND
		IntegerSum(_Int,1,_NewInt)
		THEN
		DB_LizardFirstShovelUses(_NewInt);
		NOT DB_LizardFirstShovelUses(_Int);
		Proc_StartDialog(1,"GEN_AD_Lizrd_Dig",_Lizrd);
		
		
		
		//END_REGION
		
		//REGION SHOVEL REWARDS
		PROC
		ProcShovelRewards((CHARACTERGUID)_Player,(STRING)_Reward)
		AND
		DB_ShovelRewardItemAdd(_Reward,(ITEMGUID)_Item)
		THEN
		ItemToInventory(_Item,_Player,-1);
		
		PROC
		ProcShovelRewards((CHARACTERGUID)_Player,(STRING)_Reward)
		AND
		DB_ShovelRewardItemAppear(_Reward,(ITEMGUID)_Item,(TRIGGERGUID)_Trigger)
		THEN
		SetOnStage(_Item,1);
		ItemDragToTrigger(_Item,_Trigger);
		
		PROC
		ProcShovelRewards((CHARACTERGUID)_Player,(STRING)_Reward)
		AND
		DB_ShovelRewardCharacterAppear(_Reward,(CHARACTERGUID)_Character)
		THEN
		CharacterAppear(_Character,1,"");
		
		PROC
		ProcShovelRewards((CHARACTERGUID)_Player,(STRING)_Reward)
		AND
		DB_ShovelRewardItemSpawn(_Reward,(ITEMGUID)_Item)
		THEN
		SetOnStage(_Item,1);
		
		PROC
		ProcShovelRewards((CHARACTERGUID)_Player,(STRING)_Reward)
		AND
		DB_ShovelRewardItemTemplate(_Reward,(STRING)_ItemTemplate,(INTEGER)_Amount)
		THEN
		ItemTemplateAddTo(_ItemTemplate,_Player,_Amount);
		
		PROC
		ProcShovelRewards((CHARACTERGUID)_Player,(STRING)_Reward)
		AND
		DB_ShovelRewardEvent(_Reward,(STRING)_Event)
		THEN
		GlobalSetFlag(_Event);
		
		PROC
		ProcShovelRewards((CHARACTERGUID)_Player,(STRING)_Reward)
		AND
		DB_ShovelRewardVoiceBark(_Reward, (STRING)_VoiceBark)
		THEN
		StartVoiceBark(_VoiceBark, _Player);
		
		PROC
		ProcShovelRewards((CHARACTERGUID)_Player,(STRING)_Reward)
		AND
		DB_ShovelRewardSurface(_Reward,(TRIGGERGUID)_Trigger, (STRING)_Type, (REAL)_Radius, (REAL)_Lifetime)
		THEN
		CreateSurface(_Trigger, _Type, _Radius, _Lifetime);
		
		PROC
		ProcShovelRewards((CHARACTERGUID)_Player,(STRING)_Reward)
		AND
		DB_ShovelRewardItemScatter(_Reward,(ITEMGUID)_Item)
		AND
		GetPosition(_Item, _X, _Y, _Z)
		THEN
		SetOnStage(_Item, 1);
		ItemScatterAt(_Item, _X, _Y, _Z);
		
		//END_REGION
		
		//REGION Tombstone AD
		
		IF
		CharacterItemEvent(_Player,_Tombstone,"GEN_UsedTombstone")
		AND
		GetVarFixedString(_Tombstone,"Dialog",_Dialog)
		AND
		_Dialog != ""
		THEN
		Proc_StartDialog(1,_Dialog,_Tombstone,_Player);
		
		//END_REGION
		
	}
	EXIT
	{
		
	}
}
Goal(4).Title("__GLOBAL_Dialogs");
Goal(4)
{
	INIT
	{
		// To intercept a dialog request, define one of these:
		//   PROC_GLOBAL_DialogStartRequested((GUIDSTRING)_Target,(GUIDSTRING)_Source)
		//   PROC_GLOBAL_DialogStartRequested_AfterGenerics((GUIDSTRING)_Target,(GUIDSTRING)_Source)
		// The former is called before any generics (low attitude etc) are checked, but still after
		// speaker availability checks are confirmed (not dead, not in combat).
		// Start your own dialog in one of those PROCs if the conditions are right, and set
		// DB_FoundDialog(_Target,_Source) if you want to prevent the default dialog to be searched/started
		//
		
		DB_AnimalFoodVars("FoodTemplate1");
		DB_AnimalFoodVars("FoodTemplate2");
		DB_AnimalFoodVars("FoodTemplate3");
		DB_AnimalFoodVars("FoodTemplate4");
		DB_AnimalFoodVars("FoodTemplate5");
		DB_AnimalFoodVars("FoodTemplate6");
		
		DB_CustomChildDialog("nullstring");
		
	}
	KB
	{
		//REGION HasMet
		IF
		DB_HasMetCharactersToCheck(_NPC,_PC)
		THEN
		ProcSetHasMetTag(_Npc,_PC);
		
		IF
		DB_HasMetCharactersToCheck(_NPC,_PC)
		THEN
		NOT DB_HasMetCharactersToCheck(_NPC,_PC);
		
		PROC
		Proc_Dialogs_CharactersHaveMetInThisShape((GUIDSTRING)_Npc,(CHARACTERGUID)_Player)
		THEN
		SetTag(_NPC,"HasMet");
		
		PROC
		ProcSetHasMetTag((GUIDSTRING)_Npc,(CHARACTERGUID)_Player)
		AND
		DB_CharacterPolymorphedInto(_Player,(STRING)_Race)
		AND
		DB_HasMet(_Npc,_Player,(STRING)_Race)
		THEN
		Proc_Dialogs_CharactersHaveMetInThisShape(_Npc,_Player);
		
		PROC
		ProcSetHasMetTag((GUIDSTRING)_Npc,(CHARACTERGUID)_Player)
		AND
		NOT DB_CharacterPolymorphedInto(_Player,_)
		AND
		DB_HasMet(_Npc,_Player,"")
		THEN
		Proc_Dialogs_CharactersHaveMetInThisShape(_Npc,_Player);
		
		IF
		DialogEnded(_Diag,_Inst)
		AND
		DB_DialogNPCs(_Inst,_Npc,_)
		AND
		DB_DialogPlayers(_Inst,_Player,_)
		THEN
		ProcSetHasMetDBEntry(_Diag,(GUIDSTRING)_Npc,(CHARACTERGUID)_Player);
		
		PROC
		ProcSetHasMetDBEntry((STRING)_Diag,(GUIDSTRING)_Npc,(CHARACTERGUID)_Player)
		AND
		DB_CharacterPolymorphedInto(_Player,_Race)
		THEN
		DB_HasMet(_Npc,_Player,_Race);
		
		PROC
		ProcSetHasMetDBEntry((STRING)_Diag,(GUIDSTRING)_Npc,(CHARACTERGUID)_Player)
		AND
		NOT DB_CharacterPolymorphedInto(_Player,_)
		THEN
		DB_HasMet(_Npc,_Player,"");
		
		
		IF
		DialogEnded(_Diag,_Inst)
		AND
		DB_DialogNPCs(_Inst,_Npc,_)
		THEN
		ClearTag(_Npc,"HasMet");
		//END_REGION
		
		//REGION Tag Priority Dialogs
		PROC
		PROC_GLOBAL_DialogStartRequested((GUIDSTRING)_NPC,(GUIDSTRING)_Player)
		THEN
		PROC_GLO_Origins_CheckTagPriorityDialogs(_NPC,_Player);
		
		PROC
		PROC_GLO_Origins_CheckTagPriorityDialogs((GUIDSTRING)_NPC,(GUIDSTRING)_Player)
		AND
		DB_TagPriorityDialog(_NPC, (STRING)_Dialog, (STRING)_PriorityTag)
		AND
		NOT DB_GLO_OriginsFoundTagPriorityPlayer(1)
		AND
		IsTagged(_Player,_PriorityTag,0)
		AND
		DB_IsPlayer(_OtherPlayer)
		AND
		QRY_SpeakerIsAvailableAndInDialogRange(_OtherPlayer, _Player)
		AND
		_OtherPlayer != _Player
		AND
		CharacterGetReservedUserID((CHARACTERGUID)_Player,_ID)
		AND
		CharacterGetReservedUserID((CHARACTERGUID)_OtherPlayer,_ID)
		AND
		IsTagged(_OtherPlayer,_PriorityTag,1)
		AND
		HasLineOfSight(_NPC, _OtherPlayer, 1)
		THEN
		DB_GLO_OriginsFoundTagPriorityPlayer(1);
		ProcForceStopDialog(_NPC);
		Proc_StartDialog(0,_Dialog,_NPC,_OtherPlayer);
		PROC_GLO_Origins_ClearTaggedPrioritiesForDialog(_Dialog);
		
		PROC
		PROC_GLO_Origins_ClearTaggedPrioritiesForDialog((STRING)_Dialog)
		AND
		DB_TagPriorityDialog(_NPC,_Dialog,_PriorityTag)
		THEN
		NOT DB_TagPriorityDialog(_NPC,_Dialog,_PriorityTag);
		
		PROC
		PROC_GLO_Origins_CheckTagPriorityDialogs((GUIDSTRING)_NPC,(GUIDSTRING)_Player)
		THEN
		NOT DB_GLO_OriginsFoundTagPriorityPlayer(1);
		
		//END_REGION
		
		
		//REGION The Only Allowed Dialog Starting
		//Dummy definition
		QRY
		QRY_GLOBAL_CrimeDialogIntercept_Wrapper((INTEGER)_Automated, (GUIDSTRING)_Speaker1, (GUIDSTRING)_Speaker2, (GUIDSTRING)_Speaker3,(GUIDSTRING)_Speaker4, (GUIDSTRING)_Speaker5, (GUIDSTRING)_Speaker6)
		AND
		0 == 1
		THEN
		DB_NOOP(1);
		
		//Dummy definition
		QRY
		QRY_PlayOriginMoment((STRING)_Dialog, (GUIDSTRING)_MainNPC, (GUIDSTRING)_Player)
		AND
		0 == 1
		THEN
		DB_NOOP(1);
		
		PROC
		Proc_StartDialog((INTEGER)_Automated,(STRING)_Dialog,(GUIDSTRING)_Speaker1)
		AND
		QRY_StartDialog(_Automated,_Dialog,_Speaker1)
		THEN
		DB_NOOP(1);
		
		PROC
		Proc_StartDialog((INTEGER)_Automated,(STRING)_Dialog,(GUIDSTRING)_Speaker1,(GUIDSTRING)_Speaker2)
		AND
		NOT QRY_GLOBAL_CrimeDialogIntercept_Wrapper(_Automated, _Speaker1,_Speaker2, NULL_00000000-0000-0000-0000-000000000000, NULL_00000000-0000-0000-0000-000000000000, NULL_00000000-0000-0000-0000-000000000000,  NULL_00000000-0000-0000-0000-000000000000)
		AND
		NOT QRY_PlayOriginMoment(_Dialog,_Speaker1,_Speaker2)
		AND
		NOT DB_OriginRecruitmentDialog((CHARACTERGUID)_,_Dialog)
		AND
		QRY_StartDialog(_Automated,_Dialog,_Speaker1,_Speaker2)
		THEN
		DB_NOOP(1);
		
		PROC
		Proc_StartDialog((INTEGER)_Automated,(STRING)_Dialog,(GUIDSTRING)_Speaker1,(GUIDSTRING)_Speaker2,(GUIDSTRING)_Speaker3)
		AND
		NOT QRY_GLOBAL_CrimeDialogIntercept_Wrapper(_Automated, _Speaker1,_Speaker2, _Speaker3, NULL_00000000-0000-0000-0000-000000000000, NULL_00000000-0000-0000-0000-000000000000,  NULL_00000000-0000-0000-0000-000000000000)
		AND
		NOT QRY_PlayOriginMoment(_Dialog,_Speaker1,_Speaker3)
		AND
		QRY_StartDialog(_Automated,_Dialog,_Speaker1,_Speaker2,_Speaker3)
		THEN
		DB_NOOP(1);
		
		PROC
		Proc_StartDialog((INTEGER)_Automated,(STRING)_Dialog,(GUIDSTRING)_Speaker1,(GUIDSTRING)_Speaker2,(GUIDSTRING)_Speaker3,(GUIDSTRING)_Speaker4)
		AND
		NOT QRY_GLOBAL_CrimeDialogIntercept_Wrapper(_Automated, _Speaker1,_Speaker2, _Speaker3, _Speaker4, NULL_00000000-0000-0000-0000-000000000000,  NULL_00000000-0000-0000-0000-000000000000)
		AND
		NOT QRY_PlayOriginMoment(_Dialog,_Speaker1,_Speaker4)
		AND
		QRY_StartDialog(_Automated,_Dialog,_Speaker1,_Speaker2,_Speaker3,_Speaker4)
		THEN
		DB_NOOP(1);
		
		PROC
		Proc_StartDialog((INTEGER)_Automated,(STRING)_Dialog,(GUIDSTRING)_Speaker1,(GUIDSTRING)_Speaker2,(GUIDSTRING)_Speaker3,(GUIDSTRING)_Speaker4,(GUIDSTRING)_Speaker5)
		AND
		NOT QRY_GLOBAL_CrimeDialogIntercept_Wrapper(_Automated, _Speaker1,_Speaker2, _Speaker3, _Speaker4, _Speaker5, NULL_00000000-0000-0000-0000-000000000000)
		AND
		NOT QRY_PlayOriginMoment(_Dialog,_Speaker1,_Speaker5)
		AND
		QRY_StartDialog(_Automated,_Dialog,_Speaker1,_Speaker2,_Speaker3,_Speaker4,_Speaker5)
		THEN
		DB_NOOP(1);
		
		PROC
		Proc_StartDialog((INTEGER)_Automated,(STRING)_Dialog,(GUIDSTRING)_Speaker1,(GUIDSTRING)_Speaker2,(GUIDSTRING)_Speaker3,(GUIDSTRING)_Speaker4,(GUIDSTRING)_Speaker5,(GUIDSTRING)_Speaker6)
		AND
		NOT QRY_GLOBAL_CrimeDialogIntercept_Wrapper(_Automated, _Speaker1,_Speaker2, _Speaker3, _Speaker4, _Speaker5, _Speaker6)
		AND
		NOT QRY_PlayOriginMoment(_Dialog,_Speaker1,_Speaker6)
		AND
		QRY_StartDialog(_Automated,_Dialog,_Speaker1,_Speaker2,_Speaker3,_Speaker4,_Speaker5,_Speaker6)
		THEN
		DB_NOOP(1);
		
		QRY
		QRY_StartDialog(1,(STRING)_Dialog,(GUIDSTRING)_Speaker1)
		AND
		QRY_SpeakerIsAvailable(_Speaker1,1)
		AND
		StartDialog_Internal(_Dialog,0,_Speaker1,NULL_00000000-0000-0000-0000-000000000000,NULL_00000000-0000-0000-0000-000000000000,NULL_00000000-0000-0000-0000-000000000000,NULL_00000000-0000-0000-0000-000000000000,NULL_00000000-0000-0000-0000-000000000000,1)
		THEN
		Proc_DialogFlagSetup((STRING)_Dialog,(GUIDSTRING)_Speaker1);
		
		QRY
		QRY_StartDialog(1,(STRING)_Dialog,(GUIDSTRING)_Speaker1,(GUIDSTRING)_Speaker2)
		AND
		QRY_SpeakerIsAvailable(_Speaker1,1)
		AND
		QRY_SpeakerIsAvailable(_Speaker2,1)
		AND
		StartDialog_Internal(_Dialog,0,_Speaker1,_Speaker2,NULL_00000000-0000-0000-0000-000000000000,NULL_00000000-0000-0000-0000-000000000000,NULL_00000000-0000-0000-0000-000000000000,NULL_00000000-0000-0000-0000-000000000000,1)
		THEN
		Proc_DialogFlagSetup((STRING)_Dialog,(GUIDSTRING)_Speaker1,(GUIDSTRING)_Speaker2);
		
		QRY
		QRY_StartDialog(1,(STRING)_Dialog,(GUIDSTRING)_Speaker1,(GUIDSTRING)_Speaker2,(GUIDSTRING)_Speaker3)
		AND
		QRY_SpeakerIsAvailable(_Speaker1,1)
		AND
		QRY_SpeakerIsAvailable(_Speaker2,1)
		AND
		QRY_SpeakerIsAvailable(_Speaker3,1)
		AND
		StartDialog_Internal(_Dialog,0,_Speaker1,_Speaker2,_Speaker3,NULL_00000000-0000-0000-0000-000000000000,NULL_00000000-0000-0000-0000-000000000000,NULL_00000000-0000-0000-0000-000000000000,1)
		THEN
		Proc_DialogFlagSetup((STRING)_Dialog,(GUIDSTRING)_Speaker1,(GUIDSTRING)_Speaker2, (GUIDSTRING)_Speaker3);
		
		QRY
		QRY_StartDialog(1,(STRING)_Dialog,(GUIDSTRING)_Speaker1,(GUIDSTRING)_Speaker2,(GUIDSTRING)_Speaker3,(GUIDSTRING)_Speaker4)
		AND
		QRY_SpeakerIsAvailable(_Speaker1,1)
		AND
		QRY_SpeakerIsAvailable(_Speaker2,1)
		AND
		QRY_SpeakerIsAvailable(_Speaker3,1)
		AND
		QRY_SpeakerIsAvailable(_Speaker4,1)
		AND
		StartDialog_Internal(_Dialog,0,_Speaker1,_Speaker2,_Speaker3,_Speaker4,NULL_00000000-0000-0000-0000-000000000000,NULL_00000000-0000-0000-0000-000000000000,1)
		THEN
		Proc_DialogFlagSetup((STRING)_Dialog,(GUIDSTRING)_Speaker1,(GUIDSTRING)_Speaker2, (GUIDSTRING)_Speaker3, (GUIDSTRING)_Speaker4);
		
		QRY
		QRY_StartDialog(1,(STRING)_Dialog,(GUIDSTRING)_Speaker1,(GUIDSTRING)_Speaker2,(GUIDSTRING)_Speaker3,(GUIDSTRING)_Speaker4,(GUIDSTRING)_Speaker5)
		AND
		QRY_SpeakerIsAvailable(_Speaker1,1)
		AND
		QRY_SpeakerIsAvailable(_Speaker2,1)
		AND
		QRY_SpeakerIsAvailable(_Speaker3,1)
		AND
		QRY_SpeakerIsAvailable(_Speaker4,1)
		AND
		QRY_SpeakerIsAvailable(_Speaker5,1)
		AND
		StartDialog_Internal(_Dialog,0,_Speaker1,_Speaker2,_Speaker3,_Speaker4,_Speaker5,NULL_00000000-0000-0000-0000-000000000000,1)
		THEN
		Proc_DialogFlagSetup((STRING)_Dialog,(GUIDSTRING)_Speaker1,(GUIDSTRING)_Speaker2, (GUIDSTRING)_Speaker3, (GUIDSTRING)_Speaker4, (GUIDSTRING)_Speaker5,NULL_00000000-0000-0000-0000-000000000000);
		
		QRY
		QRY_StartDialog(1,(STRING)_Dialog,(GUIDSTRING)_Speaker1,(GUIDSTRING)_Speaker2,(GUIDSTRING)_Speaker3,(GUIDSTRING)_Speaker4,(GUIDSTRING)_Speaker5,(GUIDSTRING)_Speaker6)
		AND
		QRY_SpeakerIsAvailable(_Speaker1,1)
		AND
		QRY_SpeakerIsAvailable(_Speaker2,1)
		AND
		QRY_SpeakerIsAvailable(_Speaker3,1)
		AND
		QRY_SpeakerIsAvailable(_Speaker4,1)
		AND
		QRY_SpeakerIsAvailable(_Speaker5,1)
		AND
		QRY_SpeakerIsAvailable(_Speaker6,1)
		AND
		StartDialog_Internal(_Dialog,0,_Speaker1,_Speaker2,_Speaker3,_Speaker4,_Speaker5,_Speaker6,1)
		THEN
		Proc_DialogFlagSetup((STRING)_Dialog,(GUIDSTRING)_Speaker1,(GUIDSTRING)_Speaker2, (GUIDSTRING)_Speaker3, (GUIDSTRING)_Speaker4, (GUIDSTRING)_Speaker5, (GUIDSTRING)_Speaker6);
		
		QRY
		QRY_StartDialog(0,(STRING)_Dialog,(GUIDSTRING)_Speaker1)
		AND
		QRY_SpeakerIsAvailable(_Speaker1)
		AND
		QRY_PrepForInteractiveDialog(_Speaker1)
		AND
		StartDialog_Internal(_Dialog,1,_Speaker1,NULL_00000000-0000-0000-0000-000000000000,NULL_00000000-0000-0000-0000-000000000000,NULL_00000000-0000-0000-0000-000000000000,NULL_00000000-0000-0000-0000-000000000000,NULL_00000000-0000-0000-0000-000000000000,1)
		THEN
		Proc_DialogFlagSetup((STRING)_Dialog,(GUIDSTRING)_Speaker1);
		CharacterMakeStoryNpc((CHARACTERGUID)_Speaker1,1);
		ProcItemSetInvulnerableForDialog(_Speaker1);
		
		QRY
		QRY_StartDialog(0,(STRING)_Dialog,(GUIDSTRING)_Speaker1,(GUIDSTRING)_Speaker2)
		AND
		QRY_SpeakerIsAvailable(_Speaker1)
		AND
		QRY_SpeakerIsAvailable(_Speaker2)
		AND
		QRY_PrepForInteractiveDialog(_Speaker1)
		AND
		QRY_PrepForInteractiveDialog(_Speaker2)
		AND
		StartDialog_Internal(_Dialog,1,_Speaker1,_Speaker2,NULL_00000000-0000-0000-0000-000000000000,NULL_00000000-0000-0000-0000-000000000000,NULL_00000000-0000-0000-0000-000000000000,NULL_00000000-0000-0000-0000-000000000000,1)
		THEN
		Proc_DialogFlagSetup((STRING)_Dialog,(GUIDSTRING)_Speaker1,(GUIDSTRING)_Speaker2);
		ProcFaceCharacter(_Speaker1,_Speaker2);
		ProcFaceCharacter(_Speaker2,_Speaker1);
		ProcItemSetInvulnerableForDialog(_Speaker1);
		ProcItemSetInvulnerableForDialog(_Speaker2);
		CharacterMakeStoryNpc((CHARACTERGUID)_Speaker1,1);
		CharacterMakeStoryNpc((CHARACTERGUID)_Speaker2,1);
		DB_HasMetCharactersToCheck(_Speaker1,_Speaker2);
		
		QRY
		QRY_StartDialog(0,(STRING)_Dialog,(GUIDSTRING)_Speaker1,(GUIDSTRING)_Speaker2,(GUIDSTRING)_Speaker3)
		AND
		QRY_SpeakerIsAvailable(_Speaker1)
		AND
		QRY_SpeakerIsAvailable(_Speaker2)
		AND
		QRY_SpeakerIsAvailable(_Speaker3)
		AND
		QRY_PrepForInteractiveDialog(_Speaker1)
		AND
		QRY_PrepForInteractiveDialog(_Speaker2)
		AND
		QRY_PrepForInteractiveDialog(_Speaker3)
		AND
		StartDialog_Internal(_Dialog,1,_Speaker1,_Speaker2,_Speaker3,NULL_00000000-0000-0000-0000-000000000000,NULL_00000000-0000-0000-0000-000000000000,NULL_00000000-0000-0000-0000-000000000000,1)
		THEN
		Proc_DialogFlagSetup((STRING)_Dialog,(GUIDSTRING)_Speaker1,(GUIDSTRING)_Speaker2, (GUIDSTRING)_Speaker3);
		ProcFaceCharacter(_Speaker1,_Speaker3);
		ProcFaceCharacter(_Speaker2,_Speaker3);
		ProcFaceCharacter(_Speaker3,_Speaker1);
		ProcItemSetInvulnerableForDialog(_Speaker1);
		ProcItemSetInvulnerableForDialog(_Speaker2);
		ProcItemSetInvulnerableForDialog(_Speaker3);
		CharacterMakeStoryNpc((CHARACTERGUID)_Speaker1,1);
		CharacterMakeStoryNpc((CHARACTERGUID)_Speaker2,1);
		CharacterMakeStoryNpc((CHARACTERGUID)_Speaker3,1);
		DB_HasMetCharactersToCheck(_Speaker1,_Speaker2);
		DB_HasMetCharactersToCheck(_Speaker1,_Speaker3);
		
		
		QRY
		QRY_StartDialog(0,(STRING)_Dialog,(GUIDSTRING)_Speaker1,(GUIDSTRING)_Speaker2,(GUIDSTRING)_Speaker3,(GUIDSTRING)_Speaker4)
		AND
		QRY_SpeakerIsAvailable(_Speaker1)
		AND
		QRY_SpeakerIsAvailable(_Speaker2)
		AND
		QRY_SpeakerIsAvailable(_Speaker3)
		AND
		QRY_SpeakerIsAvailable(_Speaker4)
		AND
		QRY_PrepForInteractiveDialog(_Speaker1)
		AND
		QRY_PrepForInteractiveDialog(_Speaker2)
		AND
		QRY_PrepForInteractiveDialog(_Speaker3)
		AND
		QRY_PrepForInteractiveDialog(_Speaker4)
		AND
		StartDialog_Internal(_Dialog,1,_Speaker1,_Speaker2,_Speaker3,_Speaker4,NULL_00000000-0000-0000-0000-000000000000,NULL_00000000-0000-0000-0000-000000000000,1)
		THEN
		Proc_DialogFlagSetup((STRING)_Dialog,(GUIDSTRING)_Speaker1,(GUIDSTRING)_Speaker2, (GUIDSTRING)_Speaker3, (GUIDSTRING)_Speaker4);
		ProcFaceCharacter(_Speaker1,_Speaker4);
		ProcFaceCharacter(_Speaker2,_Speaker4);
		ProcFaceCharacter(_Speaker3,_Speaker4);
		ProcFaceCharacter(_Speaker4,_Speaker1);
		ProcItemSetInvulnerableForDialog(_Speaker1);
		ProcItemSetInvulnerableForDialog(_Speaker2);
		ProcItemSetInvulnerableForDialog(_Speaker3);
		ProcItemSetInvulnerableForDialog(_Speaker4);
		CharacterMakeStoryNpc((CHARACTERGUID)_Speaker1,1);
		CharacterMakeStoryNpc((CHARACTERGUID)_Speaker2,1);
		CharacterMakeStoryNpc((CHARACTERGUID)_Speaker3,1);
		CharacterMakeStoryNpc((CHARACTERGUID)_Speaker4,1);
		DB_HasMetCharactersToCheck(_Speaker1,_Speaker2);
		DB_HasMetCharactersToCheck(_Speaker1,_Speaker3);
		DB_HasMetCharactersToCheck(_Speaker1,_Speaker4);
		
		
		QRY
		QRY_StartDialog(0,(STRING)_Dialog,(GUIDSTRING)_Speaker1,(GUIDSTRING)_Speaker2,(GUIDSTRING)_Speaker3,(GUIDSTRING)_Speaker4,(GUIDSTRING)_Speaker5)
		AND
		QRY_SpeakerIsAvailable(_Speaker1)
		AND
		QRY_SpeakerIsAvailable(_Speaker2)
		AND
		QRY_SpeakerIsAvailable(_Speaker3)
		AND
		QRY_SpeakerIsAvailable(_Speaker4)
		AND
		QRY_SpeakerIsAvailable(_Speaker5)
		AND
		QRY_PrepForInteractiveDialog(_Speaker1)
		AND
		QRY_PrepForInteractiveDialog(_Speaker2)
		AND
		QRY_PrepForInteractiveDialog(_Speaker3)
		AND
		QRY_PrepForInteractiveDialog(_Speaker4)
		AND
		QRY_PrepForInteractiveDialog(_Speaker5)
		AND
		StartDialog_Internal(_Dialog,1,_Speaker1,_Speaker2,_Speaker3,_Speaker4,_Speaker5,NULL_00000000-0000-0000-0000-000000000000,1)
		THEN
		Proc_DialogFlagSetup((STRING)_Dialog,(GUIDSTRING)_Speaker1,(GUIDSTRING)_Speaker2, (GUIDSTRING)_Speaker3, (GUIDSTRING)_Speaker4, (GUIDSTRING)_Speaker5);
		ProcFaceCharacter(_Speaker1,_Speaker5);
		ProcFaceCharacter(_Speaker2,_Speaker5);
		ProcFaceCharacter(_Speaker3,_Speaker5);
		ProcFaceCharacter(_Speaker4,_Speaker5);
		ProcFaceCharacter(_Speaker5,_Speaker1);
		ProcItemSetInvulnerableForDialog(_Speaker1);
		ProcItemSetInvulnerableForDialog(_Speaker2);
		ProcItemSetInvulnerableForDialog(_Speaker3);
		ProcItemSetInvulnerableForDialog(_Speaker4);
		ProcItemSetInvulnerableForDialog(_Speaker5);
		CharacterMakeStoryNpc((CHARACTERGUID)_Speaker1,1);
		CharacterMakeStoryNpc((CHARACTERGUID)_Speaker2,1);
		CharacterMakeStoryNpc((CHARACTERGUID)_Speaker3,1);
		CharacterMakeStoryNpc((CHARACTERGUID)_Speaker4,1);
		CharacterMakeStoryNpc((CHARACTERGUID)_Speaker5,1);
		DB_HasMetCharactersToCheck(_Speaker1,_Speaker2);
		DB_HasMetCharactersToCheck(_Speaker1,_Speaker3);
		DB_HasMetCharactersToCheck(_Speaker1,_Speaker4);
		DB_HasMetCharactersToCheck(_Speaker1,_Speaker5);
		
		QRY
		QRY_StartDialog(0,(STRING)_Dialog,(GUIDSTRING)_Speaker1,(GUIDSTRING)_Speaker2,(GUIDSTRING)_Speaker3,(GUIDSTRING)_Speaker4,(GUIDSTRING)_Speaker5,(GUIDSTRING)_Speaker6)
		AND
		QRY_SpeakerIsAvailable(_Speaker1)
		AND
		QRY_SpeakerIsAvailable(_Speaker2)
		AND
		QRY_SpeakerIsAvailable(_Speaker3)
		AND
		QRY_SpeakerIsAvailable(_Speaker4)
		AND
		QRY_SpeakerIsAvailable(_Speaker5)
		AND
		QRY_SpeakerIsAvailable(_Speaker6)
		AND
		QRY_PrepForInteractiveDialog(_Speaker1)
		AND
		QRY_PrepForInteractiveDialog(_Speaker2)
		AND
		QRY_PrepForInteractiveDialog(_Speaker3)
		AND
		QRY_PrepForInteractiveDialog(_Speaker4)
		AND
		QRY_PrepForInteractiveDialog(_Speaker5)
		AND
		QRY_PrepForInteractiveDialog(_Speaker6)
		AND
		StartDialog_Internal(_Dialog,1,_Speaker1,_Speaker2,_Speaker3,_Speaker4,_Speaker5,_Speaker6,1)
		THEN
		Proc_DialogFlagSetup((STRING)_Dialog,(GUIDSTRING)_Speaker1,(GUIDSTRING)_Speaker2, (GUIDSTRING)_Speaker3, (GUIDSTRING)_Speaker4, (GUIDSTRING)_Speaker5, (GUIDSTRING)_Speaker6);
		ProcFaceCharacter(_Speaker1,_Speaker6);
		ProcFaceCharacter(_Speaker2,_Speaker6);
		ProcFaceCharacter(_Speaker3,_Speaker6);
		ProcFaceCharacter(_Speaker4,_Speaker6);
		ProcFaceCharacter(_Speaker5,_Speaker6);
		ProcFaceCharacter(_Speaker6,_Speaker1);
		ProcItemSetInvulnerableForDialog(_Speaker1);
		ProcItemSetInvulnerableForDialog(_Speaker2);
		ProcItemSetInvulnerableForDialog(_Speaker3);
		ProcItemSetInvulnerableForDialog(_Speaker4);
		ProcItemSetInvulnerableForDialog(_Speaker5);
		ProcItemSetInvulnerableForDialog(_Speaker6);
		CharacterMakeStoryNpc((CHARACTERGUID)_Speaker1,1);
		CharacterMakeStoryNpc((CHARACTERGUID)_Speaker2,1);
		CharacterMakeStoryNpc((CHARACTERGUID)_Speaker3,1);
		CharacterMakeStoryNpc((CHARACTERGUID)_Speaker4,1);
		CharacterMakeStoryNpc((CHARACTERGUID)_Speaker5,1);
		CharacterMakeStoryNpc((CHARACTERGUID)_Speaker6,1);
		DB_HasMetCharactersToCheck(_Speaker1,_Speaker2);
		DB_HasMetCharactersToCheck(_Speaker1,_Speaker3);
		DB_HasMetCharactersToCheck(_Speaker1,_Speaker4);
		DB_HasMetCharactersToCheck(_Speaker1,_Speaker5);
		DB_HasMetCharactersToCheck(_Speaker1,_Speaker6);
		
		QRY
		QRY_PrepForInteractiveDialog((GUIDSTRING)_Speaker)
		THEN
		DialogRequestStop(_Speaker);
		//END_REGION
		
		//REGION Setting Items in Dialog Invulnerable 
		PROC
		ProcItemSetInvulnerableForDialog((GUIDSTRING)_Speaker)
		AND
		ObjectIsItem(_Speaker,1)
		THEN
		SetInvulnerable_UseProcSetInvulnerable(_Speaker,1);
		//END_REGION
		
		//REGION Flags Set Up The Start Of Dialog
		PROC
		Proc_DialogFlagSetup((STRING)_Dialog,(GUIDSTRING)_Speaker1)
		THEN
		DB_NOOP(1);
		
		PROC
		Proc_DialogFlagSetup((STRING)_Dialog,(GUIDSTRING)_Speaker1,(GUIDSTRING)_Speaker2)
		THEN
		DB_NOOP(1);
		
		PROC
		Proc_DialogFlagSetup((STRING)_Dialog,(GUIDSTRING)_Speaker1,(GUIDSTRING)_Speaker2,(GUIDSTRING)_Speaker3)
		THEN
		DB_NOOP(1);
		
		PROC
		Proc_DialogFlagSetup((STRING)_Dialog,(GUIDSTRING)_Speaker1,(GUIDSTRING)_Speaker2,(GUIDSTRING)_Speaker3,(GUIDSTRING)_Speaker4)
		THEN
		DB_NOOP(1);
		
		PROC
		Proc_DialogFlagSetup((STRING)_Dialog,(GUIDSTRING)_Speaker1,(GUIDSTRING)_Speaker2,(GUIDSTRING)_Speaker3,(GUIDSTRING)_Speaker4,(GUIDSTRING)_Speaker5)
		THEN
		DB_NOOP(1);
		
		PROC
		Proc_DialogFlagSetup((STRING)_Dialog,(GUIDSTRING)_Speaker1,(GUIDSTRING)_Speaker2,(GUIDSTRING)_Speaker3,(GUIDSTRING)_Speaker4,(GUIDSTRING)_Speaker5,(GUIDSTRING)_Speaker6)
		THEN
		DB_NOOP(1);
		//END_REGION
		
		IF	
		DialogEnded(_,_Inst)
		THEN
		DB_MarkedForDelete(_Inst);
		ProcClearDialogFlagsForPlayers(_Inst);
		ProcClearDialogFlagsForNPCs(_Inst);
		
		//REGION Animal Food Dialogs
		PROC
		ProcSetAnimalFoodEvents((CHARACTERGUID)_Player,_)
		THEN
		SetVarInteger(_Player,"GEN_HasAnimalFood",0);
		
		PROC
		ProcSetAnimalFoodEvents((CHARACTERGUID)_Player,(CHARACTERGUID)_Npc)
		AND
		DB_AnimalFoodVars(_Var)
		AND
		GetVarFixedString(_Npc,_Var,_TempVal)
		AND
		_TempVal!="DONTEAT"
		AND
		QryItemTemplateInMagicPockets(_Player,_tempVal)
		THEN
		SetVarInteger(_Player,"GEN_HasAnimalFood",1);
		
		PROC
		ProcGiveAnimalFood((CHARACTERGUID)_Player,(CHARACTERGUID)_Npc)
		AND
		DB_AnimalFoodVars(_Var)
		AND
		GetVarFixedString(_Npc,_Var,_TempVal)
		AND
		_TempVal!="DONTEAT"
		AND
		NOT DB_FoodGiven(_Player)
		AND
		QryRemoveItemTemplateFromMagicPockets(_Player,_TempVal,1)
		THEN
		DB_FoodGiven(_Player);
		CharacterAddAttitudeTowardsPlayer(_Npc,_Player,5);
		
		PROC
		ProcGiveAnimalFood(_Player,_Npc)
		THEN
		NOT DB_FoodGiven(_Player);
		
		IF
		ObjectFlagSet("GEN_PlayerGivesFood",_Player,_Inst)
		AND
		DB_DialogNPCs(_Inst,_Npc,1)
		THEN
		ProcGiveAnimalFood((CHARACTERGUID)_Player,(CHARACTERGUID)_Npc);
		//END_REGION
		
		//REGION Dialogs that must not be interceptable by custom scripts
		//END_REGION
		
		//REGION Custom script dialog Intercepts
		PROC
		PROC_GLOBAL_DialogStartRequested((GUIDSTRING)_Npc,(GUIDSTRING)_Player)
		THEN
		DB_NOOP(1);
		
		PROC
		SelectAndStartDialog((GUIDSTRING)_Player,(GUIDSTRING)_Npc) 
		THEN
		// Reverse order of parameters to be consisted with DialogStartRequested()
		PROC_GLOBAL_DialogStartRequested(_Npc,_Player);
		//END_REGION
		
		//REGION Hostile Dialog
		PROC
		StartHostileDialog((GUIDSTRING)_Player,(GUIDSTRING)_Npc)
		AND
		IsTagged(_Npc,"ANIMAL",1)
		THEN
		DB_FoundDialog(_Npc,_Player);
		ProcSetAnimalFoodEvents((CHARACTERGUID)_Player,(CHARACTERGUID)_Npc);
		Proc_StartDialog(0,"GEB_Default_AnimalHostile",_Npc,_Player); //TODO Change this Dialog to a new Style Dialog
		
		PROC
		StartHostileDialog((GUIDSTRING)_Player,(GUIDSTRING)_Npc)
		AND
		IsTagged(_Npc,"ANIMAL",0)
		THEN
		StartHostileDialog_1(_Player,_Npc);
		
		PROC
		StartHostileDialog_1((GUIDSTRING)_Player,(GUIDSTRING)_Npc)
		AND
		DB_HostileDialog(_Npc,(STRING)_Dialog)
		THEN
		DB_FoundDialog(_Npc,_Player);
		Proc_StartDialog(0,_Dialog,_Npc,_Player);
		
		PROC
		StartHostileDialog_1((GUIDSTRING)_Player,(GUIDSTRING)_Npc)
		AND
		NOT DB_FoundDialog(_Npc,_Player)
		THEN
		DB_FoundDialog(_Npc,_Player);
		Proc_StartDialog(0,"GEB_Default_Hostile",_Npc,_Player);
		//END_REGION
		
		//REGION Companion Redirects & ADs
		PROC
		SelectAndStartDialog((GUIDSTRING)_Player,(GUIDSTRING)_OtherPlayer) 
		AND
		NOT DB_FoundDialog(_OtherPlayer,_Player)
		AND
		DB_IsPlayer((CHARACTERGUID)_Player)
		AND
		DB_IsPlayer((CHARACTERGUID)_OtherPlayer)
		AND
		CharacterGetReservedUserID(_Player,_PID)
		AND
		CharacterGetReservedUserID(_OtherPlayer,_OPID)
		AND
		_PID != _OPID
		THEN
		Proc_StartDialog(1,"GLO_AD_CompanionCantTalk",_OtherPlayer);
		DB_FoundDialog(_OtherPlayer,_Player);
		
		PROC
		SelectAndStartDialog((GUIDSTRING)_Player,(GUIDSTRING)_OtherPlayer) 
		AND
		NOT DB_FoundDialog(_OtherPlayer,_Player)
		AND
		DB_IsPlayer((CHARACTERGUID)_Player)
		AND
		DB_IsPlayer((CHARACTERGUID)_OtherPlayer)
		AND
		IsTagged(_Player,"AVATAR",0)
		AND
		IsTagged(_OtherPlayer,"AVATAR",0)
		AND
		DB_CompanionAvatarBond(_OtherPlayer,_Avatar)
		AND
		IsTagged(_Avatar,"AVATAR",1)
		AND
		CharacterGetReservedUserID(_Avatar,_PID)
		AND
		CharacterGetReservedUserID(_OtherPlayer,_PID)
		AND
		QRY_SpeakerIsAvailableAndInDialogRange(_Avatar,_OtherPlayer)
		THEN
		SelectAndStartDialog(_Avatar,_OtherPlayer);
		MakePlayerActive(_Avatar);
		DB_FoundDialog(_OtherPlayer,_Player);
		
		PROC
		SelectAndStartDialog((GUIDSTRING)_Player,(GUIDSTRING)_OtherPlayer) 
		AND
		NOT DB_FoundDialog(_OtherPlayer,_Player)
		AND
		DB_IsPlayer((CHARACTERGUID)_Player)
		AND
		DB_IsPlayer((CHARACTERGUID)_OtherPlayer)
		AND
		IsTagged(_Player,"AVATAR",0)
		AND
		IsTagged(_OtherPlayer,"AVATAR",0)
		THEN
		Proc_StartDialog(1,"GLO_AD_CompanionCantTalk",_OtherPlayer);
		DB_FoundDialog(_OtherPlayer,_Player);
		
		PROC
		SelectAndStartDialog((GUIDSTRING)_Player,(GUIDSTRING)_Companion) 
		AND
		NOT DB_FoundDialog(_Companion,_Player)
		AND
		DB_GLO_PartyMembers_RecruiteeAvatarBond((CHARACTERGUID)_Companion,(CHARACTERGUID)_Player2)
		AND
		_Player != _Player2
		THEN
		Proc_StartDialog(0,"GLO_NonBondedCompanionDialog",_Companion,_Player);
		DB_FoundDialog(_Companion,_Player);
		
		PROC
		SelectAndStartDialog((GUIDSTRING)_Player,(GUIDSTRING)_Companion) 
		AND
		NOT DB_FoundDialog(_Companion,_Player)
		AND
		DB_RelationshipDialogs((CHARACTERGUID)_Companion,_Dialog)
		AND
		DB_CompanionAvatarBond((CHARACTERGUID)_Companion,(CHARACTERGUID)_Player)
		AND
		QRY_StartDialog(0,_Dialog,_Companion,_Player)
		THEN
		NOT DB_RelationshipDialogs(_Companion,_Dialog);
		DB_FoundDialog(_Companion,_Player);
		
		PROC
		SelectAndStartDialog((GUIDSTRING)_Player,(GUIDSTRING)_Npc) 
		AND
		IsTagged(_NPC,"ANIMAL",0)
		AND
		NOT DB_FoundDialog(_Npc,_Player)
		AND
		CharacterGetAttitudeTowardsPlayer((CHARACTERGUID)_Npc,(CHARACTERGUID)_Player,_Att)
		AND
		_Att <= -45
		AND
		NOT _Npc.DB_IsPlayer()
		AND
		NOT DB_NoLowAttitudeDialog(_Npc)
		THEN
		StartHostileDialog(_Player,_Npc);
		DB_FoundDialog(_Npc,_Player);
		//END_REGION
		
		//REGION Threatened Dialog
		PROC
		SelectAndStartDialog((GUIDSTRING)_Player,(GUIDSTRING)_NPC)
		AND
		NOT DB_FoundDialog(_NPC,_Player)
		AND
		CharacterIsInFightMode((CHARACTERGUID)_Player,1)
		AND
		NOT DB_IsPlayer((CHARACTERGUID)_NPC)
		AND
		NOT DB_BlockThreatenedDialog(_NPC)
		AND
		IsTagged(_NPC,"ANIMAL",0)
		AND
		NOT DB_CombatCharacters(_Player,_)
		THEN
		StartThreatenedDialog(_NPC,_Player);
		
		PROC 
		StartThreatenedDialog((GUIDSTRING)_NPC,(GUIDSTRING)_Player)
		AND
		CharacterCanTrade((CHARACTERGUID)_NPC,_CanTrade)
		THEN
		DB_FoundDialog(_NPC,_Player);
		Proc_StartDialog(0,"GEB_Warning_Weapons_StartDialog",_NPC,_Player);
		CharacterSetCanTrade(_NPC,0);
		DB_CouldTrade(_NPC,_CanTrade);
		
		IF
		DialogEnded("GEB_Warning_Weapons_StartDialog",_Inst)
		AND
		DB_DialogNPCs(_Inst,_NPC,1)
		AND
		DB_CouldTrade((CHARACTERGUID)_NPC,_CanTrade)
		THEN
		NOT DB_CouldTrade(_NPC,_CanTrade);
		CharacterSetCanTrade((CHARACTERGUID)_NPC,_CanTrade);
		
		//END_REGION
		
		//REGION Script intercept after generics
		PROC
		PROC_GLOBAL_DialogStartRequested_AfterGenerics((GUIDSTRING)_Npc,(GUIDSTRING)_Player)
		THEN
		DB_NOOP(1);
		
		PROC
		SelectAndStartDialog((GUIDSTRING)_Player,(GUIDSTRING)_Npc) 
		AND 
		NOT DB_FoundDialog(_Npc,_Player) 
		THEN
		PROC_GLOBAL_DialogStartRequested_AfterGenerics(_Npc,_Player);
		//END_REGION
		
		//REGION Dialog Start by clicking on NPC
		PROC	
		SelectAndStartDialog((GUIDSTRING)_Player,(GUIDSTRING)_Npc) 
		AND 
		NOT DB_FoundDialog(_Npc,_Player) 
		THEN
		DB_FoundDialog(_Npc,_Player);
		NPCDialogStartRequested(_Npc,_Player);// start the default dialog
		
		PROC
		SelectAndStartDialog((GUIDSTRING)_Player,(GUIDSTRING)_Npc) 
		THEN
		NOT DB_FoundDialog(_Npc,_Player);
		
		IF	
		DialogStartRequested(_Npc2,_Npc1)
		AND
		QRY_SpeakerIsAvailable(_Npc1)
		AND
		QRY_SpeakerIsAvailable(_Npc2)
		THEN
		SelectAndStartDialog(_Npc1,_Npc2);
		
		//END_REGION
		
		IF
		CharacterDying(_Char)
		THEN
		DialogRequestStop(_Char);
		
		IF
		CharacterUnlockedTalent(_Char,"AnimalEmpathy")
		THEN
		SetTag(_char,"PETPAL");
		
		IF
		CharacterLockedTalent(_Char,"AnimalEmpathy")
		THEN
		ClearTag(_char,"PETPAL");
		
		IF
		DB_IsPlayer(_Char)
		AND
		CharacterHasTalent(_Char,"AnimalEmpathy",1)
		THEN
		SetTag(_char,"PETPAL");
		
		IF
		CharacterCreationFinished(_Char)
		AND
		_Char != NULL_00000000-0000-0000-0000-000000000000
		AND
		CharacterHasTalent(_Char,"AnimalEmpathy",0)
		THEN
		ClearTag(_char,"PETPAL");
		
		//REGION Child dialogs
		IF
		ChildDialogRequested(_ChildDialog,_ParentInstance,_TargetInstance)
		AND
		NOT DB_CustomChildDialog(_ChildDialog)
		AND
		DB_DialogPlayers(_ParentInstance,_Player,1)
		THEN
		ProcStartChildDialog(_ChildDialog,_ParentInstance,_TargetInstance);
		
		PROC
		ProcStartChildDialog((STRING)_ChildDialog,(INTEGER)_ParentInstance,(INTEGER)_TargetInstance)
		THEN
		DB_TargetInstancespeakers(_TargetInstance,1,(CHARACTERGUID)NULL_00000000-0000-0000-0000-000000000000);
		DB_TargetInstancespeakers(_TargetInstance,2,(CHARACTERGUID)NULL_00000000-0000-0000-0000-000000000000);
		DB_TargetInstancespeakers(_TargetInstance,3,(CHARACTERGUID)NULL_00000000-0000-0000-0000-000000000000);
		DB_TargetInstancespeakers(_TargetInstance,4,(CHARACTERGUID)NULL_00000000-0000-0000-0000-000000000000);
		
		PROC
		ProcStartChildDialog((STRING)_ChildDialog,(INTEGER)_ParentInstance,(INTEGER)_TargetInstance)
		AND
		DB_DialogNumPlayers(_ParentInstance,_NumPlayers)
		AND
		DB_DialogNumNPCs(_ParentInstance,_NumNPCs)
		AND
		IntegerSum(_NumPlayers,_NumNPCs,_Total)
		AND
		_Total > 4
		THEN
		DebugBreak("too many speakers to fit in the child dialog! Need custom scripting and/or extension on speaker limit");
		
		PROC
		ProcStartChildDialog(_,(INTEGER)_ParentInstance,(INTEGER)_TargetInstance)
		AND
		DB_DialogNPCs(_ParentInstance,_NPC,_Index)
		THEN
		NOT DB_TargetInstancespeakers(_TargetInstance,_Index,NULL_00000000-0000-0000-0000-000000000000);
		DB_TargetInstancespeakers(_TargetInstance,_Index,(CHARACTERGUID)_NPC);
		
		PROC
		ProcStartChildDialog(_,(INTEGER)_ParentInstance,(INTEGER)_TargetInstance)
		AND
		DB_DialogPlayers(_ParentInstance,_Player,_Index)
		AND
		DB_DialogNumNPCs(_ParentInstance,_NumNPCs)
		AND
		IntegerSum(_NumNPCs,_Index,_PlayerIndex)
		THEN
		NOT DB_TargetInstancespeakers(_TargetInstance,_PlayerIndex,NULL_00000000-0000-0000-0000-000000000000);
		DB_TargetInstancespeakers(_TargetInstance,_PlayerIndex,(CHARACTERGUID)_Player);
		
		PROC
		ProcStartChildDialog(_ChildDialog,(INTEGER)_ParentInstance,(INTEGER)_TargetInstance)
		AND
		DB_TargetInstancespeakers(_TargetInstance,1,_Speaker1)
		AND
		DB_TargetInstancespeakers(_TargetInstance,2,_Speaker2)
		AND
		DB_TargetInstancespeakers(_TargetInstance,3,_Speaker3)
		AND
		DB_TargetInstancespeakers(_TargetInstance,4,_Speaker4)
		AND
		DialogStartChildDialog(_ChildDialog,_ParentInstance,_TargetInstance,_Speaker1,_Speaker2,_Speaker3,_Speaker4,_)
		THEN
		DB_NOOP(1);
		
		PROC
		ProcStartChildDialog(_ChildDialog,(INTEGER)_ParentInstance,(INTEGER)_TargetInstance)
		AND
		DB_TargetInstancespeakers(_TargetInstance,_Index,_Speaker)
		THEN
		NOT DB_TargetInstancespeakers(_TargetInstance,_Index,_Speaker);
		//END_REGION
		
	}
	EXIT
	{
		
	}
}
Goal(5).Title("__GLOBAL_ExplorationBonus");
Goal(5)
{
	INIT
	{
		
	}
	KB
	{
		IF
		DB_ExplorationZones((TRIGGERGUID)_Trigger,(INTEGER)_Act,(INTEGER)_ActPArt,(INTEGER)_Gain)
		AND
		NOT DB_Subregion(_Trigger,_,_) //Subregions can give XP without being Oneshot
		THEN
		ProcTriggerRegisterForPlayers(_Trigger);
		
		IF
		CharacterEnteredTrigger((CHARACTERGUID)_Player,(TRIGGERGUID)_Trigger)
		AND
		DB_ExplorationZones(_Trigger,(INTEGER)_Act,(INTEGER)_ActPart,(INTEGER)_Gain)
		THEN
		ProcAddXPToParty(_Player,_Trigger);
		ProcCheckRemoveExplorationZone(_Trigger);
		
		
		PROC
		ProcAddXPToParty((CHARACTERGUID)_Player,(TRIGGERGUID)_Trigger)
		AND
		DB_ExplorationZones(_Trigger,_Act,_ActPart,_Gain)
		AND
		DB_IsPlayer(_OtherPlayer)
		AND
		NOT DB_ExplorationXPGiven(_OtherPlayer,_Trigger)
		AND
		CharacterIsInPartyWith(_OtherPlayer,_Player,1)
		THEN
		DB_ExplorationXPGiven(_OtherPlayer,_Trigger);
		CharacterAddExplorationExperience(_OtherPlayer,_Act,_ActPart,_Gain);
		
		//Dont unregister if also a Subregion
		IF
		DB_ExplorationXPGiven(_OtherPlayer,_Trigger)
		AND
		NOT DB_Subregion(_Trigger,_,_)
		THEN
		TriggerUnregisterForCharacter(_Trigger,_OtherPlayer);
		
		PROC
		ProcCheckRemoveExplorationZone((TRIGGERGUID)_Trigger)
		AND
		DB_IsPlayer(_Player)
		AND
		NOT DB_ExplorationXPGiven(_Player,_Trigger)
		THEN
		DB_ExplorationZoneStillOpen(1);
		
		PROC
		ProcCheckRemoveExplorationZone(_Trigger)
		AND
		NOT DB_ExplorationZoneStillOpen(1)
		AND
		DB_ExplorationZones(_Trigger,_Act,_ActPart,_Gain)
		THEN
		NOT DB_ExplorationZones(_Trigger,_Act,_ActPart,_Gain);
		
		PROC
		ProcCheckRemoveExplorationZone(_Trigger)
		THEN
		NOT DB_ExplorationZoneStillOpen(1);
		
		IF
		CharacterJoinedParty(_Char)
		AND
		DB_ExplorationZones(_Trigger,_Act,_ActPart,_Gain)
		AND
		DB_ExplorationXPGiven(_Player,_Trigger)
		AND
		CharacterIsInPartyWith(_Player,_Char,1)
		THEN
		DB_ExplorationXPGiven(_Char,_Trigger);
		ProcCheckRemoveExplorationZone(_Trigger);
		
	}
	EXIT
	{
		
	}
}
Goal(6).Title("__GLOBAL_HiddenWalls");
Goal(6)
{
	INIT
	{
		DB_HiddenWallCount(0);
		
	}
	KB
	{
		//REGION Use event to open hidden wall
		
		IF
		GlobalFlagSet(_flag)
		AND
		DB_HiddenWallEvent((STRING)_flag, (INTEGER)_wallIndex)
		THEN
		PROC_OpenWall(_WallIndex);
		
		//END_REGION
		
		//REGION Action When Player Uses Item To Open Wall
		
		IF
		CharacterUsedItem(_Player, _Item)
		AND
		_Player.DB_IsPlayer()
		AND
		DB_HiddenWallItem((ITEMGUID)_Item, (INTEGER)_WallIndex)
		THEN
		PROC_CommentHiddenEffect(_Player);
		PROC_OpenWall(_WallIndex);
		
		//END_REGION
		
		//REGION Action When Player Uses Trigger To Open Wall
		
		IF
		DB_HiddenWallTrigger(_trigger, _)
		THEN
		DB_HW_CharCountInTrigger(_trigger, 0);
		
		IF
		CharacterEnteredTrigger(_, _trigger)
		AND
		DB_HiddenWallTrigger((TRIGGERGUID)_trigger, (INTEGER)_wallIndex)
		AND
		DB_HW_CharCountInTrigger(_trigger, _current)
		AND
		IntegerSum(_current, 1, _new)
		THEN
		NOT DB_HW_CharCountInTrigger(_trigger, _current);
		DB_HW_CharCountInTrigger(_trigger, _new);
		
		IF
		CharacterLeftTrigger(_, _trigger)
		AND
		DB_HiddenWallTrigger((TRIGGERGUID)_trigger, (INTEGER)_wallIndex)
		AND
		DB_HW_CharCountInTrigger(_trigger, _current)
		AND
		IntegerSubtract(_current, 1, _new)
		THEN
		NOT DB_HW_CharCountInTrigger(_trigger, _current);
		DB_HW_CharCountInTrigger(_trigger, _new);
		
		IF
		DB_HW_CharCountInTrigger(_trigger, _current)
		AND
		_current < 0
		THEN
		NOT DB_HW_CharCountInTrigger(_trigger, _current);
		DB_HW_CharCountInTrigger(_trigger, 0);
		
		IF
		DB_HW_CharCountInTrigger(_trigger, _current)
		AND
		_current > 0
		AND
		DB_HiddenWallTrigger(_trigger, _wallIndex)
		THEN
		PROC_OpenWall(_wallIndex);
		
		IF
		DB_HW_CharCountInTrigger(_trigger, _current)
		AND
		_current == 0
		AND
		DB_HiddenWallTrigger(_trigger, _wallIndex)
		THEN
		PROC_CloseWall(_wallIndex);
		
		
		//END_REGION
		
		//REGION Action When Player Uses Skills To Open Wall
		
		IF
		StoryEvent(_Wall, "Open")
		AND
		DB_HiddenWall(_WallIndex, (ITEMGUID)_Wall)
		THEN
		PROC_OpenWall(_WallIndex);
		
		//END_REGION
		
		//REGION Registering all the hidden walls 
		
		PROC
		PROC_Register_HiddenWall((ITEMGUID)_Wall)
		AND
		NOT DB_HiddenWall(_, (ITEMGUID)_Wall)
		AND
		DB_HiddenWallCount(_Current)
		AND
		IntegerSum(_Current, 1, _New)
		THEN
		NOT DB_HiddenWallCount(_Current);
		DB_HiddenWallCount(_New);
		DB_HiddenWall((INTEGER)_New, (ITEMGUID)_Wall);
		DB_HW_ClosedWalls(_New);
		
		//END_REGION
		
		//REGION Open/Close Hidden walls
		
		PROC
		PROC_OpenWall((INTEGER)_WallIndex)
		AND
		DB_HW_ClosedWalls(_WallIndex)
		AND
		DB_HiddenWall(_WallIndex, _Wall)
		THEN
		NOT DB_HW_ClosedWalls(_WallIndex);
		PlayEffect(_Wall, "RS3_FX_GP_ScriptedEvent_Teleport_GenericSmoke_01");
		SetOnStage(_Wall, 0);
		
		PROC
		PROC_CloseWall((INTEGER)_WallIndex)
		AND
		NOT DB_HW_ClosedWalls(_WallIndex)
		AND
		DB_HiddenWall(_WallIndex, _Wall)
		THEN
		DB_HW_ClosedWalls(_WallIndex);
		PlayEffect(_Wall, "RS3_FX_GP_ScriptedEvent_Teleport_GenericSmoke_01");
		SetOnStage(_Wall, 1);
		
		//END_REGION
		
	}
	EXIT
	{
		
	}
}
Goal(7).Title("__GLOBAL_ItemInteraction");
Goal(7)
{
	INIT
	{
		
	}
	KB
	{
		IF
		CharacterUsedItemTemplate(_Player, _Template, _)
		AND
		_Player.DB_IsPlayer()
		AND
		DB_RecipeBook(_Template, (STRING)_ID)
		THEN
		UnlockJournalRecipe(_ID);
		NOT DB_RecipeBook(_Template, _ID);
		
		PROC
		Proc_ItemRotateYduration((ITEMGUID)_Item,(REAL)_Angle,(INTEGER)_DurationMS)
		AND
		RealProduct(_Angle,1000.0,_AngleProd)
		AND
		Real(_DurationMS,_DurationReal)
		AND
		RealDivide(_AngleProd,_DurationReal,_Speed)
		THEN
		ItemRotateY(_Item,_Angle,_Speed);
		
		PROC
		Proc_ItemRotateToAngleYduration((ITEMGUID)_Item,(REAL)_Angle,(INTEGER)_DurationMS)
		AND
		RealProduct(_Angle,1000.0,_AngleProd)
		AND
		Real(_DurationMS,_DurationReal)
		AND
		RealDivide(_AngleProd,_DurationReal,_Speed)
		THEN
		ItemRotateY(_Item,_Angle,_Speed);
		
	}
	EXIT
	{
		
	}
}
Goal(8).Title("__GLOBAL_ItemRotationPuzzles");
Goal(8)
{
	INIT
	{
		DB_IRP_Internal_IndexCount(0);
		
	}
	KB
	{
		//REGION Initialization of databases
		
		PROC
		PROC_Puzzle_RegisterRotatingItem((STRING)_puzzleName, (ITEMGUID)_item, (INTEGER)_solution)
		AND
		DB_IRP_Internal_IndexCount(_index)
		THEN
		DB_IRP_IncreaseInternalCount();
		DB_IRP_Internal_Items((INTEGER)_index, (ITEMGUID)_item, 0);
		DB_IRP_Internal_Solutions((INTEGER)_index, (INTEGER)_solution);
		DB_IRP_Internal_Puzzles((STRING)_puzzleName, (INTEGER)_index, 0);
		PROC_IRP_Internal_IncreasePuzzleItemcount(_puzzleName);
		
		PROC
		DB_IRP_IncreaseInternalCount()
		AND
		DB_IRP_Internal_IndexCount(_indexCount)
		AND
		IntegerSum(_indexCount, 1, _newIndex)
		THEN
		NOT DB_IRP_Internal_IndexCount(_indexCount);
		DB_IRP_Internal_IndexCount(_newIndex);
		
		PROC
		PROC_ItemRotatePuzzle_AddItemToHandle((ITEMGUID)_handle, (ITEMGUID)_item)
		AND
		DB_IRP_Internal_Items(_index, _item, _)
		THEN
		DB_IRP_Internal_Handles(_handle, _index);
		
		PROC
		PROC_IRP_Internal_IncreasePuzzleItemcount((STRING)_puzzleName)
		AND
		NOT DB_IRP_Internal_PuzzlesTotalItemCount(_puzzleName, _)
		THEN
		DB_IRP_Internal_PuzzlesTotalItemCount(_puzzleName, 0);
		DB_IRP_Internal_PuzzlesItemsSolved(_puzzleName, 0);
		
		PROC
		PROC_IRP_Internal_IncreasePuzzleItemcount((STRING)_puzzleName)
		AND
		DB_IRP_Internal_PuzzlesTotalItemCount(_puzzleName, _count)
		AND
		IntegerSum(_count, 1, _newTotal)
		THEN
		NOT DB_IRP_Internal_PuzzlesTotalItemCount(_puzzleName, _count);
		DB_IRP_Internal_PuzzlesTotalItemCount(_puzzleName, _newTotal);
		
		//END_REGION
		
		
		//REGION Rotate items
		
		IF
		CharacterUsedItem(_player, _handle)
		AND
		_player.DB_IsPlayer()
		AND
		DB_IRP_Internal_Handles(_handle, _index)
		AND
		DB_IRP_Internal_Items(_index, _item, _)
		THEN
		PROC_IRP_RotateItem(_item);
		
		IF
		CharacterUsedItem(_player, _item)
		AND
		_player.DB_IsPlayer()
		AND
		DB_IRP_Internal_Items(_index, _item, _)
		THEN
		PROC_IRP_RotateItem(_item);
		
		PROC
		PROC_IRP_RotateItem((ITEMGUID)_item)
		AND
		DB_IRP_Internal_Items(_index, _item, _turnCount)
		AND
		DB_IRP_Internal_Puzzles(_puzzleName, _index, _)
		AND
		IntegerSum(_turnCount, 1, _newTurnCount)
		THEN
		NOT DB_IRP_Internal_Items(_index, _item, _turnCount);
		DB_IRP_Internal_Items(_index, _item, _newTurnCount);
		ItemRotateY(_item, 90.0, 135.0);
		PROC_IRP_CheckItemState(_item);
		PROC_IRP_CheckPuzzleState(_puzzleName);
		
		IF
		DB_IRP_Internal_Items(_index, _item, 4)
		THEN
		NOT DB_IRP_Internal_Items(_index, _item, 4);
		DB_IRP_Internal_Items(_index, _item, 0);
		
		//END_REGION
		
		//REGION Check for item solution
		
		PROC
		PROC_IRP_CheckItemState((ITEMGUID)_item)
		AND
		DB_IRP_Internal_Items(_index, _item, _turnCount)
		AND
		DB_IRP_Internal_Puzzles(_puzzleName, _index, 0)
		AND
		DB_IRP_Internal_Solutions(_index, _solution)
		AND
		_turnCount == _solution
		THEN 
		NOT DB_IRP_Internal_Puzzles(_puzzleName, _index, 0);
		DB_IRP_Internal_Puzzles(_puzzleName, _index, 1);
		
		PROC
		PROC_IRP_CheckItemState((ITEMGUID)_item)
		AND
		DB_IRP_Internal_Items(_index, _item, _turnCount)
		AND
		DB_IRP_Internal_Puzzles(_puzzleName, _index, 1)
		AND
		DB_IRP_Internal_Solutions(_index, _solution)
		AND
		NOT _turnCount == _solution
		THEN 
		NOT DB_IRP_Internal_Puzzles(_puzzleName, _index, 1);
		DB_IRP_Internal_Puzzles(_puzzleName, _index, 0);
		
		//END_REGION
		
		//REGION Check for puzzle solution
		
		PROC
		PROC_IRP_CheckPuzzleState((STRING)_puzzleName)
		AND
		DB_IRP_Internal_Puzzles(_puzzleName, _, 1)
		AND
		DB_IRP_Internal_PuzzlesItemsSolved(_puzzleName, _count)
		AND
		IntegerSum(_count, 1, _new)
		THEN
		NOT DB_IRP_Internal_PuzzlesItemsSolved(_puzzleName, _count);
		DB_IRP_Internal_PuzzlesItemsSolved(_puzzleName, _new);
		
		PROC
		PROC_IRP_CheckPuzzleState((STRING)_puzzleName)
		AND
		DB_IRP_Internal_PuzzlesItemsSolved(_puzzleName, _itemsSolved)
		AND
		NOT DB_IRP_Internal_PuzzlesTotalItemCount(_puzzleName, _itemsSolved)
		THEN
		NOT DB_IRP_Internal_PuzzlesItemsSolved(_puzzleName, _itemsSolved);
		DB_IRP_Internal_PuzzlesItemsSolved(_puzzleName, 0);
		GlobalClearFlag(_puzzleName);
		
		PROC
		PROC_IRP_CheckPuzzleState((STRING)_puzzleName)
		AND
		DB_IRP_Internal_PuzzlesItemsSolved(_puzzleName, _itemsSolved)
		AND
		DB_IRP_Internal_PuzzlesTotalItemCount(_puzzleName, _itemsSolved)
		THEN
		NOT DB_IRP_Internal_PuzzlesItemsSolved(_puzzleName, _itemsSolved);
		DB_IRP_Internal_PuzzlesItemsSolved(_puzzleName, 0);
		GlobalSetFlag(_puzzleName);
		
		//END_REGION
		
		
	}
	EXIT
	{
		
	}
}
Goal(9).Title("__OneshotDialogs");
Goal(9)
{
	INIT
	{
		
	}
	KB
	{
		//REGION One Shot Normal Dialogs
		IF
		DB_OneShot_PlayerOnlyDialogTrigger((TRIGGERGUID)_Trigger,(STRING)_Dialog,(CHARACTERGUID)_NPC)
		THEN
		DB_OneShotPlayerOnlyTrigger(_Trigger);
		DB_OneShot_DialogSpeakerCount(_Trigger,_Dialog,1);
		DB_OneShot_DialogSpeakers(_Trigger,_Npc,1);
		
		IF
		DB_OneShot_DialogTrigger((TRIGGERGUID)_Trigger,(STRING)_Dialog,(CHARACTERGUID)_NPC)
		THEN
		DB_OneShotPlayerTrigger(_Trigger);
		DB_OneShot_DialogSpeakerCount(_Trigger,_Dialog,1);
		DB_OneShot_DialogSpeakers(_Trigger,_Npc,1);
		
		IF
		DB_OneShot_DialogTrigger((TRIGGERGUID)_Trigger,(STRING)_Dialog,(CHARACTERGUID)_NPC,(CHARACTERGUID)_NPC2)
		THEN
		DB_OneShotPlayerTrigger(_Trigger);
		DB_OneShot_DialogSpeakerCount(_Trigger,_Dialog,2);
		DB_OneShot_DialogSpeakers(_Trigger,_Npc,1);
		DB_OneShot_DialogSpeakers(_Trigger,_Npc2,2);
		
		IF
		DB_OneShot_DialogTrigger((TRIGGERGUID)_Trigger,(STRING)_Dialog,(CHARACTERGUID)_NPC,(CHARACTERGUID)_NPC2,(CHARACTERGUID)_NPC3)
		THEN
		DB_OneShotPlayerTrigger(_Trigger);
		DB_OneShot_DialogSpeakerCount(_Trigger,_Dialog,3);
		DB_OneShot_DialogSpeakers(_Trigger,_Npc,1);
		DB_OneShot_DialogSpeakers(_Trigger,_Npc2,2);
		DB_OneShot_DialogSpeakers(_Trigger,_Npc3,3);
		
		IF
		DB_OneShot_DialogTrigger((TRIGGERGUID)_Trigger,(STRING)_Dialog,(CHARACTERGUID)_NPC,(CHARACTERGUID)_NPC2,(CHARACTERGUID)_NPC3,(CHARACTERGUID)_NPC4)
		THEN
		DB_OneShotPlayerTrigger(_Trigger);
		DB_OneShot_DialogSpeakerCount(_Trigger,_Dialog,4);
		DB_OneShot_DialogSpeakers(_Trigger,_Npc,1);
		DB_OneShot_DialogSpeakers(_Trigger,_Npc2,2);
		DB_OneShot_DialogSpeakers(_Trigger,_Npc3,3);
		DB_OneShot_DialogSpeakers(_Trigger,_Npc4,4);
		
		PROC
		ProcCheckIfNPCsBusy((TRIGGERGUID)_Trigger)
		AND
		DB_OneShot_DialogSpeakers(_Trigger,_Npc,_)
		AND
		NOT QRY_SpeakerIsAvailable(_Npc,1)
		THEN
		DB_OneShot_BusyNPC(_Trigger);
		
		PROC
		ProcDoStartOneShotDialog((CHARACTERGUID)_Player,(TRIGGERGUID)_Trigger)
		AND
		DB_OneShot_DialogSpeakerCount(_Trigger,_Dialog,1)
		AND
		DB_OneShot_DialogSpeakers(_Trigger,_Npc,1)
		THEN
		Proc_StartDialog(0,_Dialog,_Npc,_Player);
		
		PROC
		ProcDoStartOneShotDialog((CHARACTERGUID)_Player,(TRIGGERGUID)_Trigger)
		AND
		DB_OneShot_DialogSpeakerCount(_Trigger,_Dialog,2)
		AND
		DB_OneShot_DialogSpeakers(_Trigger,_Npc,1)
		AND
		DB_OneShot_DialogSpeakers(_Trigger,_Npc2,2)
		THEN
		Proc_StartDialog(0,_Dialog,_Npc,_Npc2,_Player);
		
		PROC
		ProcDoStartOneShotDialog((CHARACTERGUID)_Player,(TRIGGERGUID)_Trigger)
		AND
		DB_OneShot_DialogSpeakerCount(_Trigger,_Dialog,3)
		AND
		DB_OneShot_DialogSpeakers(_Trigger,_Npc,1)
		AND
		DB_OneShot_DialogSpeakers(_Trigger,_Npc2,2)
		AND
		DB_OneShot_DialogSpeakers(_Trigger,_Npc3,3)
		THEN
		Proc_StartDialog(0,_Dialog,_Npc,_Npc2,_Npc3,_Player);
		
		PROC
		ProcStartOneShotDialog((CHARACTERGUID)_Player,(TRIGGERGUID)_Trigger)
		AND
		NOT DB_OneShot_BusyNPC(_Trigger)
		THEN
		ProcDoStartOneShotDialog(_Player,_Trigger);
		
		PROC
		ProcClearOneShotCount((TRIGGERGUID)_Trigger)
		AND
		DB_OneShot_DialogSpeakerCount(_Trigger,_Dialog,1)
		AND
		DB_OneShot_DialogTrigger((TRIGGERGUID)_Trigger,(STRING)_Dialog,(CHARACTERGUID)_NPC)
		THEN
		NOT DB_OneShot_DialogTrigger(_Trigger,_Dialog,_NPC);
		
		PROC
		ProcClearOneShotCount((TRIGGERGUID)_Trigger)
		AND
		DB_OneShot_DialogSpeakerCount(_Trigger,_Dialog,2)
		AND
		DB_OneShot_DialogTrigger((TRIGGERGUID)_Trigger,(STRING)_Dialog,(CHARACTERGUID)_NPC,(CHARACTERGUID)_NPC2)
		THEN
		NOT DB_OneShot_DialogTrigger(_Trigger,_Dialog,_NPC,_NPC2);
		
		PROC
		ProcClearOneShotCount((TRIGGERGUID)_Trigger)
		AND
		DB_OneShot_DialogSpeakerCount(_Trigger,_Dialog,3)
		AND
		DB_OneShot_DialogTrigger((TRIGGERGUID)_Trigger,(STRING)_Dialog,(CHARACTERGUID)_NPC,(CHARACTERGUID)_NPC2,(CHARACTERGUID)_NPC3)
		THEN
		NOT DB_OneShot_DialogTrigger(_Trigger,_Dialog,_NPC,_NPC2,_NPC3);
		
		
		PROC
		ProcClearOneShotCount((TRIGGERGUID)_Trigger)
		AND
		DB_OneShot_DialogSpeakerCount(_Trigger,_Dialog,4)
		AND
		DB_OneShot_DialogTrigger((TRIGGERGUID)_Trigger,(STRING)_Dialog,(CHARACTERGUID)_NPC,(CHARACTERGUID)_NPC2,(CHARACTERGUID)_NPC3,(CHARACTERGUID)_NPC4)
		THEN
		NOT DB_OneShot_DialogTrigger(_Trigger,_Dialog,_NPC,_NPC2,_NPC3,_NPC4);
		
		PROC
		ProcClearOneShotCount((TRIGGERGUID)_Trigger)
		AND
		DB_OneShot_DialogSpeakerCount(_Trigger,_Dialog,_Count)
		THEN
		NOT DB_OneShot_DialogSpeakerCount(_Trigger,_Dialog,_Count);
		
		PROC
		ProcClearOneShotSpeakers((TRIGGERGUID)_Trigger)
		AND
		DB_OneShot_DialogSpeakers(_Trigger,_Npc,_Count)
		THEN
		NOT DB_OneShot_DialogSpeakers(_Trigger,_Npc,_Count);
		
		PROC
		ProcOneShotDialogCleanup((TRIGGERGUID)_Trigger)
		THEN
		ProcClearOneShotCount(_Trigger);
		ProcClearOneShotSpeakers(_Trigger);
		
		PROC
		RemoveOneShotDialog((TRIGGERGUID)_Trigger)
		THEN
		ProcOneShotDialogCleanup(_Trigger);
		ProcTriggerUnregisterForPlayers(_Trigger);
		NOT DB_OneShotPlayerTrigger(_Trigger);
		
		IF
		DB_Dead(_Npc)
		AND
		DB_OneShot_DialogSpeakers(_Trigger,_Npc,_)
		THEN
		RemoveOneShotDialog(_Trigger);
		
		PROC
		ProcOneShotTriggerEntered((CHARACTERGUID)_Player,(TRIGGERGUID)_Trigger)
		AND
		DB_OneShot_DialogSpeakerCount(_Trigger,_,_)
		AND
		QRY_SpeakerIsAvailable(_Player)
		THEN
		ProcCheckIfNPCsBusy(_Trigger); //TODO: do this busy check? Dialogs won't ever start if one of these NPCs is busy
		ProcStartOneShotDialog(_Player,_Trigger);
		
		PROC
		ProcStartOneShotDialog(_,(TRIGGERGUID)_Trigger)
		THEN
		NOT DB_OneShot_BusyNPC(_Trigger);
		
		PROC
		ProcStartOneShotDialog(_,(TRIGGERGUID)_Trigger)
		THEN
		ProcOneShotDialogCleanup(_Trigger);
		
		//if the dialog is started (manually), cleanup so this doesn't get started again
		IF
		DialogStarted(_Dialog,_)
		AND
		DB_OneShot_DialogSpeakerCount(_Trigger,_Dialog,_Count)
		THEN
		ProcOneShotDialogCleanup(_Trigger);
		ProcTriggerUnregisterForPlayers(_Trigger);
		NOT DB_OneShotPlayerTrigger(_Trigger); //because this might not have triggerd yet and we don't want to leave these around
		
		//END_REGION
		
		//REGION One Shot Automated Dialogs
		
		IF
		DB_OneShot_ADTrigger((TRIGGERGUID)_Trigger,(STRING)_Dialog,(CHARACTERGUID)_NPC)
		THEN
		DB_OneShotPlayerTrigger(_Trigger);
		DB_OneShot_ADSpeakerCount(_Trigger,_Dialog,1);
		DB_OneShot_ADSpeakers(_Trigger,_Npc,1);
		
		IF
		DB_OneShot_ADTrigger((TRIGGERGUID)_Trigger,(STRING)_Dialog,(CHARACTERGUID)_NPC,(CHARACTERGUID)_NPC2)
		THEN
		DB_OneShotPlayerTrigger(_Trigger);
		DB_OneShot_ADSpeakerCount(_Trigger,_Dialog,2);
		DB_OneShot_ADSpeakers(_Trigger,_Npc,1);
		DB_OneShot_ADSpeakers(_Trigger,_Npc2,2);
		
		PROC
		ProcDoStartOneShotAD((CHARACTERGUID)_Player,(TRIGGERGUID)_Trigger)
		AND
		DB_OneShot_ADSpeakerCount(_Trigger,_Dialog,1)
		AND
		DB_OneShot_ADSpeakers(_Trigger,_Npc,1)
		THEN
		Proc_StartDialog(1,_Dialog,_Npc);
		
		PROC
		ProcDoStartOneShotAD((CHARACTERGUID)_Player,(TRIGGERGUID)_Trigger)
		AND
		DB_OneShot_ADSpeakerCount(_Trigger,_Dialog,2)
		AND
		DB_OneShot_ADSpeakers(_Trigger,_Npc,1)
		AND
		DB_OneShot_ADSpeakers(_Trigger,_Npc2,2)
		THEN
		Proc_StartDialog(1,_Dialog,_Npc,_Npc2);
		
		PROC
		ProcClearOneShotADCount((TRIGGERGUID)_Trigger)
		AND
		DB_OneShot_ADSpeakerCount(_Trigger,_Dialog,1)
		AND
		DB_OneShot_ADTrigger((TRIGGERGUID)_Trigger,(STRING)_Dialog,(CHARACTERGUID)_NPC)
		THEN
		NOT DB_OneShot_ADTrigger(_Trigger,_Dialog,_NPC);
		
		PROC
		ProcClearOneShotADCount((TRIGGERGUID)_Trigger)
		AND
		DB_OneShot_ADSpeakerCount(_Trigger,_Dialog,2)
		AND
		DB_OneShot_ADTrigger((TRIGGERGUID)_Trigger,(STRING)_Dialog,(CHARACTERGUID)_NPC,(CHARACTERGUID)_NPC2)
		THEN
		NOT DB_OneShot_ADTrigger(_Trigger,_Dialog,_NPC,_NPC2);
		
		PROC
		ProcClearOneShotADSpeakers((TRIGGERGUID)_Trigger)
		AND
		DB_OneShot_ADSpeakers(_Trigger,_Npc,_Count)
		THEN
		NOT DB_OneShot_ADSpeakers(_Trigger,_Npc,_Count);
		
		PROC
		ProcOneShotADCleanup((TRIGGERGUID)_Trigger)
		THEN
		ProcClearOneShotADCount(_Trigger);
		ProcClearOneShotADSpeakers(_Trigger);
		
		PROC
		RemoveOneShotAD((TRIGGERGUID)_Trigger)
		THEN
		ProcOneShotADCleanup(_Trigger);
		ProcTriggerUnregisterForPlayers(_Trigger);
		NOT DB_OneShotPlayerTrigger(_Trigger);
		
		IF
		DB_Dead(_Npc)
		AND
		DB_OneShot_ADSpeakers(_Trigger,_Npc,_)
		THEN
		RemoveOneShotAD(_Trigger);
		
		PROC
		ProcOneShotTriggerEntered((CHARACTERGUID)_Player,(TRIGGERGUID)_Trigger)
		AND
		DB_OneShot_ADSpeakerCount(_Trigger,_,_)
		AND
		DB_OneShot_ADSpeakers(_Trigger,_Npc,1)
		AND
		QRY_SpeakerIsAvailable(_Player)
		AND
		QRY_SpeakerIsAvailable(_Npc)
		THEN
		ProcDoStartOneShotAD(_Player,_Trigger);
		ProcOneShotADCleanup(_Trigger);
		
		//if the dialog is started (manually), cleanup so this doesn't get started again
		IF
		AutomatedDialogStarted(_Dialog,_)
		AND
		DB_OneShot_ADSpeakerCount(_Trigger,_Dialog,_Count)
		THEN
		ProcOneShotADCleanup(_Trigger);
		ProcTriggerUnregisterForPlayers(_Trigger);
		
		//END_REGION
		
		//REGION One Shot Voice Bark
		
		IF
		DB_OneShot_VoiceBarkTrigger((TRIGGERGUID)_Trigger,(STRING)_VoiceBark)
		THEN
		DB_OneShotPlayerTrigger(_Trigger);
		
		PROC
		ProcOneShotTriggerEntered(_Player,_Trigger)
		AND
		DB_OneShot_VoiceBarkTrigger(_Trigger,_VoiceBark)
		AND
		QRY_SpeakerIsAvailable(_Player)
		THEN
		StartVoiceBark(_VoiceBark,_Player);
		
		IF
		VoiceBarkStarted(_VoiceBark,_)
		AND
		DB_OneShot_VoiceBarkTrigger(_Trigger,_VoiceBark)
		THEN
		NOT DB_OneShot_VoiceBarkTrigger(_Trigger,_VoiceBark);
		
		IF
		VoiceBarkFailed(_VoiceBark)
		AND
		DB_OneShot_VoiceBarkTrigger(_Trigger,_VoiceBark)
		THEN
		NOT DB_OneShot_VoiceBarkTrigger(_Trigger,_VoiceBark);
		
		//END_REGION
		
	}
	EXIT
	{
		
	}
}
Goal(10).Title("__PROC");
Goal(10)
{
	INIT
	{
		DB_InternalGroup_Count(0);
		
		
	}
	KB
	{
		PROC
		CharacterGiveReward((CHARACTERGUID)_Player,(STRING)_Reward)
		THEN
		CharacterGiveReward(_Player,_Reward,1);
		
		//REGION Defaults for item adding
		PROC
		ItemTemplateAddTo((STRING)_ItemTemplate, (GUIDSTRING)_Object, (INTEGER)_Count)
		THEN
		ItemTemplateAddTo(_ItemTemplate,_Object,_Count,1);
		
		PROC
		ItemToInventory((ITEMGUID)_Item,(GUIDSTRING)_Container)
		THEN
		ItemToInventory(_Item,_Container,1,1,1);
		
		PROC
		ItemToInventory((ITEMGUID)_Item, (GUIDSTRING)_TargetObject, (INTEGER)_Amount)
		THEN
		ItemToInventory(_Item, _TargetObject, _Amount, 1, 1);
		
		PROC
		ItemToInventory((ITEMGUID)_Item, (GUIDSTRING)_TargetObject, (INTEGER)_Amount, (INTEGER)_ShowNotification)
		THEN
		ItemToInventory(_Item, _TargetObject, _Amount, _ShowNotification, 1);
		
		//END_REGION
		
		//REGION Follow logic 
		PROC
		ProcCharacterFollowCharacter((CHARACTERGUID)_Char,(CHARACTERGUID)_Target)
		THEN
		ProcCharacterStopFollow(_Char);
		DB_Following(_Char,_Target);
		ProcCheckCombatFollow(_Char,_Target);
		
		PROC
		ProcCheckCombatFollow((CHARACTERGUID)_Char,(CHARACTERGUID)_Target)
		AND
		CombatGetIDForCharacter(_Char,0)
		THEN
		CharacterFollowCharacter(_Char,_Target);
		
		PROC
		ProcCharacterStopFollow((CHARACTERGUID)_Char)
		AND
		CharacterIsDead(_Char,0)
		THEN
		CharacterStopFollow(_Char);
		
		PROC
		ProcCharacterStopFollow((CHARACTERGUID)_Char)
		AND
		DB_Following(_Char,_Target)
		THEN
		NOT DB_Following(_Char,_Target);
		
		IF
		CharacterDying(_Char)
		THEN
		ProcCharacterStopFollow(_Char);
		
		IF
		ObjectEnteredCombat((CHARACTERGUID)_Obj,_)
		AND
		DB_Following(_Obj,_)
		THEN
		CharacterStopFollow(_Obj);
		
		IF
		ObjectLeftCombat((CHARACTERGUID)_Obj,_)
		AND
		DB_Following(_Obj,_Target)
		THEN
		CharacterFollowCharacter(_Obj,_Target);
		
		//END_REGION
		
		IF
		DB_DoNotFace((GUIDSTRING)_Char)
		THEN
		CharacterSetDoNotFaceFlag((CHARACTERGUID)_Char,1);
		DB_CheckDoNotFace(_Char);
		
		IF
		DB_CheckDoNotFace(_Char)
		AND
		NOT DB_DoNotFace(_Char)
		THEN
		CharacterSetDoNotFaceFlag((CHARACTERGUID)_Char,0);
		NOT DB_CheckDoNotFace(_Char);
		
		PROC
		ProcFaceCharacter((GUIDSTRING)_Char,(GUIDSTRING)_Target)
		AND
		NOT DB_DoNotFace(_Char)
		AND
		ObjectIsCharacter(_Char,1)
		AND
		CharacterIsIncapacitated((CHARACTERGUID)_Char,0)
		THEN
		CharacterLookAt((CHARACTERGUID)_Char,_Target,0);
		
		PROC
		ProcFaceEachother((GUIDSTRING)_Char,(GUIDSTRING)_Target)
		AND
		NOT DB_DoNotFace(_Char)
		AND
		ObjectIsCharacter(_Char,1)
		AND
		CharacterIsIncapacitated((CHARACTERGUID)_Char,0)
		THEN
		CharacterLookAt((CHARACTERGUID)_Char,_Target,0);
		
		PROC
		ProcFaceEachother((GUIDSTRING)_Char,(GUIDSTRING)_Target)
		AND
		NOT DB_DoNotFace(_Target)
		AND
		ObjectIsCharacter(_Target,1)
		AND
		CharacterIsIncapacitated((CHARACTERGUID)_Target,0)
		THEN
		CharacterLookAt((CHARACTERGUID)_Target,_Char,0);
		
		//REGION Internal Dialog Logic (Starting dialog by clicking on NPC)
		PROC
		ProcIncreaseInternalCount()
		AND
		DB_InternalGroup_Count(_Nr)
		AND
		IntegerSum(_Nr,1,_New)
		THEN
		NOT DB_InternalGroup_Count(_Nr);
		DB_InternalGroup_Count(_New);
		
		IF
		DB_Dialogs((GUIDSTRING)_Npc,(STRING)_Dialog)
		THEN
		SetHasDialog(_Npc,1);
		ProcIncreaseInternalCount();
		ProcInteralCounterEntry(_Npc,_Dialog);
		
		PROC
		ProcInteralCounterEntry((GUIDSTRING)_Npc,(STRING)_Dialog)
		AND
		DB_InternalGroup_Count(_New)
		THEN
		DB_InternalCounter(_New,_Dialog,1);
		DB_Internal_Dialogs(_Npc,_Dialog,_New,1);
		
		IF
		DB_Dialogs((GUIDSTRING)_Npc,(GUIDSTRING)_Npc2,(STRING)_Dialog)
		THEN
		SetHasDialog(_Npc,1);
		SetHasDialog(_Npc2,1);
		ProcIncreaseInternalCount();
		ProcInteralCounterEntry(_Npc,_Npc2,_Dialog);
		
		PROC
		ProcInteralCounterEntry((GUIDSTRING)_Npc,(GUIDSTRING)_Npc2,(STRING)_Dialog)
		AND
		DB_InternalGroup_Count(_Group)
		THEN
		DB_InternalCounter(_Group,_Dialog,2);
		DB_Internal_Dialogs(_Npc,_Dialog,_Group,1);
		DB_Internal_Dialogs(_Npc2,_Dialog,_Group,2);
		
		IF
		DB_Dialogs((GUIDSTRING)_Npc,(GUIDSTRING)_Npc2,(GUIDSTRING)_Npc3,(STRING)_Dialog)
		THEN
		SetHasDialog(_Npc,1);
		SetHasDialog(_Npc2,1);
		SetHasDialog(_Npc3,1);
		ProcIncreaseInternalCount();
		ProcInteralCounterEntry(_Npc,_Npc2,_Npc3,_Dialog);
		
		PROC
		ProcInteralCounterEntry((GUIDSTRING)_Npc,(GUIDSTRING)_Npc2,(GUIDSTRING)_Npc3,(STRING)_Dialog)
		AND
		DB_InternalGroup_Count(_Group)
		THEN
		DB_InternalCounter(_Group,_Dialog,3);
		DB_Internal_Dialogs(_Npc,_Dialog,_Group,1);
		DB_Internal_Dialogs(_Npc2,_Dialog,_Group,2);
		DB_Internal_Dialogs(_Npc3,_Dialog,_Group,3);
		
		IF
		DB_Dialogs((GUIDSTRING)_Npc,(GUIDSTRING)_Npc2,(GUIDSTRING)_Npc3,(GUIDSTRING)_Npc4,(STRING)_Dialog)
		THEN
		SetHasDialog(_Npc,1);
		SetHasDialog(_Npc2,1);
		SetHasDialog(_Npc3,1);
		SetHasDialog(_Npc4,1);
		ProcIncreaseInternalCount();
		ProcInteralCounterEntry(_Npc,_Npc2,_Npc3,_Npc4,_Dialog);
		
		PROC
		ProcInteralCounterEntry((GUIDSTRING)_Npc,(GUIDSTRING)_Npc2,(GUIDSTRING)_Npc3,(GUIDSTRING)_Npc4,(STRING)_Dialog)
		AND
		DB_InternalGroup_Count(_Group)
		THEN
		DB_InternalCounter(_Group,_Dialog,4);
		DB_Internal_Dialogs(_Npc,_Dialog,_Group,1);
		DB_Internal_Dialogs(_Npc2,_Dialog,_Group,2);
		DB_Internal_Dialogs(_Npc3,_Dialog,_Group,3);
		DB_Internal_Dialogs(_Npc4,_Dialog,_Group,4);
		
		PROC
		ProcStartNPCDialog((GUIDSTRING)_Player,(STRING)_Dialog,(INTEGER)_Group)
		AND
		DB_InternalCounter(_Group,_Dialog,1)
		AND
		DB_Internal_Dialogs(_Npc,_Dialog,_Group,1)
		THEN
		Proc_StartDialog(0,_Dialog,_Npc,_Player);
		
		PROC
		ProcStartNPCDialog((GUIDSTRING)_Player,(STRING)_Dialog,(INTEGER)_Group)
		AND
		DB_InternalCounter(_Group,_Dialog,2)
		AND
		DB_Internal_Dialogs(_Npc,_Dialog,_Group,1)
		AND
		DB_Internal_Dialogs(_Npc2,_Dialog,_Group,2)
		THEN
		Proc_StartDialog(0,_Dialog,_Npc,_Npc2,_Player);
		
		PROC
		ProcStartNPCDialog((GUIDSTRING)_Player,(STRING)_Dialog,(INTEGER)_Group)
		AND
		DB_InternalCounter(_Group,_Dialog,3)
		AND
		DB_Internal_Dialogs(_Npc,_Dialog,_Group,1)
		AND
		DB_Internal_Dialogs(_Npc2,_Dialog,_Group,2)
		AND
		DB_Internal_Dialogs(_Npc3,_Dialog,_Group,3)
		THEN
		Proc_StartDialog(0,_Dialog,_Npc,_Npc2,_Npc3,_Player);
		
		PROC
		ProcStartNPCDialog((GUIDSTRING)_Player,(STRING)_Dialog,(INTEGER)_Group)
		AND
		DB_InternalCounter(_Group,_Dialog,4)
		AND
		DB_Internal_Dialogs(_Npc,_Dialog,_Group,1)
		AND
		DB_Internal_Dialogs(_Npc2,_Dialog,_Group,2)
		AND
		DB_Internal_Dialogs(_Npc3,_Dialog,_Group,3)
		AND
		DB_Internal_Dialogs(_Npc4,_Dialog,_Group,4)
		THEN
		Proc_StartDialog(0,_Dialog,_Npc,_Npc2,_Npc3,_Npc4,_Player);
		
		
		PROC
		NPCDialogStartRequested((GUIDSTRING)_Npc,(GUIDSTRING)_Player)
		AND
		DB_Internal_Dialogs(_Npc,_Dialog,_Group,1)
		AND
		NOT DB_TempRequested(_NPC,_,_)
		THEN
		DB_TempRequested(_NPC,_Dialog,_Group);
		
		PROC
		NPCDialogStartRequested((GUIDSTRING)_Npc,(GUIDSTRING)_Player)
		AND
		DB_Internal_Dialogs(_Npc,_Dialog,_Group,_)
		AND
		NOT DB_TempRequested(_NPC,_,_)
		THEN
		DB_TempRequested(_NPC,_Dialog,_Group);
		
		PROC
		NPCDialogStartRequested((GUIDSTRING)_Npc,(GUIDSTRING)_Player)
		AND
		NOT DB_TempRequested(_NPC,_,_)
		AND
		QRY_SpeakerIsAvailable(_Npc)
		AND
		QRY_SpeakerIsAvailable(_Player)
		AND
		ObjectIsCharacter(_Npc,1)
		AND
		HasDefaultDialog((CHARACTERGUID)_Npc,1)
		THEN
		DialogRequestStop(_Npc);
		DialogRequestStop(_Player);
		ProcTryStartDefaultDialog(_Npc,(CHARACTERGUID)_Player);
		
		PROC
		NPCDialogStartRequested((GUIDSTRING)_Npc,(GUIDSTRING)_Player)
		AND
		DB_TempRequested(_NPC,_Dialog,_Group)
		THEN
		NOT DB_TempRequested(_NPC,_Dialog,_Group);
		ProcStartNPCDialog(_Player,_Dialog,_Group);
		
		PROC
		ProcTryStartDefaultDialog((CHARACTERGUID)_Npc,(CHARACTERGUID)_Player)
		AND
		StartDefaultDialog(_Npc,_Player,_Dialog,_Automated)
		THEN
		ProcHandleDefaultDialogSetting(_Npc,_Player,_Dialog,_Automated);
		
		PROC
		ProcHandleDefaultDialogSetting((CHARACTERGUID)_Npc,(CHARACTERGUID)_Player,(STRING)_Dialog,1)
		THEN
		ProcFaceCharacter(_Npc,_Player);
		Proc_DialogFlagSetup(_Dialog,_Npc,_Player);
		
		PROC
		ProcHandleDefaultDialogSetting((CHARACTERGUID)_Npc,(CHARACTERGUID)_Player,(STRING)_Dialog,0)
		THEN
		Proc_DialogFlagSetup(_Dialog,_Npc,_Player);
		ProcFaceCharacter(_Npc,_Player);
		ProcFaceCharacter(_Player,_Npc);
		ProcItemSetInvulnerableForDialog(_Npc);
		ProcItemSetInvulnerableForDialog(_Player);
		CharacterMakeStoryNpc(_Npc,1);
		CharacterMakeStoryNpc(_Player,1);
		DB_HasMetCharactersToCheck(_Npc,_Player);
		
		//END_REGION
		
		//REGION Internal Dialog Cleanup
		PROC
		ProcRemoveAllDialogEntriesForSpeaker((GUIDSTRING)_NPC)
		AND
		DB_Internal_Dialogs(_Npc,_Dialog,_Group,1)
		THEN
		ProcRemoveInternalDialogEntries(_Dialog,_Group);
		ProcRemoveExternalDialogEntry(_Npc,_Dialog,_Group);
		
		PROC
		ProcRemoveDialogEntryForSpeaker((GUIDSTRING)_NPC,(STRING)_Dialog)
		AND
		DB_Internal_Dialogs(_Npc,_Dialog,_Group,1)
		THEN
		ProcRemoveInternalDialogEntries(_Dialog,_Group);
		ProcRemoveExternalDialogEntry(_Npc,_Dialog,_Group);
		
		//remove dialogs when an NPC dies.
		IF
		DB_Dead((CHARACTERGUID)_Npc)
		AND
		NOT DB_KeepDialogsOnDeath(_Npc)
		AND
		DB_Internal_Dialogs(_Npc,_Dialog,_Group,_Nr)
		AND
		DB_Internal_Dialogs(_FirstSpeaker,_Dialog,_Group,1)
		THEN
		ProcRemoveDialogEntryForSpeaker(_FirstSpeaker,_Dialog);
		
		PROC
		ProcRemoveExternalDialogEntry((GUIDSTRING)_Npc,(STRING)_Dialog,(INTEGER)_Group)
		AND
		DB_InternalCounter(_Group,_Dialog,1)
		AND
		DB_Dialogs(_Npc,_Dialog)
		THEN
		NOT DB_Dialogs(_Npc,_Dialog);
		NOT DB_InternalCounter(_Group,_Dialog,1);
		
		PROC
		ProcRemoveExternalDialogEntry((GUIDSTRING)_Npc,(STRING)_Dialog,(INTEGER)_Group)
		AND
		DB_InternalCounter(_Group,_Dialog,2)
		AND
		DB_Dialogs(_Npc,_Npc2,_Dialog)
		THEN
		NOT DB_Dialogs(_Npc,_Npc2,_Dialog);
		NOT DB_InternalCounter(_Group,_Dialog,2);
		
		PROC
		ProcRemoveExternalDialogEntry((GUIDSTRING)_Npc,(STRING)_Dialog,(INTEGER)_Group)
		AND
		DB_InternalCounter(_Group,_Dialog,3)
		AND
		DB_Dialogs(_Npc,_Npc2,_Npc3,_Dialog)
		THEN
		NOT DB_Dialogs(_Npc,_Npc2,_Npc3,_Dialog);
		NOT DB_InternalCounter(_Group,_Dialog,3);
		
		PROC
		ProcRemoveExternalDialogEntry((GUIDSTRING)_Npc,(STRING)_Dialog,(INTEGER)_Group)
		AND
		DB_InternalCounter(_Group,_Dialog,4)
		AND
		DB_Dialogs(_Npc,_Npc2,_Npc3,_Npc4,_Dialog)
		THEN
		NOT DB_Dialogs(_Npc,_Npc2,_Npc3,_Npc4,_Dialog);
		NOT DB_InternalCounter(_Group,_Dialog,4);
		
		PROC
		ProcRemoveInternalDialogEntries((STRING)_Dialog,(INTEGER)_Group)
		AND
		DB_Internal_Dialogs(_Npc,_Dialog,_Group,_Nr)
		THEN
		NOT DB_Internal_Dialogs(_Npc,_Dialog,_Group,_Nr);
		//END_REGION
		
		//REGION Start Dialog with 1 Item 
		IF
		CharacterUsedItem(_Player,_Item)
		AND
		DB_Dialogs(_Item,_Dialog)
		AND
		DB_CombatCharacters(_Player, _)
		AND
		NOT DB_IgnoreCombatItems((ITEMGUID) _Item)
		THEN
		Proc_StartDialog(1,"GLO_AD_CannotUseNow", _Player);
		
		IF
		CharacterUsedItem(_Player,_Item)
		AND
		DB_Dialogs(_Item,_Dialog)
		AND
		NOT DB_CombatCharacters(_Player, _)
		THEN
		Proc_StartDialog(0,_Dialog,_Item,_Player);
		
		IF
		CharacterUsedItem(_Player,_Item)
		AND
		DB_Dialogs(_Item,_Dialog)
		AND
		DB_CombatCharacters(_Player, _)
		AND
		DB_IgnoreCombatItems((ITEMGUID) _Item)
		THEN
		Proc_StartDialog(0,_Dialog,_Item,_Player);
		
		// From item's GEN_ItemDialog behavior script we can start interactive dialogs (used for modders to start item dialogs without Osiris support)
		IF
		CharacterItemEvent(_Player,_Item,"GEN_StartItemDialog")
		AND
		NOT DB_Dialogs(_Item,_)
		AND
		DB_IsPlayer(_Player)
		AND
		NOT DB_CombatCharacters(_Player,_)
		AND
		GetVarString(_Item,"ItemDialog",_Dialog)
		THEN
		Proc_StartDialog(0,_Dialog,_Item,_Player);
		
		IF
		CharacterItemEvent(_Player,_Item,"GEN_StartItemDialog")
		AND
		NOT DB_Dialogs(_Item,_)
		AND
		DB_IsPlayer(_Player)
		AND
		DB_CombatCharacters(_Player,_)
		AND
		DB_IgnoreCombatItems((ITEMGUID)_Item)
		AND
		GetVarString(_Item,"ItemDialog",_Dialog)
		THEN
		Proc_StartDialog(0,_Dialog,_Item,_Player);
		//END_REGION
		
		
		//REGION Start Automated Dialog with 1 Item 
		IF
		CharacterUsedItem(_Char,_Item)
		AND
		DB_AD_Dialog(_Item,_Dialog)
		THEN
		Proc_StartDialog(1,_Dialog, _Item);
		//END_REGION
		
		//REGION Track Object Invulnerable (mainly used by itemdialogs setting items temporarily invulnerable)
		PROC
		ProcSetInvulnerable((GUIDSTRING)_Object,1)
		THEN
		DB_ObjectStoryInvulnerable(_Object);
		SetInvulnerable_UseProcSetInvulnerable(_Object,1);
		
		PROC
		ProcSetInvulnerable((GUIDSTRING)_Object,0)
		THEN
		NOT DB_ObjectStoryInvulnerable(_Object);
		SetInvulnerable_UseProcSetInvulnerable(_Object,0);
		//END_REGION
		
		//REGION Clear Involved NPCs in Dialog
		PROC
		ProcClearDialogFlagsForPlayers((INTEGER)_Instance)
		AND
		DB_DialogPlayers(_Instance,_Player,_Index)
		THEN
		ProcClearPlayerIfNotInOtherDialog(_Instance,_Player);
		
		PROC
		ProcClearPlayerIfNotInOtherDialog((INTEGER)_Inst,(GUIDSTRING)_Player)
		AND
		DB_DialogPlayers(_OtherInstance,_Player,_)
		AND
		_OtherInstance!=_Inst
		AND
		NOT DB_AutomatedDialog(_OtherInstance)
		AND
		NOT DB_MarkedForDelete(_OtherInstance)
		THEN
		DB_TempIsInOtherDialog(_Player,1);
		
		PROC
		ProcClearPlayerIfNotInOtherDialog((INTEGER)_Inst,(GUIDSTRING)_Player)
		AND
		NOT DB_TempIsInOtherDialog(_Player,1)
		THEN
		SetStoryNpcStatus((CHARACTERGUID)_Player);
		
		PROC
		ProcClearPlayerIfNotInOtherDialog((INTEGER)_Inst,(GUIDSTRING)_Player)
		THEN
		NOT DB_TempIsInOtherDialog(_Player,1);
		
		PROC
		ProcClearDialogFlagsForNPCs((INTEGER)_Instance)
		AND
		DB_DialogNPCs(_Instance,_Npc,_Index)
		THEN
		ProcClearNPCIfNotInOtherDialog(_Instance,_Npc);
		
		PROC
		ProcClearNPCIfNotInOtherDialog((INTEGER)_Inst,(GUIDSTRING)_Npc)
		AND
		DB_DialogNPCs(_OtherInstance,_Npc,_)
		AND
		_OtherInstance!=_Inst
		AND
		NOT DB_AutomatedDialog(_OtherInstance)
		AND
		NOT DB_MarkedForDelete(_OtherInstance)
		THEN
		DB_TempIsInOtherDialog(_Npc,1);
		
		PROC
		ProcClearNPCIfNotInOtherDialog((INTEGER)_Inst,(GUIDSTRING)_Npc)
		AND
		NOT DB_TempIsInOtherDialog(_Npc,1)
		THEN
		SetStoryNpcStatus((CHARACTERGUID)_Npc);
		
		PROC
		ProcClearNPCIfNotInOtherDialog((INTEGER)_Inst,(GUIDSTRING)_Npc)
		AND
		NOT DB_TempIsInOtherDialog(_Npc,1)
		AND
		NOT DB_ObjectStoryInvulnerable(_Npc)
		AND
		ObjectIsItem(_Npc,1)
		THEN
		SetInvulnerable_UseProcSetInvulnerable(_Npc,0);
		
		PROC
		ProcClearNPCIfNotInOtherDialog((INTEGER)_Inst,(GUIDSTRING)_Npc)
		THEN
		NOT DB_TempIsInOtherDialog(_Npc,1);
		
		//END_REGION
		
		//REGION Set Relation to Players
		PROC
		SetRelationFactionToPlayers((STRING)_Faction,(INTEGER)_Relation)
		THEN
		CharacterSetRelationFactionToFaction(_Faction,"Hero",_Relation);
		CharacterSetRelationFactionToFaction("Hero",_Faction,_Relation);
		CharacterSetRelationFactionToFaction(_Faction,"Companion",_Relation);
		CharacterSetRelationFactionToFaction("Companion",_Faction,_Relation);
		
		PROC
		SetRelationIndivFactionToPlayers((CHARACTERGUID)_Char,(INTEGER)_Relation)
		THEN
		CharacterSetRelationIndivFactionToFaction(_Char,"Hero",_Relation);
		CharacterSetRelationFactionToIndivFaction("Hero",_Char,_Relation);
		CharacterSetRelationIndivFactionToFaction(_Char,"Companion",_Relation);
		CharacterSetRelationFactionToIndivFaction("Companion",_Char,_Relation);
		
		PROC
		ProcSetRelationToPlayers((CHARACTERGUID)_Character,(INTEGER)_Relation)
		AND
		_Relation == 0
		AND
		GetFaction(_Character,_Faction)
		THEN
		SetFaction(_Character,"Evil NPC");
		DB_PreviousAlignment(_Character,_Faction);
		
		PROC
		ProcSetRelationToPlayers((CHARACTERGUID)_Character,(INTEGER)_Relation)
		AND
		_Relation == 100
		AND
		NOT DB_PreviousAlignment(_Character,_)
		AND
		GetFaction(_Character,_Faction)
		THEN
		CharacterSetRelationFactionToFaction(_Faction,"Hero",100);
		CharacterSetRelationFactionToFaction("Hero",_Faction,100);
		
		PROC
		ProcSetRelationToPlayers((CHARACTERGUID)_Character,(INTEGER)_Relation)
		AND
		DB_IsPlayer(_Player)
		AND
		_Relation == 100
		AND
		DB_PreviousAlignment(_Character,_Faction)
		THEN
		SetFaction(_Character,_Faction);
		CharacterSetRelationFactionToFaction(_Faction,"Hero",100);
		CharacterSetRelationFactionToFaction("Hero",_Faction,100);
		NOT DB_PreviousAlignment(_Character,_Faction);
		
		PROC
		ProcSetHostileToIndivPlayer((CHARACTERGUID)_Character,(CHARACTERGUID)_Player)
		THEN
		CharacterSetRelationIndivFactionToIndivFaction(_Character,_Player,0);
		CharacterSetRelationIndivFactionToIndivFaction(_Player,_Character,0);
		
		PROC
		ProcSetFactionHostileToIndivPlayer((STRING)_Faction,(CHARACTERGUID)_Player)
		THEN
		CharacterSetRelationFactionToIndivFaction(_Faction,_Player,0);
		CharacterSetRelationIndivFactionToFaction(_Player,_Faction,0);
		//END_REGION
		
		//REGION Change Attitude
		IF
		ObjectFlagSet("ChangeAttitude",_Player,_Instance)
		AND
		GetVarInteger(_Player,"ChangeAttitude",_Value)
		AND
		DB_DialogNPCs(_Instance,_Npc,1)
		THEN
		ObjectClearFlag(_Player,"ChangeAttitude",_Instance);
		CharacterAddAttitudeTowardsPlayer((CHARACTERGUID)_Npc,(CHARACTERGUID)_Player,_Value);
		
		PROC
		ChangeAttitude((CHARACTERGUID)_NPC,(CHARACTERGUID)_Player,(INTEGER)_Value)
		THEN
		CharacterAddAttitudeTowardsPlayer(_Npc,_Player,_Value);
		//END_REGION
		
		//REGION Peace Timer
		PROC
		PROC_PeaceTimerLaunch((STRING)_TimerName,(INTEGER)_TimerLength)
		AND
		DB_CombatCharacters(_Player,_)
		AND
		DB_IsPlayer(_Player)
		AND
		NOT DB_PeaceTimer(_TimerName)
		THEN
		DB_PeaceTimer(_TimerName);
		DB_PeaceTimerStillToStart(_TimerName,_TimerLength);
		
		PROC
		PROC_PeaceTimerLaunch((STRING)_TimerName,(INTEGER)_TimerLength)
		AND
		NOT DB_PeaceTimer(_TimerName)
		THEN
		DB_PeaceTimer(_TimerName);
		TimerLaunch(_TimerName,_TimerLength);
		
		IF
		ObjectEnteredCombat((CHARACTERGUID)_Player,_)
		AND
		_Player.DB_IsPlayer()
		AND
		DB_PeaceTimer(_TimerName)
		THEN
		TimerPause(_TimerName);
		
		IF
		ObjectLeftCombat((CHARACTERGUID)_Player,_)
		AND
		_Player.DB_IsPlayer()
		AND
		DB_PeaceTimer(_TimerName)
		THEN
		ProcUnPausePeaceTimerIfNoPlayerInCombat(_TimerName);
		
		PROC
		ProcUnPausePeaceTimerIfNoPlayerInCombat((STRING)_TimerName)
		AND
		_Player.DB_IsPlayer()
		AND
		DB_CombatCharacters(_Player,_)
		THEN
		DB_PlayerInCombat(1);
		
		PROC
		ProcUnPausePeaceTimerIfNoPlayerInCombat((STRING)_TimerName)
		AND
		NOT DB_PlayerInCombat(1)
		AND
		NOT DB_PeaceTimerStillToStart(_TimerName,_)
		THEN
		TimerUnpause(_TimerName);
		
		PROC
		ProcUnPausePeaceTimerIfNoPlayerInCombat((STRING)_TimerName)
		AND
		NOT DB_PlayerInCombat(1)
		AND
		DB_PeaceTimerStillToStart(_TimerName,_TimerLength)
		THEN
		TimerLaunch(_TimerName,_TimerLength);
		NOT DB_PeaceTimerStillToStart(_TimerName,_TimerLength);
		
		PROC
		ProcUnPausePeaceTimerIfNoPlayerInCombat((STRING)_TimerName)
		THEN
		NOT DB_PlayerInCombat(1);
		IF
		TimerFinished(_TimerName)
		AND
		DB_PeaceTimer(_TimerName)
		THEN
		NOT DB_PeaceTimer(_TimerName);
		//END_REGION
		
		//REGION Doors
		PROC
		ItemCloseAndLock((ITEMGUID)_Item,(STRING)_Key)
		THEN
		ItemClose(_Item);
		ItemLock(_Item,_Key);
		
		PROC
		ItemUnlockAndOpen((ITEMGUID)_Item)
		THEN
		ItemUnLock(_Item);
		ItemOpen(_Item);
		//END_REGION
		
		//REGION  Automated dialogs
		IF
		DB_AD_Dialog((GUIDSTRING)_Char,(STRING)_)
		THEN
		SetHasDialog(_Char,1);
		
		IF
		DB_AD_Dialog((GUIDSTRING)_Char1,(GUIDSTRING)_Char2,(STRING)_)
		THEN
		SetHasDialog(_Char1,1);
		SetHasDialog(_Char2,1);
		
		PROC
		PROC_GLOBAL_DialogStartRequested((GUIDSTRING)_Char,(GUIDSTRING)_Player)
		AND
		DB_AD_Dialog(_Char,(STRING)_Dialog)
		AND
		NOT DB_ADRequested(_Char)
		AND
		QRY_StartDialog(1,_Dialog,_Char)
		THEN
		DB_ADRequested(_Char);
		DB_FoundDialog(_Char,_Player);
		
		PROC
		PROC_GLOBAL_DialogStartRequested((GUIDSTRING)_Char1,(GUIDSTRING)_Player)
		AND
		DB_AD_Dialog(_Char1,_Char2,(STRING)_Dialog)
		AND
		NOT DB_ADRequested(_Char1)
		AND
		NOT DB_ADRequested(_Char2)
		AND
		QRY_StartDialog(1,_Dialog,_Char1,_Char2)
		THEN
		DB_ADRequested(_Char1);
		DB_ADRequested(_Char2);
		DB_FoundDialog(_Char1,_Player);
		
		PROC
		PROC_GLOBAL_DialogStartRequested((GUIDSTRING)_Char2,(GUIDSTRING)_Player)
		AND
		DB_AD_Dialog(_Char1,_Char2,(STRING)_Dialog)
		AND
		NOT DB_ADRequested(_Char1)
		AND
		NOT DB_ADRequested(_Char2)
		AND
		QRY_StartDialog(1,_Dialog,_Char1,_Char2)
		THEN
		DB_ADRequested(_Char1);
		DB_ADRequested(_Char2);
		DB_FoundDialog(_Char2,_Player);
		
		IF
		AutomatedDialogEnded(_Dialog,_Inst)
		THEN
		ProcClearADRequests(_Dialog,_Inst);
		
		IF
		AutomatedDialogRequestFailed(_Dialog,_Inst)
		THEN
		ProcClearADRequests(_Dialog,_Inst);
		
		PROC
		ProcClearADRequests((STRING)_Dialog,(INTEGER)_Inst)
		AND
		DB_DialogNPCs(_Inst,_Npc,1)
		AND
		DB_AD_Dialog(_Npc,_Dialog)
		THEN
		NOT DB_ADRequested(_Npc);
		
		PROC
		ProcClearADRequests((STRING)_Dialog,(INTEGER)_Inst)
		AND
		DB_DialogPlayers(_Inst,_Player,1)
		AND
		DB_AD_Dialog(_Player,_Dialog)
		THEN
		NOT DB_ADRequested(_Player);
		
		PROC
		ProcClearADRequests((STRING)_Dialog,(INTEGER)_Inst)
		AND
		DB_DialogNPCs(_Inst,_Npc,_)
		AND
		DB_AD_Dialog(_,_,_Dialog)
		THEN
		NOT DB_ADRequested(_Npc);
		
		PROC
		ProcClearADRequests((STRING)_Dialog,(INTEGER)_Inst)
		AND
		DB_DialogPlayers(_Inst,_Player,1)
		AND
		DB_AD_Dialog(_,_,_Dialog)
		THEN
		NOT DB_ADRequested(_Player);
		
		PROC
		ProcRemoveNPCADs((GUIDSTRING)_Npc)
		AND
		DB_AD_Dialog(_Npc,_Dialog)
		THEN
		NOT DB_AD_Dialog(_Npc,_Dialog);
		NOT DB_ADRequested(_Npc);
		
		PROC
		ProcRemoveNPCADs((GUIDSTRING)_Npc)
		AND
		DB_AD_Dialog(_Npc,_Npc2,_Dialog)
		THEN
		NOT DB_AD_Dialog(_Npc,_Npc2,_Dialog);
		NOT DB_ADRequested(_Npc);
		NOT DB_ADRequested(_Npc2);
		
		PROC
		ProcRemoveNPCADs((GUIDSTRING)_Npc2)
		AND
		DB_AD_Dialog(_Npc,_Npc2,_Dialog)
		THEN
		NOT DB_AD_Dialog(_Npc,_Npc2,_Dialog);
		NOT DB_ADRequested(_Npc);
		NOT DB_ADRequested(_Npc2);
		
		PROC
		PROC_GLOBAL_DialogStartRequested((GUIDSTRING)_NPC,(GUIDSTRING)_Player)
		AND
		DB_AD_Dialog(_NPC,_)
		THEN
		ProcFaceEachother(_NPC,_Player);
		
		//END_REGION
		
		//REGION Object timer
		PROC
		ProcObjectTimer((GUIDSTRING)_Object,(STRING)_TimerName,(INTEGER)_Time)
		AND
		GetUUID(_Object,_UUID)
		AND
		StringConcatenate(_UUID,_TimerName,_ObjectTimerName)
		THEN
		DB_ObjectTimer(_Object,_ObjectTimerName,_TimerName);
		TimerLaunch(_ObjectTimerName,_Time);
		
		PROC
		ProcObjectTimerCancel((GUIDSTRING)_Object,(STRING)_TimerName)
		AND
		DB_ObjectTimer(_Object,_ObjectTimerName,_TimerName)
		THEN
		NOT DB_ObjectTimer(_Object,_ObjectTimerName,_TimerName);
		TimerCancel(_ObjectTimerName);
		
		IF
		TimerFinished(_ObjectTimerName)
		AND
		DB_ObjectTimer(_Object,_ObjectTimerName,_TimerName)
		THEN
		NOT DB_ObjectTimer(_Object,_ObjectTimerName,_TimerName);
		ProcObjectTimerFinished(_Object,_TimerName);
		
		PROC
		ProcObjectTimerFinished((GUIDSTRING)_Object,(STRING)_TimerName)
		THEN
		DB_NOOP(1);
		//END_REGION
		
		//REGION Tutorial Messages
		PROC
		PROC_CheckPlayTut((STRING)_Message)
		AND
		_Player.DB_IsPlayer()
		THEN
		PROC_CheckPlayTut(_Player,_Message);
		
		PROC
		PROC_CheckPlayTut((CHARACTERGUID)_Player,(STRING)_Message)
		AND
		DB_StartTutMessages(1)
		THEN
		ProcPlayTut(_Player,_Message);
		
		PROC
		PROC_CheckPlayTutWithDelay((STRING)_Message,(INTEGER)_Delay)
		AND
		_Player.DB_IsPlayer()
		THEN
		PROC_CheckPlayTutWithDelay(_Player,_Message,_Delay);
		
		PROC
		PROC_CheckPlayTutWithDelay((CHARACTERGUID)_Player,(STRING)_Message,(INTEGER)_Delay)
		AND
		NOT DB_TutorialMessage(_Player,_Message,_)
		AND
		GetUUID(_Player,_Timer)
		AND
		StringConcatenate(_Timer,"_Tut",_TimerMsg)
		THEN
		TimerLaunch(_TimerMsg,_Delay);
		DB_TutorialMessage(_Player,_Message,_TimerMsg);
		
		IF
		TimerFinished(_TimerMsg)
		AND
		DB_StartTutMessages(1)
		AND
		DB_TutorialMessage(_Player,_Message,_TimerMsg)
		THEN
		NOT DB_TutorialMessage(_Player,_Message,_TimerMsg);
		ProcPlayTut(_Player,_Message);
		//END_REGION
		
		//REGION Move to changes 
		PROC
		ProcSaveGenericBehaviourState((CHARACTERGUID)_Char)
		AND
		NOT DB_StoryMoving(_Char,1)
		AND
		DB_Internal_Dialogs(_Char,_,_,_)
		THEN
		DB_NPCHadDialog(_Char,1);
		
		PROC
		ProcSaveGenericBehaviourState((CHARACTERGUID)_Char)
		AND
		NOT DB_StoryMoving(_Char,1)
		AND
		DB_AD_Dialog(_Char,_)
		THEN
		DB_NPCHadDialog(_Char,1);
		
		PROC
		ProcInternalMoveDisableGenericBehaviours((CHARACTERGUID)_Char)
		AND
		NOT DB_AD_Dialog(_Char,_)
		THEN
		SetHasDialog(_Char,0);
		
		PROC
		ProcInternalMoveDisableGenericBehaviours((CHARACTERGUID)_Char)
		THEN
		CharacterDisableAllCrimes(_Char);
		
		PROC
		ProcRestoreGenericBehaviour((CHARACTERGUID)_Char)
		AND
		NOT DB_CharacterAllCrimesDisabled(_Char)
		THEN
		CharacterEnableAllCrimes(_Char);
		
		PROC
		ProcRestoreGenericBehaviour((CHARACTERGUID)_Char)
		AND
		DB_CharacterCrimeDisabled(_Char,_Crime)
		THEN
		CharacterDisableCrime(_Char,_Crime);
		
		PROC
		ProcRestoreGenericBehaviour((CHARACTERGUID)_Char)
		AND
		DB_CharacterCrimeEnabled(_Char,_Crime)
		THEN
		CharacterEnableCrime(_Char,_Crime);
		
		PROC
		ProcRestoreGenericBehaviour((CHARACTERGUID)_Char)
		AND
		DB_NPCHadDialog(_Char,1)
		THEN
		NOT DB_NPCHadDialog(_Char,1);
		SetHasDialog(_Char,1);
		
		PROC
		ProcSetMoveEvent((STRING)_Event)
		AND
		_Event!=""
		THEN
		DB_MoveEvent(_Event);
		
		PROC
		ProcSetMoveEvent("")
		THEN
		DB_MoveEvent("_ResetGenericBehaviours_");
		
		PROC
		ProcExecuteMove((CHARACTERGUID)_Char,(GUIDSTRING)_Point,(INTEGER)_Running)
		AND
		DB_MoveEvent(_Event)
		AND
		DB_CharMovementCommandID(_Char,_ID)
		THEN
		NOT DB_MoveEvent(_Event);
		CharacterMoveTo(_Char,_Point,_Running,_Event,0);
		DB_CharacterMovement(_Char,_Event,_ID);
		
		PROC
		ProcBumpOsirisMoveCommandID((CHARACTERGUID)_Char)
		AND
		NOT DB_CharMovementCommandID(_Char,_)
		THEN
		DB_CharMovementCommandID(_Char,0);
		
		PROC
		ProcBumpOsirisMoveCommandID((CHARACTERGUID)_Char)
		AND
		DB_CharMovementCommandID(_Char,_ID)
		AND
		IntegerSum(1,_ID,_New)
		THEN
		NOT DB_CharMovementCommandID(_Char,_ID);
		DB_CharMovementCommandID(_Char,_New);
		
		PROC
		ProcCharacterMoveTo((CHARACTERGUID)_Char,_,_,_)
		THEN
		SetStoryEvent(_Char,"ClearCrimeReturnPos");
		ProcBumpOsirisMoveCommandID(_Char);
		
		PROC
		ProcCharacterMoveTo((CHARACTERGUID)_Char,(GUIDSTRING)_Point,(INTEGER)_Running,(STRING)_Event)
		AND
		DB_CharMovementCommandID(_Char,_ID)
		THEN
		ProcSaveGenericBehaviourState(_Char);
		ProcInternalMoveDisableGenericBehaviours(_Char);
		ProcSetMoveEvent(_Event);
		ProcExecuteMove(_Char,_Point,_Running);
		DB_StoryMoving(_Char,1);
		DB_MovingTo(_Char,_Point,_Running,_ID);
		
		PROC
		ProcCharacterMoveTo((CHARACTERGUID)_Char,_,_,_)
		THEN
		ProcBumpOsirisMoveCommandID(_Char);
		
		PROC
		ProcResumeStoryMoving((CHARACTERGUID)_Char)
		AND
		DB_CharacterMovement(_Char,_Event,_ID)
		AND
		NOT DB_SelectedMove(_Char)
		THEN
		ProcSelectMove(_Char,_ID);
		
		PROC
		ProcSelectMove((CHARACTERGUID)_Char,(INTEGER)_ID)
		AND
		DB_MovingTo(_Char,_Point,_Running,_ID)
		AND
		DB_CharacterMovement(_Char,_Event,_ID)
		THEN
		DB_SelectedMove(_Char);
		CharacterMoveTo(_Char,_Point,_Running,_Event,0);
		
		PROC
		ProcResumeStoryMoving((CHARACTERGUID)_Char)
		THEN
		NOT DB_SelectedMove(_Char);
		
		PROC
		ProcClearMovingFacts((CHARACTERGUID)_Char)
		AND
		DB_CharacterMovement(_Char,_Event,_ID)
		THEN
		NOT DB_CharacterMovement(_Char,_Event,_ID);
		
		PROC
		ProcClearMovingFacts((CHARACTERGUID)_Char)
		AND
		DB_MovingTo(_Char,_Point,_Running,_ID)
		THEN
		NOT DB_MovingTo(_Char,_Point,_Running,_ID);
		
		PROC
		ProcClearMovingFacts((CHARACTERGUID)_Char)
		THEN
		ProcRestoreGenericBehaviour(_Char);
		
		IF
		StoryEvent((CHARACTERGUID)_Char,_Event)
		AND
		DB_CharacterMovement(_Char,_Event,_ID)
		THEN
		NOT DB_ClearedMoveEvent(_Char);
		
		IF
		StoryEvent((CHARACTERGUID)_Char,_Event)
		AND
		DB_CharacterMovement(_Char,_Event,_ID)
		AND
		DB_MovingTo(_Char,_Point,_Running,_ID)
		AND
		NOT DB_ClearedMoveEvent(_Char)
		THEN
		DB_ClearedMoveEvent(_Char);
		NOT DB_MovingTo(_Char,_Point,_Running,_ID);
		
		IF
		StoryEvent((CHARACTERGUID)_Char,_Event)
		AND
		DB_CharacterMovement(_Char,_Event,_ID)
		THEN
		NOT DB_HandledMoveEvent(_Char);
		
		IF
		StoryEvent((CHARACTERGUID)_Char,_Event)
		AND
		DB_CharacterMovement(_Char,_Event,_ID)
		AND
		NOT DB_HandledMoveEvent(_Char)
		THEN
		DB_HandledMoveEvent(_Char);
		NOT DB_CharacterMovement(_Char,_Event,_ID);
		SetStoryEvent(_Char,"ClearCrimeReturnPos");
		ProcCheckRestoreGenericBehaviours(_Char);
		
		
		PROC
		ProcCheckRestoreGenericBehaviours((CHARACTERGUID)_Char)
		AND
		NOT DB_CharacterMovement(_Char,_,_)
		THEN
		NOT DB_StoryMoving(_Char,1);
		ProcRestoreGenericBehaviour(_Char);
		
		IF
		AttackedByObject((CHARACTERGUID)_Char,(CHARACTERGUID)_SourceOwner,(CHARACTERGUID)_Source,_,_DamageSource)
		AND
		_Char != _Source
		AND
		DB_StoryMoving(_Char,1)
		AND
		NOT DB_CombatCharacters(_Char,_)
		AND
		NOT QryIgnoreDamageSource(_DamageSource)
		AND
		CharacterIsPlayer(_Source,1)
		THEN
		ProcMakeNPCHostile(_Source,_Char);
		
		IF
		DB_Dead(_Char)
		AND
		DB_StoryMoving(_Char,1)
		THEN
		ProcClearStoryMove(_Char);
		
		IF
		CharacterWentOnStage(_Char,0)
		AND
		DB_StoryMoving(_Char,1)
		THEN
		ProcClearStoryMove(_Char);
		
		IF
		ObjectEnteredCombat((CHARACTERGUID)_Char,_)
		AND
		DB_StoryMoving(_Char,1)
		THEN
		CharacterPurgeQueue(_Char);
		
		IF
		ObjectLeftCombat((CHARACTERGUID)_Char,_)
		AND
		NOT DB_Dead(_Char)
		AND
		DB_StoryMoving(_Char,1)
		THEN
		ProcResumeStoryMoving(_Char);
		
		PROC
		ProcClearStoryMove((CHARACTERGUID)_Char)
		THEN
		NOT DB_StoryMoving(_Char,1);
		ProcClearMovingFacts(_Char);
		CharacterPurgeQueue(_Char);
		//END_REGION
		
		//REGION Movement via State_Manager_GoTo
		// The parameters are roughly the same as with ProcCharacterMoveTo. Additional parameters:
		//  - _MinDist: the minimal distance to which the character must have neared its destination before the event is triggered
		//  - _AfterArrivalState: the State_Manager state to go to once the character reaches its destination
		PROC
		ProcStateManagerCharacterMoveTo((CHARACTERGUID)_Char,(GUIDSTRING)_Destination,(INTEGER)_Running,(REAL)_MinDist,(STRING)_Event,(STRING)_AfterArrivalState)
		AND
		ObjectIsCharacter(_Destination,1)
		THEN
		DB_ProcStateManagerCharacterMoveTo_Handled(1);
		SetVarObject(_Char,"DestinationCharacter",_Destination);
		SetVarFixedString(_Char,"currentState","State_Manager_Go_To_Character");
		
		PROC
		ProcStateManagerCharacterMoveTo((CHARACTERGUID)_Char,(GUIDSTRING)_Destination,(INTEGER)_Running,(REAL)_MinDist,(STRING)_Event,(STRING)_AfterArrivalState)
		AND
		NOT DB_ProcStateManagerCharacterMoveTo_Handled(1)
		AND
		ObjectIsItem(_Destination,1)
		THEN
		DB_ProcStateManagerCharacterMoveTo_Handled(1);
		SetVarObject(_Char,"DestinationItem",_Destination);
		SetVarFixedString(_Char,"currentState","State_Manager_Go_To_Item");
		
		PROC
		ProcStateManagerCharacterMoveTo((CHARACTERGUID)_Char,(GUIDSTRING)_Destination,(INTEGER)_Running,(REAL)_MinDist,(STRING)_Event,(STRING)_AfterArrivalState)
		AND
		NOT DB_ProcStateManagerCharacterMoveTo_Handled(1)
		THEN
		SetVarObject(_Char,"Destination",_Destination);
		SetVarFixedString(_Char,"currentState","State_Manager_Go_To_Trigger");
		
		PROC
		ProcStateManagerCharacterMoveTo((CHARACTERGUID)_Char,(GUIDSTRING)_Destination,(INTEGER)_Running,(REAL)_MinDist,(STRING)_Event,(STRING)_AfterArrivalState)
		THEN
		NOT DB_ProcStateManagerCharacterMoveTo_Handled(1);
		SetVarInteger(_Char,"Running",_Running);
		SetVarFloat(_Char,"Distance",_MinDist);
		SetVarString(_Char,"ArriveEvent",_Event);
		SetVarFixedString(_Char,"AfterArriveState",_AfterArrivalState);
		//END_REGION
		
		PROC 
		ReactOnKillCounter((STRING)_Counter)
		THEN 
		DB_NOOP(1);
		
		PROC
		ProcStartMovie((STRING)_Movie)
		AND
		_Char.DB_IsPlayer()
		AND
		CharacterGetReservedUserID(_Char,_ID)
		AND
		GetUserProfileID(_ID,_UserProfile)
		AND
		NOT DB_MoviePlayed(_UserProfile,_Movie)
		THEN
		DB_MoviePlayed(_UserProfile,_Movie);
		MoviePlay(_Char,_Movie);
		
		
		//REGION check closest available character to object
		QRY
		QRY_GetClosestAvailableCharacterTo((CHARACTERGUID)_Obj,(INTEGER)_SightCheck)
		AND
		QRY_GetClosestAvailableCharacterTo((CHARACTERGUID)_Obj,(INTEGER)_SightCheck,0,NULL_00000000-0000-0000-0000-000000000000)
		THEN
		DB_NoOp(1);
		
		QRY
		QRY_GetClosestAvailableCharacterTo((CHARACTERGUID)_Obj,(INTEGER)_SightCheck,(INTEGER)_PartyCheck,(CHARACTERGUID)_Player)
		AND
		QRY_GetClosestAvailableCharacterTo((CHARACTERGUID)_Obj,(INTEGER)_SightCheck,(INTEGER)_PartyCheck,(CHARACTERGUID)_Player,(CHARACTERGUID)NULL_00000000-0000-0000-0000-000000000000)
		THEN
		DB_NoOp(1);
		
		QRY
		QRY_GetClosestAvailableCharacterTo((CHARACTERGUID)_Obj,(INTEGER)_SightCheck,(INTEGER)_PartyCheck,(CHARACTERGUID)_Player,(CHARACTERGUID)_ExceptPlayer)
		AND 
		QRY_GetClosestAvailableCharacterTo_ClearFacts(_Obj)
		AND
		DB_IsPlayer(_Char)
		AND
		_Char != _ExceptPlayer
		AND
		QRY_Conditional_CharacterCanSee(_SightCheck,_Obj,(CHARACTERGUID)_Char)
		AND
		QRY_SpeakerIsAvailable(_Char)
		AND
		QRY_Conditional_CharacterIsInPartyWith(_PartyCheck,_Char,_Player)
		AND
		GetDistanceTo(_Char,_Obj,_Dist)
		THEN
		DB_ClosestAvailableCharacterTo(_Char,_Obj,_Dist);
		
		//Helper functions
		QRY
		QRY_GetClosestAvailableCharacterTo_ClearFacts((CHARACTERGUID)_Obj)
		THEN
		PROC_GetClosestAvailableCharacterTo_ClearFacts(_Obj);
		
		PROC
		PROC_GetClosestAvailableCharacterTo_ClearFacts((CHARACTERGUID)_Obj)
		AND
		DB_ClosestAvailableCharacterTo(_Char,_Obj,_Dist)
		THEN
		NOT DB_ClosestAvailableCharacterTo(_Char,_Obj,_Dist);
		
		IF
		DB_ClosestAvailableCharacterTo(_Char1,_Obj,_Dist1)
		AND
		DB_ClosestAvailableCharacterTo(_Char2,_Obj,_Dist2)
		AND
		_Char1 != _Char2
		AND
		_Dist1 <= _Dist2
		THEN
		NOT DB_ClosestAvailableCharacterTo(_Char2,_Obj,_Dist2);
		//END_REGION
		
		//REGION Conditional Party/Sight checks
		QRY
		QRY_Conditional_CharacterCanSee(0,(CHARACTERGUID)_Obj,(CHARACTERGUID)_Char)
		THEN
		DB_NoOp(1);
		
		QRY
		QRY_Conditional_CharacterCanSee(1,(CHARACTERGUID)_Obj,(CHARACTERGUID)_Char)
		AND
		CharacterCanSee(_Obj,_Char,1)
		THEN
		DB_NoOp(1);
		
		QRY
		QRY_Conditional_CharacterIsInPartyWith(0,(CHARACTERGUID)_Obj,(CHARACTERGUID)_Char)
		THEN
		DB_NoOp(1);
		
		QRY
		QRY_Conditional_CharacterIsInPartyWith(1,(CHARACTERGUID)_Obj,(CHARACTERGUID)_Char)
		AND
		CharacterIsInPartyWith(_Obj,_Char,1)
		THEN
		DB_NoOp(1);
		//END_REGION
		
		//REGION Disappear out of sight
		
		PROC
		ProcCharacterDisappearOutOfSight((CHARACTERGUID)_Character,(INTEGER)_Angle,(INTEGER)_Running,(STRING)_Event,(INTEGER)_IncreaseSpeed)
		THEN
		CharacterDisableAllCrimes(_Character);
		DB_CharacterDisappearedOutOfSight(_Character,_Event,1);
		CharacterDisappearOutOfSight(_Character,_Angle,_Running,_Event,_IncreaseSpeed);
		
		PROC
		ProcCharacterDisappearOutOfSightToObject((CHARACTERGUID)_Character,(GUIDSTRING)_Object,(INTEGER)_Running,(STRING)_Event,(INTEGER)_IncreaseSpeed)
		THEN
		CharacterDisableAllCrimes(_Character);
		DB_CharacterDisappearedOutOfSight(_Character,_Event,1);
		CharacterDisappearOutOfSightToObject(_Character,_Object,_Running,_Event,_IncreaseSpeed);
		
		QRY
		QryCanSeeAttackers((CHARACTERGUID)_Char,(CHARACTERGUID)_Src,(CHARACTERGUID)_SrcSummon)
		AND
		_SrcSummon != NULL_00000000-0000-0000-0000-000000000000
		AND
		_SrcSummon != _Src
		AND
		CharacterCanSee(_Char,_SrcSummon,1)
		THEN
		DB_SawAttacker(_SrcSummon);
		
		QRY
		QryCanSeeAttackers((CHARACTERGUID)_Char,(CHARACTERGUID)_Src,(CHARACTERGUID)_SrcSummon)
		AND
		NOT DB_SawAttacker(_)
		AND
		CharacterCanSee(_Char,_Src,1)
		THEN
		DB_SawAttacker(_Src);
		
		IF
		AttackedByObject((CHARACTERGUID)_Char,(CHARACTERGUID)_Src,_SrcSummon,_,_)
		AND
		_SrcSummon != _Char
		AND
		ObjectIsOnStage(_Char,1)
		AND
		DB_CharacterDisappearedOutOfSight(_Char,_,1)
		AND
		IsTagged(_Char,"ANIMAL",0)
		AND
		CharacterCanFight(_Char,1)
		AND
		ObjectIsCharacter(_Src,1)
		AND
		QryCanSeeAttackers(_Char,_Src,_SrcSummon)
		AND
		DB_SawAttacker(_Target)
		THEN
		DB_StoppedOutOfSight(_Char);
		CharacterPurgeQueue(_Char);
		CharacterSetTemporaryHostileRelation(_Char,_Target);
		NOT DB_SawAttacker(_Target);
		
		IF
		CharacterSetTemporaryRelationsFailed(_Char,_Target)
		AND
		DB_StoppedOutOfSight(_Char)
		THEN
		ProcResumeDisappearOutOfSight(_Char);
		
		IF
		ObjectLeftCombat((CHARACTERGUID)_Char,_)
		AND
		DB_StoppedOutOfSight(_Char)
		THEN
		ProcResumeDisappearOutOfSight(_Char);
		
		PROC
		ProcResumeDisappearOutOfSight((CHARACTERGUID)_Char)
		AND
		NOT DB_Dead(_Char)
		AND
		DB_CharacterDisappearedOutOfSight(_Char,_Event,1)
		THEN
		NOT DB_StoppedOutOfSight(_Char);
		CharacterDisappearOutOfSight(_Char,0,1,_Event,1);
		
		IF
		CharacterWentOnStage(_Character,1)
		AND
		DB_CharacterDisappearedOutOfSight(_Character,_Event,_ReactToCombat)
		THEN
		NOT DB_CharacterDisappearedOutOfSight(_Character,_Event,_ReactToCombat);
		ProcRestoreGenericBehaviour(_Character);
		
		IF
		StoryEvent((CHARACTERGUID)_Character,"GEN_CharacterDisableAllCrimesBeforeDisappear")
		THEN
		CharacterDisableAllCrimes(_Character);
		DB_CharacterDisappearedOutOfSight(_Character,"",0);
		
		IF
		StoryEvent((CHARACTERGUID)_Character,"GEN_CharacterDisableAllCrimesBeforeDisappear_ReactToCombat")
		THEN
		CharacterDisableAllCrimes(_Character);
		DB_CharacterDisappearedOutOfSight(_Character,"",1);
		
		PROC
		ProcClearDisappearData((CHARACTERGUID)_Character)
		AND
		DB_CharacterDisappearedOutOfSight(_Character,_Event,_ReactToCombat)
		THEN
		NOT DB_CharacterDisappearedOutOfSight(_Character,_Event,_ReactToCombat);
		
		//END_REGION
		
		//REGION TemporaryHostileRelation
		PROC
		Proc_CharacterSetTemporaryHostileRelation((CHARACTERGUID)_Char1,(CHARACTERGUID)_Char2)
		AND
		_Char2!= NULL_00000000-0000-0000-0000-000000000000
		AND
		_Char1!= NULL_00000000-0000-0000-0000-000000000000
		THEN
		CharacterSetTemporaryHostileRelation(_Char1,_Char2);
		//END_REGION
		
		IF
		RegionEnded(_Region)
		THEN
		ProcRegionEnded(_Region);
		
		PROC
		ProcRegionEnded((STRING)_Region)
		THEN
		DB_NOOP(1);
		
		//REGION Healing status query
		QRY
		QRY_IsHealingStatus((STRING)_Status)
		AND
		_Status != "HEAL" //DOSTWO-24618 The actual HEAL status is a tick that is set from different statusses (that possibly doesn't heal because it has its parameters overwritten). It's never set on its own.
		AND
		GetStatusType(_Status,"HEAL")
		AND
		GetHealStat(_Status,"Vitality")
		THEN
		DB_NOOP(1);
		
		QRY
		QRY_IsHealingStatus((STRING)_Status)
		AND
		GetStatusType(_Status,"HEALING")
		AND
		GetHealStat(_Status,"Vitality")
		THEN
		DB_NOOP(1);
		//END_REGION
		
		//REGION item moving defaults
		PROC
		ItemMoveToTrigger((ITEMGUID)_Item,(TRIGGERGUID)_Trigger, (REAL)_Speed, (REAL)_Acceleration, (INTEGER)_UseRotation, (STRING)_Event)
		THEN
		ItemMoveToTrigger(_Item,_Trigger,_Speed,_Acceleration,_UseRotation,_Event,1);
		
		PROC
		ItemMoveToTrigger((ITEMGUID)_Item,(TRIGGERGUID)_Trigger, (REAL)_Speed, (REAL)_Acceleration, (INTEGER)_UseRotation)
		THEN
		ItemMoveToTrigger(_Item,_Trigger,_Speed,_Acceleration,_UseRotation,"",1);
		 
		PROC
		ItemMoveToPosition((ITEMGUID)_Item, (REAL)_X, (REAL)_Y, (REAL)_Z, (REAL)_Speed, (REAL)_Acceleration, (STRING)_Event)
		THEN
		ItemMoveToPosition(_Item, _X, _Y, _Z, _Speed, _Acceleration,_Event,1);
		
		PROC
		ItemMoveToPosition((ITEMGUID)_Item, (REAL)_X, (REAL)_Y, (REAL)_Z, (REAL)_Speed, (REAL)_Acceleration)
		THEN
		ItemMoveToPosition(_Item, _X, _Y, _Z, _Speed, _Acceleration,"",1);
		
		//END_REGION
		
		//REGION transform overloads
		PROC
		Transform((ITEMGUID)_Object, (STRING)_Template)
		THEN
		Transform(_Object,_Template,0,0,0);
		
		PROC
		Transform((GUIDSTRING)_Object, (STRING)_Template, (INTEGER)_ReplaceScripts)
		THEN
		Transform(_Object,_Template,_ReplaceScripts,0,0);
		
		PROC
		Transform((GUIDSTRING)_Object, (STRING)_Template, (INTEGER)_ReplaceScripts, (INTEGER)_ReplaceScale)
		THEN
		Transform(_Object,_Template,_ReplaceScripts,_ReplaceScale,0);
		
		//END_REGION
		
		//REGION Perception
		PROC
		ProcSetPerceptionDifficulty((ITEMGUID)_Item,(STRING)_Difficulty)
		THEN
		SetVarFixedString(_Item,"Difficulty",_Difficulty);
		SetStoryEvent(_Item,"GLO_OverrideWitsCheck");
		//END_REGION
		
		PROC
		PlayEffect((GUIDSTRING)_Object,(STRING)_FxName)
		THEN
		PlayEffect(_Object,_FxName,"");
		
		PROC
		ApplyDamage((GUIDSTRING)_Object, (INTEGER)_Damage, (STRING)_DamageType)
		THEN
		ApplyDamage(_Object, _Damage, _DamageType, NULL_00000000-0000-0000-0000-000000000000);
		
		PROC
		ApplyStatus((GUIDSTRING)_Object, (STRING)_Status, (REAL)_Duration, (INTEGER)_Force)
		THEN
		ApplyStatus(_Object, _Status, _Duration, _Force, NULL_00000000-0000-0000-0000-000000000000);
		
		PROC
		CharacterDie((CHARACTERGUID)_Character, (INTEGER)_GenerateTreasure, (STRING)_DeathType)
		THEN
		CharacterDie(_Character, _GenerateTreasure, _DeathType, NULL_00000000-0000-0000-0000-000000000000);
		
		PROC
		CharacterDieImmediate((CHARACTERGUID)_Character, (INTEGER)_GenerateTreasure, (STRING)_DeathType)
		THEN
		CharacterDieImmediate(_Character, _GenerateTreasure, _DeathType, NULL_00000000-0000-0000-0000-000000000000);
		
	}
	EXIT
	{
		
	}
}
Goal(11).Title("__Shared_Campaign");
Goal(11)
{
	INIT
	{
		
	}
	KB
	{
		IF
		GameModeStarted("Campaign",_IsEditorMode)
		THEN
		GoalCompleted;
		
	}
	EXIT
	{
		
	}
}
Goal(12).Title("__Start");
Goal(12)
{
	INIT
	{
		Proc_ExclamationMarkCleanup();
		
		
	}
	KB
	{
		IF
		GameEventSet("GAMEEVENT_GameStarted")
		THEN
		InitStory();
		GoalCompleted;
		
		
		PROC
		Proc_ExclamationMarkCleanup()
		AND
		_Player.DB_IsPlayer()
		THEN
		CharacterStopAllEffectsWithName(_Player,"RS3_FX_UI_Exclamation_Mark_01");
		SetHasDialog(_Player,0);
		
	}
	EXIT
	{
		
	}
}
Goal(13).Title("_AAA_FirstGoal");
Goal(13)
{
	INIT
	{
		// Time(_Day,_Hour,_TotalHours)
		// Current time (updated last time event NewHour was generated)
		//		_TotalHours = (_Day - 1)*24 + _Hour
		//		_TotalHours is suitable for calculating time differences
		//SetTime(ENGINE_GAME,10);  TODO
		DB_Time(1,10,10);
		// CurrentHalfHour and total HalfHours
		DB_HalfHour(20,20);
		
		//TODO: for now we use these timers to simulate time passing. This should come from the game engine if we're going to support different time of day settings
		DB_GameHour(300000);
		StartTimeOfDayTimerLoop();
		
		// Money dialog variables
		DB_FirstGoal_MoneyDialogVar(1,"GEN_CheckMagicPocketGold_6057ad05-9492-4630-9f0a-be548b134c54");
		DB_FirstGoal_MoneyDialogVar(2,"GEN_CheckMagicPocketGold_2_463b0f43-5410-412d-aba3-875cf81c38ca");
		DB_FirstGoal_MoneyDialogVar(3,"GEN_CheckMagicPocketGold_3_01f129ea-b4dc-44b6-8154-9a948f876a82");
		DB_FirstGoal_MoneyDialogVar(4,"GEN_CheckMagicPocketGold_4_5dac5eea-faeb-459c-b675-46c51519b784");
		DB_FirstGoal_MoneyDialogVar(5,"GEN_CheckMagicPocketGold_5_8860ed48-ba5f-4b7b-82bf-f1220f967d41");
		DB_FirstGoal_MoneyDialogVar(6,"GEN_CheckMagicPocketGold_6_ebf7de6b-4598-4feb-9c50-8083fc0fc59d");
		
		DB_FirstGoal_CheckPocketGoldSpeakerVar(1,"GEN_CheckPocketGold_SpeakerIndex_8504b4e0-886e-4912-9525-fbe559c5f8ff");
		DB_FirstGoal_CheckPocketGoldSpeakerVar(2,"GEN_CheckPocketGold_2_SpeakerIndex_a9c4d456-3ef5-491d-a1eb-49f09b91e8b4");
		DB_FirstGoal_CheckPocketGoldSpeakerVar(3,"GEN_CheckPocketGold_3_SpeakerIndex_d7fa1537-77d4-4d7d-a955-7ffda90e6207");
		DB_FirstGoal_CheckPocketGoldSpeakerVar(4,"GEN_CheckPocketGold_4_SpeakerIndex_5c499066-448b-4d0c-8dc9-d1553d04c6d4");
		DB_FirstGoal_CheckPocketGoldSpeakerVar(5,"GEN_CheckPocketGold_5_SpeakerIndex_65757687-b815-43fe-be9c-1cefe82efb60");
		
		//Has item template dialog variables
		DB_FirstGoal_HasItemTemplate_TemplateVar(1,"GEN_CheckHasItemTemplate_Template_ae6d2014-ca40-414b-a222-84b87efb1f05");
		DB_FirstGoal_HasItemTemplate_TemplateVar(2,"GEN_CheckHasItemTemplate_Template_2_1c16723d-50a0-4917-a198-0970edb93555");
		DB_FirstGoal_HasItemTemplate_TemplateVar(3,"GEN_CheckHasItemTemplate_Template_3_3965b187-cbef-40cd-9d7c-37bcb37ea2cd");
		DB_FirstGoal_HasItemTemplate_TemplateVar(4,"GEN_CheckHasItemTemplate_Template_4_4343086d-0af4-4509-8af7-efb6ae4ca057");
		DB_FirstGoal_HasItemTemplate_TemplateVar(5,"GEN_CheckHasItemTemplate_Template_5_069bdd27-9c44-4f21-b062-fcf75a541407");
		
		DB_FirstGoal_HasItemTemplate_SpeakerVar(1,"GEN_CheckHasItemTemplate_Speaker_a41274ae-7edf-4f3d-a137-dd45978c6224");
		DB_FirstGoal_HasItemTemplate_SpeakerVar(2,"GEN_CheckHasItemTemplate_Speaker_2_2674a9aa-1c71-42c3-977e-ffee67be69c6");
		DB_FirstGoal_HasItemTemplate_SpeakerVar(3,"GEN_CheckHasItemTemplate_Speaker_3_7f89238b-be41-4d7a-a9a8-6dc74a2ef8be");
		DB_FirstGoal_HasItemTemplate_SpeakerVar(4,"GEN_CheckHasItemTemplate_Speaker_4_33065191-7bc1-40dc-bd8c-3b897abb591e");
		DB_FirstGoal_HasItemTemplate_SpeakerVar(5,"GEN_CheckHasItemTemplate_Speaker_5_4fa046a9-a305-4b89-8383-ff6173a8b774");
		
		DB_FirstGoal_HasItemTemplate_AmountVar(1,"GEN_CheckHasItemTemplate_Amount_573b8076-ac9f-4c43-9161-f6eb76a90781");
		DB_FirstGoal_HasItemTemplate_AmountVar(2,"GEN_CheckHasItemTemplate_Amount_2_0663d6aa-c918-4b65-85a7-bd8e10247734");
		DB_FirstGoal_HasItemTemplate_AmountVar(3,"GEN_CheckHasItemTemplate_Amount_3_3837a5d2-c5d1-4200-bb5c-d7b8ad45f53a");
		DB_FirstGoal_HasItemTemplate_AmountVar(4,"GEN_CheckHasItemTemplate_Amount_4_32f62ba7-e482-4651-8927-636de5701edc");
		DB_FirstGoal_HasItemTemplate_AmountVar(5,"GEN_CheckHasItemTemplate_Amount_5_51db6483-c37d-4e38-b423-ebeb975571ac");
		
		// Keeping track of seen dead NPCs. Sets party flag
		// DB_SeenDeadNPCPartyFlag((CHARACTERGUID)_NPC,(STRING)_PartyFlag);
		
	}
	KB
	{
		//REGION Game Mode handling
		PROC
		Proc_GameModeStarted((STRING)_Mode,(INTEGER)_)
		THEN
		ProcSetCurrentGameMode(_Mode);
		
		PROC
		ProcSetCurrentGameMode((STRING)_Mode)
		AND
		DB_CurrentGameMode(_Old)
		THEN
		NOT DB_CurrentGameMode(_Old);
		
		PROC
		ProcSetCurrentGameMode((STRING)_Mode)
		THEN
		DB_CurrentGameMode(_Mode);
		
		//END_REGION
		
		//REGION Dialog book keeping 
		IF
		DialogRequestFailed(_Dialog,_Inst)
		THEN
		DB_MarkedForDelete(_Inst);
		ProcGetInvolvedPlayers(_Inst);
		ProcGetInvolvedNPCs(_Inst);
		ProcSaveNumActors(_Inst);
		ProcClearDialogFlagsForPlayers(_Inst);
		ProcClearDialogFlagsForNPCs(_Inst);
		DB_DialogRequestFailed(_Dialog,_Inst);
		
		IF
		AutomatedDialogRequestFailed(_Dialog,_Inst)
		THEN
		ProcGetInvolvedPlayers(_Inst);
		ProcGetInvolvedNPCs(_Inst);
		ProcSaveNumActors(_Inst);
		DB_AutomatedDialog(_Inst);
		DB_DialogRequestFailed(_Dialog,_Inst);
		
		IF
		DialogStarted(_Dialog,_Inst)
		THEN
		ProcGetInvolvedPlayers(_Inst);
		ProcGetInvolvedNPCs(_Inst);
		ProcSaveNumActors(_Inst);
		ProcSetDialogGoldCheckAmount(_Dialog);
		ProcSetDialogItemTemplateCheckAmount(_Dialog);
		DB_DialogName(_Dialog,_Inst);
		
		IF
		DialogActorJoined(_Dialog,_Inst,_Actor)
		THEN
		ProcAddActorToDialogList(_Inst,_Actor);
		ProcSetStoryNPC(_Inst,_Actor);
		ProcSetNumberOfInvolvedActors(_Inst);
		
		IF
		VoiceBarkStarted(_,_Inst)
		THEN
		DB_AutomatedDialogIsVB(_Inst);
		
		IF
		AutomatedDialogStarted(_Dialog,_Inst)
		THEN
		ProcGetInvolvedPlayers(_Inst);
		ProcGetInvolvedNPCs(_Inst);
		ProcSaveNumActors(_Inst);
		DB_AutomatedDialog(_Inst);
		DB_DialogName(_Dialog,_Inst);
		
		PROC
		ProcSetStoryNPC((INTEGER)_Inst,(GUIDSTRING)_Actor)
		AND
		NOT DB_AutomatedDialog(_Inst)
		AND
		ObjectIsCharacter((CHARACTERGUID)_Actor,1)
		AND
		NOT DB_CombatCharacters(_Actor,_)
		THEN
		CharacterMakeStoryNpc(_Actor,1);
		
		PROC
		ProcSetStoryNPC((INTEGER)_Inst,(GUIDSTRING)_Actor)
		AND
		NOT DB_AutomatedDialog(_Inst)
		THEN
		ProcItemSetInvulnerableForDialog(_Actor);
		
		//add these in the back so we don't disrupt the original flow
		PROC
		ProcAddActorToDialogList((INTEGER)_Inst,(GUIDSTRING)_Actor)
		AND
		DB_IsPlayer((CHARACTERGUID)_Actor)
		AND
		DB_DialogNumPlayers(_Inst,_NumPlayers)
		AND
		IntegerSum(_NumPlayers,1,_NewSlot)
		THEN
		DB_DialogPlayers(_Inst,(GUIDSTRING)_Actor,_NewSlot);
		
		PROC
		ProcAddActorToDialogList((INTEGER)_Inst,(GUIDSTRING)_Actor)
		AND
		NOT DB_IsPlayer((CHARACTERGUID)_Actor)
		AND
		DB_DialogNumNPCs(_Inst,_NumNPCs)
		AND
		IntegerSum(_NumNPCs,1,_NewSlot)
		THEN
		DB_DialogNPCs(_Inst,(GUIDSTRING)_Actor,_NewSlot);
		
		
		PROC
		ProcSetNumberOfInvolvedActors((INTEGER)_Inst)
		AND
		DB_DialogNumPlayers(_Inst,_NumPlayers)
		AND
		DB_DialogNumNPCs(_Inst,_NumNPCs)
		THEN
		NOT DB_DialogNumPlayers(_Inst,_NumPlayers);
		NOT DB_DialogNumNPCs(_Inst,_NumNPCs);
		ProcSaveNumActors(_Inst);
		
		PROC
		ProcSaveNumActors((INTEGER)_Inst)
		AND
		DialogGetNumberOfInvolvedNPCs(_Inst,_NumNPCs)
		AND
		DialogGetNumberOfInvolvedPlayers(_Inst,_NumPlayers)
		THEN
		DB_DialogNumPlayers(_Inst,_NumPlayers);
		DB_DialogNumNPCs(_Inst,_NumNPCs);
		
		PROC
		ProcGetInvolvedNPCs((INTEGER)_Inst)
		THEN
		ProcGetInvolveNPC(_Inst,1);
		
		PROC
		ProcGetInvolveNPC((INTEGER)_Inst,(INTEGER)_Index)
		AND
		DialogGetInvolvedNPC(_Inst,_Index,_NPC)
		AND
		IntegerSum(_Index,1,_New)
		THEN
		DB_DialogNPCs(_Inst,_NPC,_Index);
		ProcGetInvolveNPC(_Inst,_New);
		
		PROC
		ProcGetInvolvedPlayers((INTEGER)_Inst)
		THEN
		ProcGetInvolvePlayer(_Inst,1);
		
		PROC
		ProcGetInvolvePlayer((INTEGER)_Inst,(INTEGER)_Index)
		AND
		DialogGetInvolvedPlayer(_Inst,_Index,_Player)
		AND
		IntegerSum(_Index,1,_New)
		THEN
		DB_DialogPlayers(_Inst,_Player,_Index);
		ProcGetInvolvePlayer(_Inst,_New);
		
		PROC
		ProcSetDialogGoldCheckAmount((STRING)_Dialog)
		AND
		DB_DialogMoneyTransfer((INTEGER)_Index,(STRING)_Dialog,(INTEGER)_Amount,(INTEGER)_CheckSpeakerIndex,(INTEGER)_)
		AND
		DB_FirstGoal_MoneyDialogVar(_Index,_MoneyVarName)
		AND
		DB_FirstGoal_CheckPocketGoldSpeakerVar(_Index,_SpeakerVarName)
		THEN
		DialogSetVariableInt(_Dialog,_MoneyVarName,_Amount);
		DialogSetVariableInt(_Dialog,_SpeakerVarName,_CheckSpeakerIndex);
		
		PROC
		ProcSetDialogItemTemplateCheckAmount((STRING)_Dialog)
		AND
		DB_HasItemTemplateScriptFlag((INTEGER)_TemplateVarIndex, (STRING)_Dialog, (STRING)_ItemTemplate, (INTEGER)_SpeakerIndex, (INTEGER)_Amount)
		AND
		DB_FirstGoal_HasItemTemplate_TemplateVar(_TemplateVarIndex, _TemplateVarName)
		AND
		DB_FirstGoal_HasItemTemplate_SpeakerVar(_TemplateVarIndex, _SpeakerVarName)
		AND
		DB_FirstGoal_HasItemTemplate_AmountVar(_TemplateVarIndex, _AmountVarName)
		THEN
		DialogSetVariableString(_Dialog, _TemplateVarName, _ItemTemplate);
		DialogSetVariableInt(_Dialog, _SpeakerVarName, _SpeakerIndex);
		DialogSetVariableInt(_Dialog, _AmountVarName, _Amount);
		//END_REGION
		
		//REGION Player NPC seeing
		
		PROC
		ProcCheckIfOtherPlayersCanSeeNPC((CHARACTERGUID)_,(CHARACTERGUID)_)
		AND
		DB_OtherPlayersSee(_Npc)
		THEN
		NOT DB_OtherPlayersSee(_Npc);
		
		PROC
		ProcCheckIfOtherPlayersCanSeeNPC((CHARACTERGUID)_Player,(CHARACTERGUID)_Npc)
		AND
		_Other.DB_IsPlayer()
		AND
		_Other!=_Player 
		AND
		DB_Sees(_OtherPlayer,_Npc)
		THEN
		DB_OtherPlayersSee(_Npc);
		
		
		//END_REGION
		
		//REGION Player trigger checking
		
		QRY
		QryCheckOtherPlayersInTrigger((CHARACTERGUID)_Player,(TRIGGERGUID)_CheckTrigger)
		AND
		_Other.DB_IsPlayer()
		AND
		_Other!=_Player 
		AND
		DB_InRegion(_Other, _CheckTrigger)
		THEN
		DB_NOOP(1);
		
		//END_REGION
		
		//REGION Player triggers
		PROC
		ProcTriggerRegisterForPlayers((TRIGGERGUID)_Trig)
		AND
		GetRegion(_Trig,_Level)
		THEN
		DB_PlayerTriggers(_Level,_Trig);
		ProcDoTriggerRegisterForPlayers(_Level,_Trig);
		
		PROC
		ProcDoTriggerRegisterForPlayers((STRING)_Level,(TRIGGERGUID)_Trig)
		AND
		ObjectExists(_Trig,0)
		THEN
		DB_PlayerTriggerToRegister(_Level,_Trig);
		
		PROC
		ProcDoTriggerRegisterForPlayers((STRING)_Level,(TRIGGERGUID)_Trig)
		AND
		NOT DB_PlayerTriggerToRegister(_Level,_Trig)
		THEN
		TriggerRegisterForPlayers(_Trig);
		
		PROC
		ProcTriggerUnregisterForPlayers((TRIGGERGUID)_Trig)
		AND
		DB_PlayerTriggers(_Level,_Trig)
		AND
		ObjectExists(_Trig,0)
		THEN
		DB_PlayerTriggerToUnregister(_Level,_Trig);
		
		PROC
		ProcTriggerUnregisterForPlayers((TRIGGERGUID)_Trig)
		AND
		DB_PlayerTriggers(_Level,_Trig)
		AND
		NOT DB_PlayerTriggerToUnregister(_Level,_Trig)
		THEN
		TriggerUnregisterForPlayers(_Trig);
		
		PROC
		ProcTriggerUnregisterForPlayers((TRIGGERGUID)_Trig)
		AND
		DB_PlayerTriggers(_Level,_Trig)
		THEN
		NOT DB_PlayerTriggers(_Level,_Trig);
		
		PROC
		ProcRegisterPlayerTriggers((CHARACTERGUID)_Char)
		AND
		DB_PlayerTriggers(_Level,_Trig)
		AND
		ObjectExists(_Trig,0)
		THEN
		DB_PlayerTriggerToRegisterForCharacter(_Char,_Level,_Trig);
		
		PROC
		ProcRegisterPlayerTriggers((CHARACTERGUID)_Char)
		AND
		DB_PlayerTriggers(_Level,_Trig)
		AND
		NOT DB_PlayerTriggerToRegisterForCharacter(_Char,_Level,_Trig)
		THEN
		TriggerRegisterForCharacter(_Trig,_Char);
		
		PROC
		ProcUnRegisterPlayerTriggers((CHARACTERGUID)_Char)
		AND
		DB_PlayerTriggers(_Level,_Trig)
		AND
		ObjectExists(_Trig,0)
		THEN
		DB_PlayerTriggerToUnregisterForCharacter(_Char,_Level,_Trig);
		
		PROC
		ProcUnRegisterPlayerTriggers((CHARACTERGUID)_Char)
		AND
		DB_PlayerTriggers(_Level,_Trig)
		AND
		NOT DB_PlayerTriggerToUnregisterForCharacter(_Char,_Level,_Trig)
		THEN
		TriggerUnregisterForCharacter(_Trig,_Char);
		
		IF
		DB_PlayerTriggerToUnregisterForCharacter(_Char,_Level,_Trig)
		THEN
		NOT DB_PlayerTriggerToRegisterForCharacter(_Char,_Level,_Trig);
		
		IF
		DB_PlayerTriggerToRegisterForCharacter(_Char,_Level,_Trig)
		THEN
		NOT DB_PlayerTriggerToUnregisterForCharacter(_Char,_Level,_Trig);
		
		IF
		DB_PlayerTriggerToUnregister(_Level,_Trig)
		THEN
		NOT DB_PlayerTriggerToRegister(_Level,_Trig);
		
		IF
		DB_PlayerTriggerToRegister(_Level,_Trig)
		THEN
		NOT DB_PlayerTriggerToUnregister(_Level,_Trig);
		
		IF
		RegionStarted(_Level)
		THEN
		ProcRegisterTriggersForRegion(_Level);
		ProcUnregisterTriggersForRegion(_Level);
		ProcRegisterTriggersForCharacters(_Level);
		ProcUnregisterTriggersForCharacters(_Level);
		
		PROC
		ProcRegisterTriggersForRegion((STRING)_Level)
		AND
		DB_PlayerTriggerToRegister(_Level,_Trig)
		THEN
		TriggerRegisterForPlayers(_Trig);
		NOT DB_PlayerTriggerToRegister(_Level,_Trig);
		
		PROC
		ProcUnregisterTriggersForRegion((STRING)_Level)
		AND
		DB_PlayerTriggerToUnregister(_Level,_Trig)
		THEN
		TriggerUnregisterForPlayers(_Trig);
		NOT DB_PlayerTriggerToUnregister(_Level,_Trig);
		
		PROC
		ProcRegisterTriggersForCharacters((STRING)_Level)
		AND
		DB_PlayerTriggerToRegisterForCharacter(_Char,_Level,_Trig)
		THEN
		TriggerRegisterForCharacter(_Trig,_Char);
		NOT DB_PlayerTriggerToRegisterForCharacter(_Char,_Level,_Trig);
		
		PROC
		ProcUnregisterTriggersForCharacters((STRING)_Level)
		AND
		DB_PlayerTriggerToUnregisterForCharacter(_Char,_Level,_Trig)
		THEN
		TriggerUnregisterForCharacter(_Trig,_Char);
		NOT DB_PlayerTriggerToUnregisterForCharacter(_Char,_Level,_Trig);
		
		PROC
		ProcSetupGenericTimers((CHARACTERGUID)_Char)
		AND
		GetUUID(_Char,_UUID)
		AND
		StringConcatenate(_UUID,"_genTim",_Timer)
		THEN
		DB_GenericDialogTimers(_Char,_Timer);
		
		PROC
		ProcRemoveGenericTimer((CHARACTERGUID)_Char)
		AND
		DB_GenericDialogTimers(_Char,_Timer)
		THEN
		NOT DB_GenericDialogTimers(_Char,_Timer);
		//END_REGION
		
		// Since storyeditor orders goals alphabetically, this is the only way to make sure this goal comes first in story.div
		// This is important because Osiris uses rule order to execute alternatives.
		
		///////////////////////////////////////////////////////////////////////
		// buffer time
		
		PROC
		StartTimeOfDayTimerLoop()
		AND
		DB_GameHour(_Msec)
		THEN
		TimerLaunch("TimeOfDay",_Msec);
		
		IF
		TimerFinished("TimeOfDay")
		AND
		DB_GameHour(_Msec)
		AND
		DB_Time(_,_Hour,_)
		AND
		IntegerSum(_Hour,1,_NewHour)
		AND
		IntegerModulo(_NewHour,24,_Mod)
		THEN
		TimerLaunch("TimeOfDay",_Msec);
		NewHour(_Mod);
		
		PROC
		NewHour(0) 
		AND		// Day shifts to tomorrow
		DB_Time((INTEGER)_Day,(INTEGER)_,(INTEGER)_) 
		AND
		IntegerSum(_Day,1,_DayP1)
		THEN
		UpdateTime(_DayP1,0);
		
		PROC
		NewHour((INTEGER)_Hour) 
		AND
		_Hour != 0
		AND							// Day stays today
		DB_Time(_Day,_,_)
		THEN
		UpdateTime(_Day,_Hour);
		
		// Asserts Time(_Day,_Hour,...) with ... = the corresponding total hours = 24*(_Day - 1) + _Hour
		PROC
		UpdateTime((INTEGER)_Day,(INTEGER)_Hour) 
		AND
		DB_Time(_D,_H,_TH) 
		AND
		// calc new total hours:
		IntegerSubtract(_Day,1,_DM1) 
		AND
		IntegerProduct(_DM1,24,_T1) 
		AND
		IntegerSum(_T1,_Hour,_NewTH)
		THEN
		NOT DB_Time(_D,_H,_TH);
		DB_Time(_Day,_Hour,_NewTH);
		
		//TODO: commented stuff
		/*
		//
		IF		NewHalfHour(ENGINE_GAME,0)
		THEN	SetNewHalfHour(24);
		IF		NewHalfHour(ENGINE_GAME,_HH) AND _HH != 0
		THEN	SetNewHalfHour(_HH);
		
		PROC	SetNewHalfHour((INTEGER)_HH) AND
			HalfHour((INTEGER)_CurrentHH,(INTEGER)_TotalHH) AND
			IntegerSubtract(FUNCTION_Math,_HH,_CurrentHH,_Delta) AND
			// Normally, Delta == 1
			IntegerSum(FUNCTION_Math,_CurrentHH,_Delta,_CurrentHHPDelta) AND
			IntegerSum(FUNCTION_Math,_TotalHH,_Delta,_TotalHHPDelta)
		THEN	NOT HalfHour(_CurrentHH,_TotalHH);
			HalfHour(_CurrentHHPDelta,_TotalHHPDelta);
		
		
		///////////////////////////////////////////////////////////////////////
		// Buffer player invisibility
		IF		PlayerTurnsInvisible(NPC_Hero,1)
		THEN	PlayerIsInvisible(1);
		
		IF		PlayerTurnsInvisible(NPC_Hero,0)
		THEN	NOT PlayerIsInvisible(1);
		*/ 
		///////////////////////////////////////////////////////////////////////
		// Buffer seeing events
		// Note: "Sees" is asserted as soon as the "NpcSees" is generated. So you can use
		// "Sees" as event as well. Major difference: NpcSees ignores player invisibility.
		
		// Buffer effects of player movement:
		// (NpcSees actually means: "player starts seeing", NpcDoesNotSee means "players ends seeing")
		IF		
		CharacterSawCharacter(_Player,_Npc)
		AND
		_Player.DB_IsPlayer()
		THEN
		DB_Sees(_Player, _Npc);
		
		IF
		DB_Sees(_Player,_Npc)
		AND
		DB_SeenAliveNPCPartyFlag((CHARACTERGUID)_NPC,(STRING)_PartyFlag)
		AND
		DB_IsPlayer(_Player)
		AND
		NOT DB_Dead(_NPC)
		THEN
		PartySetFlag(_Player,_PartyFlag);
		
		//DB_Dead NPCs are blind
		IF
		CharacterDying(_Npc)
		AND
		DB_Sees(_Npc,_Player)
		THEN
		NOT DB_Sees(_Npc,_Player);
		
		IF		
		CharacterLostSightOfCharacter(_Player,_Npc)
		AND
		_Player.DB_IsPlayer()
		THEN	
		NOT DB_Sees(_Player, _Npc);
		NOT DB_Sees(_Npc, _Player);
		
		// Bring player invisibility into account (neglect for story npcs):
		IF		
		DB_Sees(_Npc, _Player) 
		AND
		_Player.DB_IsPlayer()
		AND 
		DB_PlayerIsInvisible(_Player,1) 
		AND 
		NOT DB_IsStoryNpc(_Npc)
		THEN
		NOT DB_Sees(_Npc, _Player);
		
		IF		
		DB_Sees(_Player, _Npc)
		AND
		_Player.DB_IsPlayer()
		AND 
		NOT DB_PlayerIsInvisible(_Player,1)
		THEN	
		DB_Sees(_Npc, _Player);
		
		IF		
		DB_Sees(_Player, _Npc)
		AND
		_Player.DB_IsPlayer()
		AND 
		DB_IsStoryNpc(_Npc)
		THEN
		DB_Sees(_Npc, _Player);
		
		/*
		///////////////////////////////////////////////////////////////////////
		// Buffer dialog distance (analogous to seeing events)
		
		// Buffer effects of player movement:
		IF		NpcEntersDialogDistance(NPC_Hero, _Npc)
		THEN	InDialogDistance(NPC_Hero, _Npc);
		
		IF		NpcLeavesDialogDistance(NPC_Hero, _Npc)
		THEN	NOT InDialogDistance(NPC_Hero, _Npc);
			NOT InDialogDistance(_Npc, NPC_Hero);
		
		// Bring player invisibility into account (neglect for story npcs):
		IF		InDialogDistance(_Npc, NPC_Hero) AND PlayerIsInvisible(1) AND NOT DB_IsStoryNpc(_Npc)
		THEN	NOT InDialogDistance(_Npc, NPC_Hero);
		
		IF		InDialogDistance(NPC_Hero, _Npc) AND NOT PlayerIsInvisible(1)
		THEN	InDialogDistance(_Npc, NPC_Hero);
		
		IF		InDialogDistance(NPC_Hero, _Npc) AND DB_IsStoryNpc(_Npc)
		THEN	InDialogDistance(_Npc, NPC_Hero);
		*/
		
		///////////////////////////////////////////////////////////////////////
		// Buffer region events
		IF	
		CharacterEnteredTrigger(_Npc,_Region)
		THEN
		DB_InRegion(_Npc, _Region);
		
		IF
		CharacterLeftTrigger(_Npc,_Region)
		THEN
		NOT DB_InRegion(_Npc, _Region);
		DB_WasInRegion(_Npc,_Region);
		
		///////////////////////////////////////////////////////////////////////
		// Buffer killed
		IF
		CharacterDying(_Npc)
		THEN
		DB_Dead(_Npc);
		
		IF
		CharacterDied(_Npc)
		AND
		NOT DB_Dead(_Npc)
		THEN
		DB_Dead(_Npc);
		
		IF
		CharacterResurrected(_Npc)
		THEN
		NOT DB_Dead(_Npc);
		
		//TODO: comments
		/*
		// Engine does not generate NpcDoesNotSee for dead npcs anymore, so we have to clean up ourself:
		IF		NpcKilled(_Npc) AND Sees(_Npc,_OtherNpc)
		THEN	NOT Sees(_Npc,_OtherNpc);
		IF		NpcKilled(_Npc) AND Sees(_OtherNpc,_Npc)
		THEN	NOT Sees(_OtherNpc,_Npc);
		// Cleanup InDialogDistance
		IF		NpcKilled(_Npc) AND InDialogDistance(_Npc,_OtherNpc)
		THEN	NOT InDialogDistance(_Npc,_OtherNpc);
		IF		NpcKilled(_Npc) AND InDialogDistance(_OtherNpc,_Npc)
		THEN	NOT InDialogDistance(_OtherNpc,_Npc);
		*/
		
		/*			///This Breaks a lot of things especially Arrest in Generics
		IF
		CharacterDied(_Npc)
		AND
		DB_InRegion(_Npc,_Region)
		THEN
		NOT DB_InRegion(_Npc,_Region);
		*/
		
		//TODO: comments
		/*
		IF		NpcResurrected((NPC)_Npc)
		THEN	NOT DB_Dead(_Npc);
		
		IF		NpcKilledBy(_Npc,NPC_Hero)
		THEN	HeroKilled(_Npc);
		*/
		///////////////////////////////////////////////////////////////////////
		// Cleanup DB_InRegion of npc (not the hero) if they are killed
		// test for _Npc != NPC_Hero explicitely added because debug cheat key "F1" does not
		// resurrect NPC_Hero, hence he remains "dead" although he can play on, enter regions, etc...
		IF
		DB_Dead(_Npc) 
		AND
		NOT _Npc.DB_IsPlayer()
		AND 
		DB_InRegion(_Npc,_Region)
		THEN
		NOT DB_InRegion(_Npc,_Region);
		
		IF
		DB_Dead(_Npc) 
		AND
		DB_DeadEvent(_Npc,(STRING)_Event)
		AND
		GlobalGetFlag(_Event,0)
		THEN
		GlobalSetFlag(_Event);
		
		IF
		RegionStarted((STRING)_NewRegion) 
		THEN
		DB_CurrentLevel(_NewRegion);
		
		IF
		RegionEnded((STRING)_Region)
		THEN
		NOT DB_CurrentLevel(_Region);
		
		QRY
		QRY_AnyRegionActive()
		AND
		DB_CurrentLevel(_)
		THEN
		DB_NOOP(1);
		
		//REGION Keeping track of seen dead NPCs
		IF
		DB_Dead(_NPC)
		AND
		DB_Sees(_Player,_NPC)
		AND
		DB_SeenDeadNPCPartyFlag((CHARACTERGUID)_NPC,(STRING)_PartyFlag)
		AND
		DB_IsPlayer(_Player)
		THEN
		PartySetFlag(_Player,_PartyFlag);
		
		IF
		CharacterDying(_NPC)
		AND
		DB_SeenDeadNPCPartyFlag(_NPC,_PartyFlag)
		AND
		DB_CombatCharacters(_NPC, _ID)
		AND
		DB_IsPlayer(_Player)
		AND
		DB_CombatCharacters(_Player, _ID)
		THEN
		PartySetFlag(_Player,_PartyFlag);
		
		//END_REGION
		
		
		//REGION OneshotTriggers
		IF
		DB_OneShotPlayerTrigger(_Trigger)
		THEN
		ProcTriggerRegisterForPlayers(_Trigger);
		
		IF
		DB_OneShotPlayerOnlyTrigger(_Trigger)
		THEN
		TriggerRegisterForPlayers(_Trigger);
		
		IF
		CharacterEnteredTrigger(_Player,_Trigger)
		AND
		DB_OneShotPlayerOnlyTrigger(_Trigger)
		THEN
		TriggerUnregisterForPlayers(_Trigger);
		NOT DB_OneShotPlayerOnlyTrigger(_Trigger);
		ProcOneShotTriggerEntered(_Player,_Trigger);
		
		PROC
		RemoveOneShotTrigger((TRIGGERGUID)_Trigger)
		AND
		DB_OneShotPlayerTrigger(_Trigger)
		THEN
		ProcTriggerUnregisterForPlayers(_Trigger);
		NOT DB_OneShotPlayerTrigger(_Trigger);
		
		IF
		CharacterEnteredTrigger(_Player,_Trigger)
		AND
		DB_OneShotPlayerTrigger(_Trigger)
		AND
		_Player.DB_IsPlayer()
		THEN
		RemoveOneShotTrigger(_Trigger);
		ProcOneShotTriggerEntered(_Player,_Trigger);
		
		PROC
		ProcOneShotTriggerEntered((CHARACTERGUID)_Player,(TRIGGERGUID)_Trigger)
		THEN
		DB_NOOP(1);
		//END_REGION
		
		//REGION _Global_CharacterAnimations
		// Flush player character animations that may be ongoing at the end of a dialog
		IF
		DialogEnded(_,_Dialog)
		AND
		DB_GLO_CharacterAnimationForDialog(_Character,_Dialog)
		AND
		DB_IsPlayer(_Character)
		THEN
		CharacterFlushQueue(_Character);
		
		IF
		DialogEnded(_,_Dialog)
		AND
		DB_GLO_CharacterAnimationForDialog(_Character,_Dialog)
		THEN
		// The animation may be purged by other code and hence never finish -> this DB would never be unset
		NOT DB_GLO_CharacterAnimationForDialog(_Character,_Dialog);
		//END_REGION
		
	}
	EXIT
	{
		
	}
}
Goal(14).Title("_AdvancedSneakTriggerSpotter");
Goal(14)
{
	INIT
	{
		//REGION AdvancedSneakTriggerSupport
		DB_SneakTriggerVars(1,"SpottedTrigger");
		DB_SneakTriggerVars(2,"SpottedTrigger1");
		DB_SneakTriggerVars(3,"SpottedTrigger2");
		DB_SneakTriggerVars(4,"SpottedTrigger3");
		//END_REGION
		
	}
	KB
	{
		//REGION AdvancedSneakTrigger
		IF
		DB_AdvancedSneakTriggerSpotter((TRIGGERGUID)_Trigger,(CHARACTERGUID)_Char)
		THEN
		ProcSetSneakyTriggerVar(_Char,_Trigger);
		PROC
		ProcSetSneakyTriggerVar((CHARACTERGUID)_Char,(TRIGGERGUID)_Trigger)
		AND
		NOT DB_SneakyTriggersCounter(_Char,_)
		THEN
		DB_SneakyTriggersCounter(_Char,0);
		PROC
		ProcSetSneakyTriggerVar((CHARACTERGUID)_Char,(TRIGGERGUID)_Trigger)
		AND
		DB_SneakyTriggersCounter(_Char,_Count)
		AND
		IntegerSum(_Count,1,_New)
		AND
		DB_SneakTriggerVars(_New,_Var)
		THEN
		DB_SneakyTriggersCounter(_Char,_New);
		NOT DB_SneakyTriggersCounter(_Char,_Count);
		SetVarObject(_Char,_Var,_Trigger);
		ProcTriggerRegisterForPlayers(_Trigger);
		
		IF
		StoryEvent((CHARACTERGUID)_Char, "GLO_AdvancedSpotterSneaker")
		AND
		GetVarObject(_Char, "SpottedDude", _Player)
		THEN
		ProcCharSpottedByChar((CHARACTERGUID)_Player,_Char);
		ProcReceiveActivatedTriggers(_Char,_Player);
		ProcLockSpotting(_Char);
		
		PROC
		ProcReceiveActivatedTriggers((CHARACTERGUID)_Char,(CHARACTERGUID)_Player)
		AND
		DB_AdvancedSneakTriggerSpotter((TRIGGERGUID)_Trigger, (CHARACTERGUID)_Char)
		AND
		DB_InRegion(_Player,_Trigger)
		THEN
		ProcCharInTriggerSpotted(_Player,_Trigger);
		ProcCharInTriggerSpottedByChar(_Player,_Trigger,_Char);
		
		PROC
		ProcCharSpottedByChar((CHARACTERGUID)_Player,(CHARACTERGUID)_Spotter)
		THEN
		DB_NOOP(1);
		
		PROC
		ProcLockSpotting((CHARACTERGUID)_Char)
		THEN
		SetVarInteger(_Char, "SpottedCounter", 1);
		
		PROC
		ProcCleanUpAdvancedSneakTriggers((CHARACTERGUID)_Char)
		AND
		DB_AdvancedSneakTriggerSpotter((TRIGGERGUID)_Trigger, (CHARACTERGUID)_Char)
		THEN
		NOT DB_AdvancedSneakTriggerSpotter(_Trigger, _Char);
		SetVarInteger(_Char, "SpottedCounter", 1);
		
		PROC
		ProcTriggerUnregisterForPlayers((TRIGGERGUID)_Trigger)
		AND
		DB_AdvancedSneakTriggerSpotter((TRIGGERGUID)_Trigger, (CHARACTERGUID)_Char)
		THEN
		NOT DB_AdvancedSneakTriggerSpotter((TRIGGERGUID)_Trigger, (CHARACTERGUID)_Char);
		IF
		DB_SpotterGroup((CHARACTERGUID)_Char,(STRING)_Name)
		AND
		_Player.DB_isPlayer()
		THEN
		SetVarInteger(_Player,_Name,0);
		SetVarFixedString(_Char,"SpotterGroup",_Name);
		//END_REGION
		
	}
	EXIT
	{
		
	}
}
Goal(15).Title("_Attitude");
Goal(15)
{
	INIT
	{
		
	}
	KB
	{
		PROC
		ProcMakeNPCHostile((CHARACTERGUID)_Player,(CHARACTERGUID)_Npc)
		AND
		CharacterIsDead(_Npc,0)
		AND
		CharacterIsPlayer(_Player,1)
		AND
		CharacterIsPlayer(_Npc,0)
		THEN
		CharacterSetTemporaryHostileRelation(_Npc,_Player);
		
		PROC
		ProcMakeNPCHostile((CHARACTERGUID)_Npc,(CHARACTERGUID)_Player)
		AND
		CharacterIsDead(_Npc,0)
		AND
		CharacterIsPlayer(_Player,1)
		THEN
		CharacterSetTemporaryHostileRelation(_Npc,_Player);
		
		PROC
		ProcMakeNPCHostile((CHARACTERGUID)_Npc,(CHARACTERGUID)_OtherNpc)
		AND
		CharacterIsDead(_Npc,0)
		AND
		CharacterIsDead(_OtherNpc,0)
		AND
		CharacterIsPlayer(_Npc,0)
		AND
		CharacterIsPlayer(_OtherNpc,0)
		THEN
		CharacterSetTemporaryHostileRelation(_Npc,_OtherNpc);
		
	}
	EXIT
	{
		
	}
}
Goal(16).Title("_CRIME_CrimeBribes");
Goal(16)
{
	INIT
	{
		// small (0) or big (1) bribe, max player level, min amount, max-min amount
		DB_CrimeBribes_BaseAmountUntilLevel(0,50,10,1);
		DB_CrimeBribes_BaseAmountUntilLevel(0,70,20,5);
		DB_CrimeBribes_BaseAmountUntilLevel(0,150,50,9);
		DB_CrimeBribes_BaseAmountUntilLevel(0,245,65,13);
		DB_CrimeBribes_BaseAmountUntilLevel(0,410,110,16);
		DB_CrimeBribes_BaseAmountUntilLevel(0,600,200,18);
		DB_CrimeBribes_BaseAmountUntilLevel(0,800,250,20);
		
		DB_CrimeBribes_BaseAmountUntilLevel(1,125,25,1);
		DB_CrimeBribes_BaseAmountUntilLevel(1,175,30,5);
		DB_CrimeBribes_BaseAmountUntilLevel(1,400,60,9);
		DB_CrimeBribes_BaseAmountUntilLevel(1,625,100,13);
		DB_CrimeBribes_BaseAmountUntilLevel(1,1100,200,16);
		DB_CrimeBribes_BaseAmountUntilLevel(1,1600,400,18);
		DB_CrimeBribes_BaseAmountUntilLevel(1,2200,500,20);
		
		DB_CrimeBribes_SevereCrimes("Murder");
		DB_CrimeBribes_SevereCrimes("SneakMurder");
		DB_CrimeBribes_SevereCrimes("Assault");
		
	}
	KB
	{
		//REGION Polymorph statuses are handled in the DivinityOrigins mod, so add a dummy proxy and a fallback
		// Actual implemetation in GLOBAL_ShapeShifting in DivinityOrigins
		QRY
		QRY_GLOBAL_Shapeshifting_GetPolymorphStatus((CHARACTERGUID)_Player)
		THEN
		DB_NOOP(1);
		
		// If we're not using DivinityOrigins, ensure we still define a
		// generic DB_GLOBAL_Shapeshifting_PolymorphStatus() as fallback
		QRY
		QRY_GLOBAL_Shapeshifting_GetPolymorphStatus_Fallback((CHARACTERGUID)_Player)
		AND
		NOT DB_GLOBAL_Shapeshifting_PolymorphStatus(_)
		THEN
		DB_GLOBAL_Shapeshifting_PolymorphStatus("");
		
		// Ensure fallback query always succeeds
		QRY
		QRY_GLOBAL_Shapeshifting_GetPolymorphStatus_Fallback((CHARACTERGUID)_Player)
		THEN
		DB_NOOP(1);
		
		//END_REGION
		
		//REGION Determine whether we select from the high or low bribes
		// Possible selectors:
		// * Tension
		// * Severity of the crime
		// * Number of times this person has been bribed
		
		// Determine severity
		// Return value:
		//   Severe crime: DB_CrimeBribes_CrimeSeverity(1)
		//   Non-sever crime: DB_CrimeBribes_CrimeSeverity(0)
		QRY
		QRY_CrimeBribes_CrimeGetSeverity((STRING)_CrimeType)
		AND
		DB_CrimeBribes_CrimeSeverity(_Severity)
		THEN
		NOT DB_CrimeBribes_CrimeSeverity(_Severity);
		
		QRY
		QRY_CrimeBribes_CrimeGetSeverity((STRING)_CrimeType)
		AND
		DB_CrimeBribes_SevereCrimes(_CrimeType)
		THEN
		DB_CrimeBribes_CrimeSeverity(1);
		
		QRY
		QRY_CrimeBribes_CrimeGetSeverity((STRING)_CrimeType)
		AND
		NOT DB_CrimeBribes_CrimeSeverity(1)
		THEN
		DB_CrimeBribes_CrimeSeverity(0);
		
		// Keep track of number of times this criminal has bribed this interrogator
		IF
		ObjectFlagSet(_Flag,_Speaker,_ID)
		AND
		DB_ItemEvents_TransferFlagToMoneyVarIndex(_Flag,_MoneyVarIndex)
		AND
		DB_DialogName(_Dialog,_ID)
		AND
		DB_CrimeTriggers_GeneralBribeDialog(_MoneyVarIndex,_Dialog)
		AND
		DB_DialogMoneyTransfer(_MoneyVarIndex,_Dialog,_,_,_TargetDBIndex)
		AND
		DB_DialogPlayers(_ID,_Player,1)
		AND
		DB_DialogNPCs(_ID,_NPC,_TargetDBIndex)
		AND
		QRY_GLOBAL_Shapeshifting_GetPolymorphStatus(_Player)
		AND
		QRY_GLOBAL_Shapeshifting_GetPolymorphStatus_Fallback(_Player)
		AND
		DB_GLOBAL_Shapeshifting_PolymorphStatus(_Race)
		THEN
		PROC_CrimeBribes_RecordBribe((CHARACTERGUID)_NPC,(CHARACTERGUID)_Player,_Race);
		
		PROC
		PROC_CrimeBribes_RecordBribe((CHARACTERGUID)_NPC,(CHARACTERGUID)_Player,(STRING)_Race)
		AND
		DB_CrimeBribes_PairBribes(_NPC,_Player,_Race,_Bribes)
		AND
		IntegerSum(_Bribes,1,_NewBribes)
		THEN
		NOT DB_CrimeBribes_PairBribes(_NPC,_Player,_Race,_Bribes);
		DB_CrimeBribes_PairBribes(_NPC,_Player,_Race,_NewBribes);
		
		PROC
		PROC_CrimeBribes_RecordBribe((CHARACTERGUID)_NPC,(CHARACTERGUID)_Player,(STRING)_Race)
		AND
		NOT DB_CrimeBribes_PairBribes(_NPC,_Player,_Race,_)
		THEN
		DB_CrimeBribes_PairBribes(_NPC,_Player,_Race,1);
		
		// Return value:
		//   Bribed too many times: DB_CrimeBribes_BribedTooManyTimes(1)
		//   Not yet bribed or a few times: DB_CrimeBribes_BribedTooManyTimes(0)
		QRY
		QRY_CrimeBribes_BribedTooManyTimes((CHARACTERGUID)_Interrogator,(CHARACTERGUID)_Criminal,(STRING)_Race)
		AND
		DB_CrimeBribes_BribedTooManyTimes(_Result)
		THEN
		NOT DB_CrimeBribes_BribedTooManyTimes(_Result);
		
		QRY
		QRY_CrimeBribes_BribedTooManyTimes((CHARACTERGUID)_Interrogator,(CHARACTERGUID)_Criminal,(STRING)_Race)
		AND
		DB_CrimeBribes_PairBribes(_Interrogator,_Criminal,_Race,_Bribes)
		AND
		// This is the number of times the NPC has already been bribed before. So starting at the second time,
		// it's too much
		_Bribes >= 1
		THEN
		DB_CrimeBribes_BribedTooManyTimes(1);
		
		QRY
		QRY_CrimeBribes_BribedTooManyTimes((CHARACTERGUID)_Interrogator,(CHARACTERGUID)_Criminal,(STRING)_Race)
		AND
		NOT DB_CrimeBribes_BribedTooManyTimes(1)
		THEN
		DB_CrimeBribes_BribedTooManyTimes(0);
		
		// Get bribe base & variation from table
		PROC
		PROC_CrimeBribes_GetBribeBounds((INTEGER)_HighBase,(INTEGER)_InterrogatorLevel)
		AND
		DB_CrimeBribes_GetBribeBounds(_Base,_Rand)
		THEN
		NOT DB_CrimeBribes_GetBribeBounds(_Base,_Rand);
		
		PROC
		PROC_CrimeBribes_GetBribeBounds((INTEGER)_HighBase,(INTEGER)_InterrogatorLevel)
		AND
		DB_CrimeBribes_BaseAmountUntilLevel(_HighBase,_Base,_Rand,1)
		THEN
		DB_CrimeBribes_GetBribeBounds(_Base,_Rand);
		
		PROC
		PROC_CrimeBribes_GetBribeBounds((INTEGER)_HighBase,(INTEGER)_InterrogatorLevel)
		AND
		DB_CrimeBribes_BaseAmountUntilLevel(_HighBase,_Base,_Rand,_Level)
		AND
		DB_CrimeBribes_GetBribeBounds(_OldBase,_OldRand)
		AND
		_Level <= _InterrogatorLevel
		AND
		_Base > _OldBase
		THEN
		NOT DB_CrimeBribes_GetBribeBounds(_OldBase,_OldRand);
		DB_CrimeBribes_GetBribeBounds(_Base,_Rand);
		
		// Get the bribe amount
		// Once a bribe amount has been set for an NPC, it stays that way until it switches from low to high
		// base, or if the level of the NPC changes (it doesn't make sense if the bribe changes randomly for
		// the same NPC with every new encounter).
		PROC
		PROC_CrimeBribes_GetBribe((CHARACTERGUID)_NPC,(INTEGER)_NPCLevel,(INTEGER)_HighBase)
		AND
		NOT DB_CrimeBribes_GetBribe_NPC(_NPC,_NPCLevel,_HighBase,_)
		THEN
		PROC_CrimeBribes_GetBribeBounds((INTEGER)_HighBase,(INTEGER)_NPCLevel);
		
		PROC
		PROC_CrimeBribes_GetBribe((CHARACTERGUID)_NPC,(INTEGER)_NPCLevel,(INTEGER)_HighBase)
		AND
		NOT DB_CrimeBribes_GetBribe_NPC(_NPC,_NPCLevel,_HighBase,_)
		AND
		DB_CrimeBribes_GetBribeBounds(_Base,_Rand)
		AND
		Random(_Rand,_Variation)
		AND
		IntegerSum(_Base,_Variation,_Bribe)
		THEN
		DB_CrimeBribes_GetBribe_NPC(_NPC,_NPCLevel,_HighBase,_Bribe);
		
		// return value
		PROC
		PROC_CrimeBribes_GetBribe((CHARACTERGUID)_NPC,(INTEGER)_NPCLevel,(INTEGER)_HighBase)
		AND
		DB_CrimeBribes_GetBribe(_Bribe)
		THEN
		NOT DB_CrimeBribes_GetBribe(_Bribe);
		
		PROC
		PROC_CrimeBribes_GetBribe((CHARACTERGUID)_NPC,(INTEGER)_NPCLevel,(INTEGER)_HighBase)
		AND
		DB_CrimeBribes_GetBribe_NPC(_NPC,_NPCLevel,_HighBase,_Bribe)
		THEN
		DB_CrimeBribes_GetBribe(_Bribe);
		
		// Set the bribe amount
		IF
		CrimeInterrogationRequest(_RegionID,_ID,_Interrogator,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_Dialog)
		THEN
		PROC_CrimeBribes_SetCrimeBribe(_ID,_Interrogator,_Criminal1,_Dialog);
		
		PROC
		ProcStartCrimeDialog((INTEGER)_CrimeID,(STRING)_CrimeDialog,1,(CHARACTERGUID)_NPC,(CHARACTERGUID)_Criminal,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4)
		THEN
		PROC_CrimeBribes_SetCrimeBribe(_CrimeID,_NPC,_Criminal,_CrimeDialog);
		
		//REGION Generic callback to disable bribing by certain (classes of) characters
		PROC
		PROC_CrimeBribes_SetCrimeBribe((INTEGER)_CrimeID,(CHARACTERGUID)_Interrogator,(CHARACTERGUID)_Criminal,(STRING)_Dialog)
		AND
		QRY_CrimeBribes_DisableBribe(_CrimeID,_Interrogator,_Criminal,_Dialog)
		THEN
		DB_CrimeBribesDisabledBribe(_Interrogator,_Criminal,_Dialog);
		ObjectSetFlag(_Interrogator,"GEB_BribeDisabled");
		//END_REGION
		
		//REGION Only allow bribing a few times
		QRY
		QRY_CrimeBribes_DisableBribe((INTEGER)_CrimeID,(CHARACTERGUID)_Interrogator,(CHARACTERGUID)_Criminal,(STRING)_Dialog)
		AND
		QRY_GLOBAL_Shapeshifting_GetPolymorphStatus(_Criminal)
		AND
		DB_GLOBAL_Shapeshifting_PolymorphStatus(_Race)
		AND
		QRY_CrimeBribes_BribedTooManyTimes(_Interrogator,_Criminal,_Race)
		AND
		DB_CrimeBribes_BribedTooManyTimes(1)
		THEN
		DB_NOOP(1);
		
		IF
		DialogEnded(_Dialog,_ID)
		AND
		DB_CrimeBribesDisabledBribe(_Interrogator,_Criminal,_Dialog)
		AND
		DB_DialogNPCs(_ID,_Interrogator,_)
		AND
		DB_DialogPlayers(_ID,_Criminal,_)
		THEN
		NOT DB_CrimeBribesDisabledBribe(_Interrogator,_Criminal,_Dialog);
		ObjectClearFlag(_Interrogator,"GEB_BribeDisabled");
		//END_REGION
		
		// Low bribe if this NPC has not yet been bribed too many time by this player,
		// AND it's not a severe crime, AND tension is below warning threshold.
		// Otherwise higher bribe.
		PROC
		PROC_CrimeBribes_SetCrimeBribe((INTEGER)_CrimeID,(CHARACTERGUID)_Interrogator,(CHARACTERGUID)_Criminal,(STRING)_Dialog)
		AND
		DB_CrimeTriggers_GeneralBribeDialog(_MoneyVarIndex,_Dialog)
		AND
		CrimeGetType(_CrimeID,_CrimeType)
		AND
		QRY_CrimeBribes_CrimeGetSeverity(_CrimeType)
		AND
		QRY_GLOBAL_Shapeshifting_GetPolymorphStatus(_Criminal)
		AND
		DB_GLOBAL_Shapeshifting_PolymorphStatus(_Race)
		AND
		QRY_CrimeBribes_BribedTooManyTimes(_Interrogator,_Criminal,_Race)
		AND
		DB_CrimeBribes_CrimeSeverity(_Severity)
		AND
		DB_CrimeBribes_BribedTooManyTimes(_TooManyTimes)
		AND
		IntegerMax(_Severity,_TooManyTimes,_HighBase1)
		AND
		CrimeIsTensionOverWarningTreshold(_Criminal,_TensionOverWarning)
		AND
		IntegerMax(_HighBase1,_TensionOverWarning,_HighBaseFinal)
		AND
		CharacterGetLevel(_Interrogator,_InterrogatorLevel)
		THEN
		PROC_CrimeBribes_GetBribe(_Interrogator,_InterrogatorLevel,_HighBaseFinal);
		
		PROC
		PROC_CrimeBribes_SetCrimeBribe((INTEGER)_CrimeID,(CHARACTERGUID)_Interrogator,(CHARACTERGUID)_Criminal,(STRING)_Dialog)
		AND
		DB_CrimeTriggers_GeneralBribeDialog(_MoneyVarIndex,_Dialog)
		AND
		DB_CrimeBribes_GetBribe(_Bribe)
		THEN
		// Will clear previous entries, if any
		DB_DialogMoneyTransfer(_MoneyVarIndex,_Dialog,_Bribe);
		
	}
	EXIT
	{
		
	}
}
Goal(17).Title("_CRIME_CrimeTriggers");
Goal(17)
{
	INIT
	{
		//Warning As AD
		// TODO: what if a custom warning is an AD? Does it get added in there?
		DB_CrimeWarningIsAD("GEB_AD_Noticed_EscapedPrisonerHelpful");
		DB_CrimeWarningIsAD("GEB_AD_Noticed_Vandalise");
		DB_CrimeWarningIsAD("GEB_AD_Noticed_Sneaking");
		DB_CrimeWarningIsAD("GEB_AD_Noticed_Smelly");
		DB_CrimeWarningIsAD("GEB_AD_Noticed_Weapons");
		DB_CrimeWarningIsAD("GEB_AD_Noticed_AttackedAnimal");
		DB_CrimeWarningIsAD("GEB_AD_Noticed_KilledAnimal");
		DB_CrimeWarningIsAD("GEB_AD_Noticed_AnimalAttackedAnimal");
		DB_CrimeWarningIsAD("GEB_AD_Help_Thief");
		DB_CrimeWarningIsAD("GEB_AD_FTJ_Noticed_NoCollar");
		DB_CrimeWarningIsAD("GEB_AD_Noticed_SummonAssault");
		DB_CrimeWarningIsAD("GEB_AD_Noticed_SummonVandalise");
		DB_CrimeWarningIsAD("GEB_AD_Noticed_Summon");
		DB_CrimeWarningIsAD("GEB_AD_Noticed_SummonMoveItem");
		DB_CrimeWarningIsAD("GEB_AD_Noticed_Polymorphed");
		DB_CrimeWarningIsAD("GEB_Lohse_AD_Warning_SummonAssault");
		DB_CrimeWarningIsAD("GEB_Ifan_AD_Warning_SummonAssault");
		DB_CrimeWarningIsAD("GEB_Sebille_AD_Warning_SummonAssault");
		DB_CrimeWarningIsAD("GEB_RedPrince_AD_Warning_SummonAssault");
		DB_CrimeWarningIsAD("GEB_AD_NoticedDeadSilentMonk");
		
		// Trespassing
		DB_TrespassingCrimes("Trespassing");
		
		// Murder
		
		// Killing -> Murder type mapping : Sneak or not, Killed animal or not, killer is Summon or not
		DB_CRIME_MurderType(0,0,0,"Murder");
		DB_CRIME_MurderType(1,0,0,"SneakMurder");
		DB_CRIME_MurderType(0,1,0,"KilledAnimal");
		DB_CRIME_MurderType(1,1,0,"SneakKilledAnimal");
		DB_CRIME_MurderType(0,0,1,"SummonMurder");
		DB_CRIME_MurderType(1,0,1,"SummonMurder");
		DB_CRIME_MurderType(0,1,1,"SummonKilledAnimal");
		DB_CRIME_MurderType(1,1,1,"SummonKilledAnimal");
		
		DB_CRIME_ForbiddenStatus("LYING");
		
		//For Status Reactions
		DB_StatusReaction("SMELLY","Smelly");
		DB_StatusReaction("UNSHEATHED","WeaponsDrawn");
		
		//Ingnore Vandalise Tags
		DB_IgnoreVandaliseTag("JUNK");
		DB_IgnoreVandaliseTag("IGNOREVANDALISE");
		
		//Bribe
		DB_CrimeTriggers_GeneralBribeDialog(1,"GEB_Arrest");
		DB_CrimeTriggers_GeneralBribeDialog(1,"GEB_Arrest_EscapedPrison");
		DB_CrimeTriggers_GeneralBribeDialog(1,"GEB_Arrest_Theft");
		DB_CrimeTriggers_GeneralBribeDialog(1,"GEB_Arrest_Trespassing");
		DB_CrimeTriggers_GeneralBribeDialog(1,"GEB_Arrest_UseForbiddenItem");
		DB_CrimeTriggers_GeneralBribeDialog(1,"GEB_Arrest_Vandalise");
		DB_CrimeTriggers_GeneralBribeDialog(1,"GEB_Interrogation");
		DB_CrimeTriggers_GeneralBribeDialog(1,"GEB_Interrogation_Assault");
		DB_CrimeTriggers_GeneralBribeDialog(1,"GEB_Interrogation_Murder");
		DB_CrimeTriggers_GeneralBribeDialog(1,"GEB_Interrogation_PickPocketNoticed");
		DB_CrimeTriggers_GeneralBribeDialog(1,"GEB_Interrogation_Steal");
		DB_CrimeTriggers_GeneralBribeDialog(1,"GEB_Interrogation_UsedSource");
		DB_CrimeTriggers_GeneralBribeDialog(1,"GEB_Interrogation_Vandalise");
		DB_CrimeTriggers_GeneralBribeDialog(1,"GEB_Warning_PickPocketFailed_EvidenceCheck");
		
		//Pickpocket
		DB_CannotPickpocketTags("ANIMAL");
		DB_CannotPickpocketTags("ELEMENTAL");
		DB_CannotPickpocketTags("GHOST");
		DB_CannotPickpocketTags("VOIDLING");
		DB_CannotPickpocketTags("VOIDSECT");
		DB_CannotPickpocketTags("VOID_SOLDIER");
		DB_CannotPickpocketTags("ALANBIRD");
		DB_CannotPickpocketTags("MOLESPITTER");
		DB_CannotPickpocketTags("NIGHTFANG");
		DB_CannotPickpocketTags("VOIDWOLF");
		DB_CannotPickpocketTags("FLESH_GOLEM");
		DB_CannotPickpocketTags("BLOCK_PICKPOCKET");
		
		//Attitude Change
		DB_CrimeAttitudeChange("SourceMagic",-5);
		DB_CrimeAttitudeChange("Murder",-30);
		DB_CrimeAttitudeChange("SpiritTalk",-1);
		DB_CrimeAttitudeChange("Assault",-20);
		DB_CrimeAttitudeChange("Steal",-5);
		DB_CrimeAttitudeChange("PickPocketFailed",-5);
		DB_CrimeAttitudeChange("PickPocket",-10);
		DB_CrimeAttitudeChange("ItemDestroy",-15);
		DB_CrimeAttitudeChange("Vandalise",-10);
		DB_CrimeAttitudeChange("VandaliseNoOwner",-5);
		DB_CrimeAttitudeChange("Trespassing",-5);
		DB_CrimeAttitudeChange("UseForbiddenItem",-5);
		DB_CrimeAttitudeChange("MoveForbiddenItem",-5);
		DB_CrimeAttitudeChange("AttackAnimal",-5);
		DB_CrimeAttitudeChange("TeleportPlayerDialog",-5);
		
		//Evidence check
		DB_EvidenceCheckInWarning("GEB_Warning_PickPocketFailed_EvidenceCheck");
		DB_EvidenceCheckInWarning("RC_WH_DijinnItem_Interrogation");
		
		DB_NeutralTagIgnore("GHOST");
		
		DB_Negate(0,1);
		DB_Negate(1,0);
		
		DB_IgnoreDamageSources("SurfaceMove");
		DB_IgnoreDamageSources("StatusTick");
		DB_IgnoreDamageSources("SurfaceStatus");
		DB_IgnoreDamageSources("Offhand");
		
		//crime tpyes that should be kept in sync when the parent crime is enabled/disabled
		DB_LinkedCrimes("Assault","SummonAssault");
		DB_LinkedCrimes("Assault","IncapacitatedAssault");
		
		DB_LinkedCrimes("Murder","KilledAnimal");
		DB_LinkedCrimes("Murder","SneakKilledAnimal");
		DB_LinkedCrimes("Murder","SneakMurder");
		DB_LinkedCrimes("Murder","SummonMurder");
		DB_LinkedCrimes("Murder","SummonKilledAnimal");
		
		DB_LinkedCrimes("MoveForbiddenItem", "SummonMoveForbiddenItem");
		
		//crime warning to hostile dialogs
		DB_CrimeWarningHostileADs("GEB_Warning_Theft","GEB_AD_Help_Thief");
		DB_CrimeWarningHostileADs("GEB_Warning_UseForbiddenItem","GEB_AD_Help_UseForbiddenItem");
		
		// Apply item effect to user
		DB_ItemStatusAffectCharacterOnUse("BURNING");
		DB_ItemStatusAffectCharacterOnUse("SHOCKED");
		
		// Score increase based on invisible/sneaking. At 9 or more, NPC will realise where attack
		// comes from and go to location of that attacker. Script will actually increase by one more
		// for implementation reasons (taken into account in values of table below)
		//                                  sneaking   invisible   base increase   random increase (mod, 1 -> 0)
		DB_CRIME_CrimeLocationScoreIncrease(0,         0,          3,              1);
		DB_CRIME_CrimeLocationScoreIncrease(1,         0,          2,              1);
		DB_CRIME_CrimeLocationScoreIncrease(0,         1,          1,              1);
		DB_CRIME_CrimeLocationScoreIncrease(1,         1,          2,              1);
		
		// score >= threshold -> perform action
		DB_CRIME_CrimeLocationScore_GoToAttackerThreshold(9);
		DB_CRIME_CrimeLocationScore_StartAttackingThreshold(13);
		// health < threshold -> perform action
		DB_CRIME_Assault_HealthStartAttackingThreshold(80.0);
		
		// Flee crime reactions
		DB_CRIME_FleeReaction("CRIME_Flee");
		DB_CRIME_FleeReaction("CRIME_FleeWithAD");
		
		// non-summon/summon versions of move forbidden item
		DB_CRIME_MoveForbiddenCrime(0, "MoveForbiddenItem");
		DB_CRIME_MoveForbiddenCrime(1, "SummonMoveForbiddenItem");
		
	}
	KB
	{
		PROC
		Proc_GameModeStarted("GameMaster",_)
		THEN
		GoalCompleted;
		
		//REGION Temporarily suspend and resume all currently enabled crimes
		IF
		StoryEvent((CHARACTERGUID)_Npc, "CRIMES_SuspendCrimeReactions")
		THEN
		CharacterDisableAllCrimes(_Npc);
		
		IF
		StoryEvent((CHARACTERGUID)_Npc, "CRIMES_ResumeCrimeReactions")
		AND
		NOT DB_CharacterAllCrimesDisabled(_Npc)
		THEN
		CharacterEnableAllCrimes(_Npc);
		
		IF
		StoryEvent((CHARACTERGUID)_Npc, "CRIMES_ResumeCrimeReactions")
		AND
		DB_CharacterCrimeDisabled(_Npc,_Crime)
		THEN
		CharacterDisableCrime(_Npc,_Crime);
		
		IF
		StoryEvent((CHARACTERGUID)_Npc, "CRIMES_ResumeCrimeReactions")
		AND
		DB_CharacterCrimeEnabled(_Npc,_Crime)
		THEN
		CharacterEnableCrime(_Npc,_Crime);
		//END_REGION
		
		//REGION Register crime wrapper to  handle ignoring crimes
		QRY
		QRY_CRIME_CrimeTriggers_IsCrimeFamilyMember((STRING)_Crime,(STRING)_CrimeOrFamily)
		AND
		_Crime == _CrimeOrFamily
		THEN
		DB_NOOP(1);
		
		QRY
		QRY_CRIME_CrimeTriggers_IsCrimeFamilyMember((STRING)_Crime,(STRING)_CrimeOrFamily)
		AND
		DB_LinkedCrimes(_CrimeOrFamily,_Crime)
		THEN
		DB_NOOP(1);
		
		// Built-in:
		// * DB_AssaultIgnoreFor(_Witness, _Victim): _Witness ignores all Assault crimes against victim
		// * DB_AssaultFamilyIgnoreFor((CHARACTERGUID)_AnyWitness,(CHARACTERGUID)_Victim): _Witness ignores all Assault-like crimes against victim
		PROC
		PROC_CRIME_CrimeTriggers_GetSilentWitnessesForCrime((INTEGER)_CrimeID,(CHARACTERGUID)_Perpetrator,"Assault",(GUIDSTRING)_Evidence,(CHARACTERGUID)_Victim)
		AND
		DB_AssaultIgnoreFor((CHARACTERGUID)_AnyWitness,(CHARACTERGUID)_Victim)
		THEN
		DB_CRIME_CrimeTriggers_SilentWitnessesForCrime(_AnyWitness);
		
		PROC
		PROC_CRIME_CrimeTriggers_GetSilentWitnessesForCrime((INTEGER)_CrimeID,(CHARACTERGUID)_Perpetrator,(STRING)_CrimeType,(GUIDSTRING)_Evidence,(CHARACTERGUID)_Victim)
		AND
		DB_AssaultFamilyIgnoreFor((CHARACTERGUID)_AnyWitness,(CHARACTERGUID)_Victim)
		AND
		QRY_CRIME_CrimeTriggers_IsCrimeFamilyMember(_CrimeType,"Assault")
		THEN
		DB_CRIME_CrimeTriggers_SilentWitnessesForCrime(_AnyWitness);
		
		PROC
		ProcCharacterRegisterCrime((CHARACTERGUID)_Char,(STRING)_CrimeType,(GUIDSTRING)_Evidence,(CHARACTERGUID)_CrimeWitness,(INTEGER)_CrimeID,(CHARACTERGUID)_Victim)
		AND
		NOT QRY_CRIME_BlockRegisterCrime(_Char, _CrimeType, _Evidence, _CrimeWitness, _CrimeID, _Victim)
		THEN
		ProcCharacterRegisterCrimeHandleIgnoresBefore(_Char,_CrimeType,_Evidence,_CrimeWitness,_CrimeID,_Victim);
		
		PROC
		ProcCharacterRegisterCrimeWithPosition((CHARACTERGUID)_Char,(STRING)_CrimeType,(GUIDSTRING)_Evidence,(CHARACTERGUID)_CrimeWitness,(REAL)_X,(REAL)_Y,(REAL)_Z,(INTEGER)_CrimeID,(CHARACTERGUID)_Victim)
		AND
		NOT QRY_CRIME_BlockRegisterCrime(_Char, _CrimeType, _Evidence, _CrimeWitness, _CrimeID, _Victim)
		THEN
		ProcCharacterRegisterCrimeHandleIgnoresBefore(_Char,_CrimeType,_Evidence,_CrimeWitness,_CrimeID,_Victim);
		
		PROC
		ProcCharacterRegisterCrimeHandleIgnoresBefore((CHARACTERGUID)_Char,(STRING)_CrimeType,(GUIDSTRING)_Evidence,(CHARACTERGUID)_CrimeWitness,(INTEGER)_CrimeID,(CHARACTERGUID)_Victim)
		THEN
		PROC_CRIME_CrimeTriggers_GetSilentWitnessesForCrime(_CrimeID,_Char,_CrimeType,_Evidence,_Victim);
		
		// If this crime is specifically already disabled for the witness, don't do anything special
		// except for ignoring the crime
		PROC
		ProcCharacterRegisterCrimeHandleIgnoresBefore((CHARACTERGUID)_Char,(STRING)_CrimeType,(GUIDSTRING)_Evidence,(CHARACTERGUID)_CrimeWitness,(INTEGER)_CrimeID,(CHARACTERGUID)_Victim)
		AND
		DB_CRIME_CrimeTriggers_SilentWitnessesForCrime(_AnyWitness)
		AND
		DB_CharacterCrimeDisabled(_AnyWitness,_CrimeType)
		THEN
		// Undefine here instead of directly checking in QRY_CRIME_CrimeTriggers_GetSilentWitnessesForCrime(), as
		// QRY_CRIME_CrimeTriggers_GetSilentWitnessesForCrime() may be overloaded in user goals and may miss such checks
		NOT DB_CRIME_CrimeTriggers_SilentWitnessesForCrime(_AnyWitness);
		DB_CRIME_CrimeTriggers_SilentWitnessIgnoreOnly(_AnyWitness);
		
		// If all crimes are disabled for the witness and this one is not enabled, don't do anything special either
		// except for ignoring the crime
		PROC
		ProcCharacterRegisterCrimeHandleIgnoresBefore((CHARACTERGUID)_Char,(STRING)_CrimeType,(GUIDSTRING)_Evidence,(CHARACTERGUID)_CrimeWitness,(INTEGER)_CrimeID,(CHARACTERGUID)_Victim)
		AND
		DB_CRIME_CrimeTriggers_SilentWitnessesForCrime(_AnyWitness)
		AND
		DB_CharacterAllCrimesDisabled(_AnyWitness)
		AND
		NOT DB_CharacterCrimeEnabled(_AnyWitness,_CrimeType)
		THEN
		NOT DB_CRIME_CrimeTriggers_SilentWitnessesForCrime(_AnyWitness);
		DB_CRIME_CrimeTriggers_SilentWitnessIgnoreOnly(_AnyWitness);
		
		// The remaining witnesses that need to temporarily ignore this crime
		PROC
		ProcCharacterRegisterCrimeHandleIgnoresBefore((CHARACTERGUID)_Char,(STRING)_CrimeType,(GUIDSTRING)_Evidence,(CHARACTERGUID)_CrimeWitness,(INTEGER)_CrimeID,(CHARACTERGUID)_Victim)
		AND
		DB_CRIME_CrimeTriggers_SilentWitnessesForCrime(_AnyWitness)
		THEN
		CharacterDisableCrime(_AnyWitness,_CrimeType);
		
		// Register the crime
		PROC
		ProcCharacterRegisterCrime((CHARACTERGUID)_Char,(STRING)_CrimeType,(GUIDSTRING)_Evidence,(CHARACTERGUID)_CrimeWitness,(INTEGER)_CrimeID,(CHARACTERGUID)_Victim)
		AND
		NOT QRY_CRIME_BlockRegisterCrime(_Char,_CrimeType,_Evidence,_CrimeWitness,_CrimeID, _Victim)
		THEN
		CharacterRegisterCrime(_Char,_CrimeType,_Evidence,_CrimeWitness,_CrimeID);
		
		QRY
		QRY_CRIME_BlockRegisterCrime((CHARACTERGUID)_Char,(STRING)_CrimeType,(GUIDSTRING)_Evidence,(CHARACTERGUID)_CrimeWitness,(INTEGER)_CrimeID,(CHARACTERGUID)_Victim)
		AND
		1 == 0
		THEN
		DB_NOOP(0);
		
		PROC
		ProcCharacterRegisterCrimeWithPosition((CHARACTERGUID)_Char,(STRING)_CrimeType,(GUIDSTRING)_Evidence,(CHARACTERGUID)_CrimeWitness,(REAL)_X,(REAL)_Y,(REAL)_Z,(INTEGER)_CrimeID,(CHARACTERGUID)_Victim)
		AND
		NOT QRY_CRIME_BlockRegisterCrime(_Char, _CrimeType, _Evidence, _CrimeWitness, _CrimeID, _Victim)
		
		THEN
		CharacterRegisterCrimeWithPosition(_Char,_CrimeType,_Evidence,_CrimeWitness,_X,_Y,_Z,_CrimeID);
		
		PROC
		ProcCharacterRegisterCrime((CHARACTERGUID)_Char,(STRING)_CrimeType,(GUIDSTRING)_Evidence,(CHARACTERGUID)_CrimeWitness,(INTEGER)_CrimeID,(CHARACTERGUID)_Victim)
		THEN
		ProcCharacterRegisterCrimeHandleIgnoresAfter(_CrimeType,_CrimeID);
		
		PROC
		ProcCharacterRegisterCrimeWithPosition((CHARACTERGUID)_Char,(STRING)_CrimeType,(GUIDSTRING)_Evidence,(CHARACTERGUID)_CrimeWitness,(REAL)_X,(REAL)_Y,(REAL)_Z,(INTEGER)_CrimeID,(CHARACTERGUID)_Victim)
		THEN
		ProcCharacterRegisterCrimeHandleIgnoresAfter(_CrimeType,_CrimeID);
		
		// Ignore the crime for the silent witnesses (they will also ignore it in case they were not a witness
		// and discover the crime scene later on) and then re-enable the crime for them
		PROC
		ProcCharacterRegisterCrimeHandleIgnoresAfter((STRING)_CrimeType,(INTEGER)_CrimeID)
		AND
		DB_CRIME_CrimeTriggers_SilentWitnessesForCrime(_AnyWitness)
		THEN
		CrimeIgnoreCrime(_CrimeID,_AnyWitness);
		CharacterEnableCrime(_AnyWitness,_CrimeType);
		NOT DB_CRIME_CrimeTriggers_SilentWitnessesForCrime(_AnyWitness);
		
		PROC
		ProcCharacterRegisterCrimeHandleIgnoresAfter((STRING)_CrimeType,(INTEGER)_CrimeID)
		AND
		DB_CRIME_CrimeTriggers_SilentWitnessIgnoreOnly(_AnyWitness)
		THEN
		NOT DB_CRIME_CrimeTriggers_SilentWitnessIgnoreOnly(_AnyWitness);
		CrimeIgnoreCrime(_CrimeID,_AnyWitness);
		//END_REGION
		
		//REGION Stopping Dialog
		IF
		CharacterOnCrimeSensibleActionNotification(_NPC,_Region,_CrimeID,_PriorityName,_Dialog,_Criminal,_Criminal2,_Criminal3,_Criminal4,_)
		THEN
		ProcForceStopDialog(_NPC); //This will only stop ADs Code stops interactive ones and SensibleAction will fail if he can't react to it
		//END_REGION
		
		//REGION Behaviour scripts disabling
		IF
		CrimeDisabled(_Char,"")
		THEN
		ProcCharacterDisableAllCrimes((CHARACTERGUID)_Char);
		
		IF
		CrimeDisabled(_Char,_Crime)
		AND
		_Crime != ""
		THEN
		ProcCharacterDisableCrime(_Char,_Crime);
		
		IF
		CrimeEnabled(_Char,"")
		THEN
		ProcCharacterEnableAllCrimes((CHARACTERGUID)_Char);
		
		IF
		CrimeEnabled(_Char,_Crime)
		AND
		_Crime != ""
		THEN
		ProcCharacterEnableCrime(_Char,_Crime);
		//END_REGION
		
		//REGION Crime Enabling/Disabling
		PROC
		ProcCharacterDisableAllCrimes((CHARACTERGUID)_Char)
		THEN
		DB_CharacterAllCrimesDisabled(_Char);
		CharacterDisableAllCrimes(_Char);
		
		PROC
		ProcCharacterEnableAllCrimes((CHARACTERGUID)_Char)
		THEN
		NOT DB_CharacterAllCrimesDisabled(_Char);
		CharacterEnableAllCrimes(_Char);
		
		PROC
		ProcCharacterEnableCrime((CHARACTERGUID)_Char,(STRING)_Crime)
		THEN
		DB_CharacterCrimeEnabled(_Char,_Crime);
		CharacterEnableCrime(_Char,_Crime);
		
		PROC
		ProcCharacterDisableCrime((CHARACTERGUID)_Char,(STRING)_Crime)
		THEN
		DB_CharacterCrimeDisabled(_Char,_Crime);
		CharacterDisableCrime(_Char,_Crime);
		
		IF
		DB_CharacterCrimeEnabled(_Char,_Crime)
		THEN
		NOT DB_CharacterCrimeDisabled(_Char,_Crime);
		
		IF
		DB_CharacterCrimeDisabled(_Char,_Crime)
		THEN
		NOT DB_CharacterCrimeEnabled(_Char,_Crime);
		
		//END_REGION
		
		//REGION Warning
		IF
		DB_CrimeReaction_DoNotWarn((CHARACTERGUID)_Char)
		THEN
		DB_CrimeReaction_DoNotWarn2(_Char);
		CharacterEnableCrimeWarnings(_Char,0);
		
		IF
		DB_CrimeReaction_DoNotWarn2((CHARACTERGUID)_Char)
		AND
		NOT DB_CrimeReaction_DoNotWarn(_Char)
		THEN
		NOT DB_CrimeReaction_DoNotWarn2(_Char);
		CharacterEnableCrimeWarnings(_Char,1);
		
		
		// Crime Warning Request events
		//--- Generic Warning:
		IF
		CharacterOnCrimeSensibleActionNotification(_Warner,_CrimeRegion,_CrimeID,"CRIME_OsirisReaction",_WarningDialog,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_)
		AND
		NOT DB_CrimeReaction_DoNotWarn(_Warner)
		AND
		CrimeGetType(_CrimeID,_CrimeName)
		AND
		NOT DB_CrimeReaction_CustomWarning((CHARACTERGUID)_Warner,_CrimeName,(STRING)_)
		THEN
		ProcCrimeCheckCrimeTypeForFlags(_CrimeID,_Warner,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_CrimeName,_WarningDialog);
		ProcCrimeSetupWarning(_CrimeRegion,_CrimeID,_Warner,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_WarningDialog);
		ProcCrimeWarningTryStopDialogs(_CrimeID,_Warner,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_WarningDialog);
		ProcCrimeCheckStartedWarning(_CrimeID,_Warner,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_WarningDialog);
		
		
		//--- Custom Warning:
		IF
		CharacterOnCrimeSensibleActionNotification(_Warner,_CrimeRegion,_CrimeID,"CRIME_OsirisReaction",_WarningDialog,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_)
		AND
		NOT DB_CrimeReaction_DoNotWarn(_Warner)
		//AND
		//NOT QryCrimeOnlyHasSummonCriminal(_CrimeID,_Criminal1,_Criminal2,_Criminal3,_Criminal4)
		AND
		CrimeGetType(_CrimeID,_CrimeName)
		AND
		DB_CrimeReaction_CustomWarning(_Warner,_CrimeName,_CustomDialog)
		THEN
		ProcCrimeCheckCrimeTypeForFlags(_CrimeID,_Warner,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_CrimeName,_CustomDialog);
		ProcCrimeSetupWarning(_CrimeRegion,_CrimeID,_Warner,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_CustomDialog);
		ProcCrimeWarningTryStopDialogs(_CrimeID,_Warner,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_CustomDialog);
		ProcCrimeCheckStartedWarning(_CrimeID,_Warner,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_CustomDialog);
		
		//--- No Warning
		IF
		CharacterOnCrimeSensibleActionNotification(_Warner,_CrimeRegion,_CrimeID,"CRIME_OsirisReaction",_Dialog,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_)
		AND
		DB_CrimeReaction_DoNotWarn(_Warner)
		THEN
		CrimeConfrontationDone(_CrimeID,_Warner);
		
		
		//--- 1) Prepare a DB and set flag
		PROC
		ProcCrimeCheckCrimeTypeForFlags((INTEGER)_CrimeID,(CHARACTERGUID)_Warner,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_CrimeType,(STRING)_WarningDialog)
		AND
		QryCrimeIsVandalismWithTension(_CrimeType)
		THEN
		ProcCrimeSetupCountFlag(_CrimeID,_Warner,_Criminal1,_Criminal2,_Criminal3,_Criminal4,"Vandalise",_WarningDialog);
		
		PROC
		ProcCrimeCheckCrimeTypeForFlags((INTEGER)_CrimeID,(CHARACTERGUID)_Warner,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_CrimeType,(STRING)_WarningDialog)
		AND
		NOT QryCrimeIsVandalismWithTension(_CrimeType)
		THEN
		ProcCrimeSetupCountFlag(_CrimeID,_Warner,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_CrimeType,_WarningDialog);
		
		QRY
		QryCrimeIsVandalismWithTension((STRING)_CrimeType)
		AND
		_CrimeType == "Vandalise"
		THEN
		DB_NOOP(1);
		
		QRY
		QryCrimeIsVandalismWithTension((STRING)_CrimeType)
		AND
		_CrimeType == "ItemDestroy"
		THEN
		DB_NOOP(1);
		
		PROC
		ProcCrimeSetupCountFlag((INTEGER)_CrimeID,(CHARACTERGUID)_Warner,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_CrimeType,(STRING)_WarningDialog)
		AND
		CrimeGetTension(_CrimeID,_Tension)
		AND
		_Tension > 0
		THEN
		DB_Crime_RequestedDialogWithTension(_CrimeType,_WarningDialog,_Warner,_Criminal1,_Criminal2,_Criminal3,_Criminal4);
		
		PROC
		ProcCrimeSetupCountFlag((INTEGER)_CrimeID,(CHARACTERGUID)_Warner,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_CrimeType,(STRING)_WarningDialog)
		AND
		DB_Crime_RequestedDialogWithTension(_CrimeType,_WarningDialog,_Warner,_,_,_,_)
		THEN
		ProcCrimeSetupCountFlag_ForEachCriminal(_CrimeType,_Warner,_Criminal1);
		ProcCrimeSetupCountFlag_ForEachCriminal(_CrimeType,_Warner,_Criminal2);
		ProcCrimeSetupCountFlag_ForEachCriminal(_CrimeType,_Warner,_Criminal3);
		ProcCrimeSetupCountFlag_ForEachCriminal(_CrimeType,_Warner,_Criminal4);
		
		PROC
		ProcCrimeSetupCountFlag_ForEachCriminal((STRING)_CrimeType,(CHARACTERGUID)_Warner,(CHARACTERGUID)_Criminal)
		AND
		_Criminal != NULL_00000000-0000-0000-0000-000000000000
		AND
		NOT DB_Crime_WarningCount(_,_CrimeType,_Criminal,_Warner) // DB doesn't exist yet, meaning the player has never been warned by that NPC with that dialog (i.e. for that crime)
		THEN
		DB_Crime_WarningCount(1,_CrimeType,_Criminal,_Warner);
		
		PROC
		ProcCrimeSetupCountFlag_ForEachCriminal((STRING)_CrimeType,(CHARACTERGUID)_Warner,(CHARACTERGUID)_Criminal)
		AND
		_Criminal != NULL_00000000-0000-0000-0000-000000000000
		AND
		DB_Crime_WarningCount(_Pos,_CrimeType,_Criminal,_Warner)
		AND
		IntegertoString(_Pos,_StrPos)
		AND
		StringConcatenate("GEB_CrimeWarning_",_StrPos,_Flag)
		THEN
		ObjectSetFlag(_Criminal,_Flag);
		
		IF
		DialogEnded(_Dialog,_ID)
		AND
		DB_TemporaryHostilityAfterDialog(_,_ID)
		AND
		DB_CrimeWarningHostileADs(_Dialog,_AD)
		AND
		DB_DialogNPCs(_ID,_NPC,1)
		THEN
		Proc_StartDialog(1,_AD,_NPC);
		
		//--- 2) Set variables in the Warner's script
		PROC
		ProcCrimeSetupWarning((STRING)_CrimeRegion,(INTEGER)_CrimeID,(CHARACTERGUID)_Warner,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_WarningDialog)
		THEN
		ObjectClearFlag(_Criminal1,"GEB_CrimeHasEvidenceInInventory");
		
		PROC
		ProcCrimeSetupWarning((STRING)_CrimeRegion,(INTEGER)_CrimeID,(CHARACTERGUID)_Warner,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_WarningDialog)
		AND
		CrimeGetType(_CrimeID,"Steal")
		AND
		CrimeFindEvidence(_CrimeID,_Warner,_Criminal1,_Criminal2,_Criminal3,_Criminal4,1,_,_)
		THEN
		DB_Interrogation(_Warner,_CrimeID);
		ObjectSetFlag(_Criminal1,"GEB_CrimeHasEvidenceInInventory");
		
		PROC
		ProcCrimeSetupWarning((STRING)_CrimeRegion,(INTEGER)_CrimeID,(CHARACTERGUID)_Warner,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_WarningDialog)
		THEN
		SetVarInteger(_Warner,"CrimeID",_CrimeID);
		SetVarFixedString(_Warner,"RegionID",_CrimeRegion);
		DB_Crime_SetupCriminalIndex(_CrimeID,1);
		ProcCrimeSetupValidWarningCriminals(_CrimeID,_Warner,_Criminal1);
		ProcCrimeSetupValidWarningCriminals(_CrimeID,_Warner,_Criminal2);
		ProcCrimeSetupValidWarningCriminals(_CrimeID,_Warner,_Criminal3);
		ProcCrimeSetupValidWarningCriminals(_CrimeID,_Warner,_Criminal4);
		ProcCrimeSetupNullWarningCriminals(_CrimeID,_Warner);
		
		PROC
		ProcCrimeSetupValidWarningCriminals((INTEGER)_CrimeID,(CHARACTERGUID)_Warner,(CHARACTERGUID)_Criminal)
		AND
		NOT QryCrimeCharacterIsSummonOrNull(_Criminal)
		AND
		DB_Crime_SetupCriminalIndex(_CrimeID,_Index)
		AND
		IntegertoString(_Index,_StrIndex)
		AND
		StringConcatenate("Criminal",_StrIndex,_Param)
		AND
		IntegerSum(_Index,1,_NewIndex)
		THEN
		SetVarObject(_Warner,_Param,_Criminal);
		NOT DB_Crime_SetupCriminalIndex(_CrimeID,_Index);
		DB_Crime_SetupCriminalIndex(_CrimeID,_NewIndex);
		
		PROC
		ProcCrimeSetupNullWarningCriminals((INTEGER)_CrimeID,(CHARACTERGUID)_Warner)
		AND
		DB_Crime_SetupCriminalIndex(_CrimeID,_Index)
		AND
		_Index < 5 //goes from 1 to 4
		AND
		IntegertoString(_Index,_StrIndex)
		AND
		StringConcatenate("Criminal",_StrIndex,_Param)
		AND
		IntegerSum(_Index,1,_NewIndex)
		THEN
		ClearVarObject(_Warner,_Param);
		NOT DB_Crime_SetupCriminalIndex(_CrimeID,_Index);
		DB_Crime_SetupCriminalIndex(_CrimeID,_NewIndex);
		ProcCrimeSetupNullWarningCriminals(_CrimeID,_Warner);
		
		PROC
		ProcCrimeSetupWarning((STRING)_CrimeRegion,(INTEGER)_CrimeID,(CHARACTERGUID)_Warner,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_WarningDialog)
		AND
		DB_Crime_SetupCriminalIndex(_CrimeID,_Index)
		THEN
		NOT DB_Crime_SetupCriminalIndex(_CrimeID,_Index);
		
		PROC
		ProcCrimeSetupWarning((STRING)_CrimeRegion,(INTEGER)_CrimeID,(CHARACTERGUID)_Warner,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_WarningDialog)
		AND
		GetPosition(_Warner,_x,_y,_z)
		THEN
		SetVarFloat3(_Warner,"NPCOrgPos",_x,_y,_z);
		
		PROC
		ProcCrimeSetupWarning((STRING)_CrimeRegion,(INTEGER)_CrimeID,(CHARACTERGUID)_Warner,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_WarningDialog)
		AND
		DB_EvidenceCheckInWarning(_WarningDialog) //Sets up Interrogation DB for evidence check in warning Dialog
		THEN
		DB_Crime_Interrogation(_CrimeID,_Warner,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_WarningDialog);
		
		
		//--- 3) Try to stop the warner's dialog
		PROC
		ProcCrimeWarningTryStopDialogs((INTEGER)_CrimeID,(CHARACTERGUID)_Warner,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_WarningDialog)
		AND
		DB_CrimeWarningIsAD(_WarningDialog)
		THEN
		ProcCrimeInterruptStoryDialogs(_CrimeID,_WarningDialog,0,_Warner,_Criminal1,_Criminal2,_Criminal3,_Criminal4);
		
		PROC
		ProcCrimeWarningTryStopDialogs((INTEGER)_CrimeID,(CHARACTERGUID)_Warner,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_WarningDialog)
		AND
		NOT DB_CrimeWarningIsAD(_WarningDialog)
		THEN
		ProcCrimeInterruptStoryDialogs(_CrimeID,_WarningDialog,1,_Warner,_Criminal1,_Criminal2,_Criminal3,_Criminal4);
		
		
		//--- 4) Verify if the crime dialog succeeded to start and clean up
		PROC
		ProcCrimeCheckStartedWarning((INTEGER)_CrimeID,(CHARACTERGUID)_Warner,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_WarningDialog)
		AND
		DB_Crime_FailedToInterruptStoryDialogs(_CrimeID,_WarningDialog,_Warner,_Criminal1,_Criminal2,_Criminal3,_Criminal4)
		AND
		DB_Crime_RequestedDialogWithTension(_CrimeType,_WarningDialog,_Warner,_Criminal1,_Criminal2,_Criminal3,_Criminal4)
		AND
		DB_Crime_WarningCount(_Pos,_Dialog,_Player,_Warner)
		AND
		IntegertoString(_Pos,_StrPos)
		AND
		StringConcatenate("GEB_CrimeWarning_",_StrPos,_Flag)
		THEN
		NOT DB_Crime_RequestedDialogWithTension(_CrimeType,_WarningDialog,_Warner,_Criminal1,_Criminal2,_Criminal3,_Criminal4);
		ObjectClearFlag(_Player,_Flag,0);
		
		PROC
		ProcCrimeCheckStartedWarning((INTEGER)_CrimeID,(CHARACTERGUID)_Warner,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_WarningDialog)
		AND
		DB_Crime_FailedToInterruptStoryDialogs(_CrimeID,_WarningDialog,_Warner,_Criminal1,_Criminal2,_Criminal3,_Criminal4)
		THEN
		ProcCrimeFailedToInterruptStoryDialog(_CrimeID,_Warner,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_WarningDialog);
		NOT DB_Crime_FailedToInterruptStoryDialogs(_CrimeID,_WarningDialog,_Warner,_Criminal1,_Criminal2,_Criminal3,_Criminal4);
		CrimeConfrontationDone(_CrimeID,_Warner);
		
		PROC
		ProcCrimeCheckStartedWarning((INTEGER)_CrimeID,(CHARACTERGUID)_Warner,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_WarningDialog)
		AND
		DB_Crime_FailedToInterruptStoryDialogs(_CrimeID,_WarningDialog,_Warner,_Criminal1,_Criminal2,_Criminal3,_Criminal4)
		AND
		CrimeIsContinuous(_CrimeID,1)
		THEN
		ProcCrimeFailedToInterruptStoryDialog(_CrimeID,_Warner,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_WarningDialog);
		NOT DB_Crime_FailedToInterruptStoryDialogs(_CrimeID,_WarningDialog,_Warner,_Criminal1,_Criminal2,_Criminal3,_Criminal4);
		
		PROC // Useful for custom scripting
		ProcCrimeFailedToInterruptStoryDialog((INTEGER)_CrimeID,(CHARACTERGUID)_Warner,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_WarningDialog)
		THEN
		DB_NOOP(1);
		
		PROC
		ProcCrimeCheckStartedWarning((INTEGER)_CrimeID,(CHARACTERGUID)_Warner,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_WarningDialog)
		AND
		DB_Crime_FailedToInterruptStoryDialogs(_AnyCrimeID,_AnyWarningDialog,_AnyWarner,_AnyCriminal1,_AnyCriminal2,_AnyCriminal3,_AnyCriminal4) // Clean up anything that could have failed previously
		THEN
		NOT DB_Crime_FailedToInterruptStoryDialogs(_AnyCrimeID,_AnyWarningDialog,_AnyWarner,_AnyCriminal1,_AnyCriminal2,_AnyCriminal3,_AnyCriminal4);
		
		
		//--- Count the warnings done:
		IF
		DialogEnded(_Dialog,_Inst)
		AND
		DB_Crime_RequestedDialogWithTension(_CrimeType,_Dialog,_Warner,_Criminal1,_Criminal2,_Criminal3,_Criminal4)
		AND
		DB_DialogNPCs(_Inst,_Warner,_)
		AND
		DB_DialogPlayers(_Inst,_Player,_)
		AND
		DB_Crime_WarningCount(_Pos,_CrimeType,(CHARACTERGUID)_Player,_Warner)
		AND
		IntegertoString(_Pos,_StrPos)
		AND
		StringConcatenate("GEB_CrimeWarning_",_StrPos,_Flag)
		AND
		ObjectGetFlag(_Player,_Flag,1)
		AND
		IntegerSum(_Pos,1,_NewPos)
		THEN
		NOT DB_Crime_RequestedDialogWithTension(_CrimeType,_Dialog,_Warner,_Criminal1,_Criminal2,_Criminal3,_Criminal4);
		ObjectClearFlag(_Player,_Flag,0);
		NOT DB_Crime_WarningCount(_Pos,_CrimeType,_Player,_Warner);
		DB_Crime_WarningCount(_NewPos,_CrimeType,_Player,_Warner);
		
		IF
		DB_Crime_WarningCount(_NewPos,_CrimeType,_Player,_Warner)
		AND
		_NewPos > 3
		THEN
		NOT DB_Crime_WarningCount(_NewPos,_CrimeType,_Player,_Warner);
		DB_Crime_WarningCount(3,_CrimeType,_Player,_Warner);
		
		IF
		DialogEnded(_Dialog,_Inst)
		AND
		DB_CrimeWarner(_CrimeID,_Warner,_Dialog)
		AND
		DB_DialogNPCs(_Inst,_Warner,_)
		THEN
		CrimeConfrontationDone(_CrimeID,_Warner);
		NOT DB_CrimeWarner(_CrimeID,_Warner,_Dialog);
		
		IF
		AutomatedDialogEnded(_Dialog,_Inst)
		AND
		DB_Crime_RequestedDialogWithTension(_CrimeType,_Dialog,_Warner,_Criminal1,_Criminal2,_Criminal3,_Criminal4)
		AND
		DB_DialogNPCs(_Inst,_Warner,_)
		AND
		DB_Crime_WarningAD_Target(_CrimeType,_Warner,_Criminal1)
		AND
		DB_Crime_WarningCount(_Pos,_CrimeType,(CHARACTERGUID)_Player,_Warner)
		AND
		IntegertoString(_Pos,_StrPos)
		AND
		StringConcatenate("GEB_CrimeWarning_",_StrPos,_Flag)
		AND
		ObjectGetFlag(_Player,_Flag,1)
		AND
		IntegerSum(_Pos,1,_NewPos)
		THEN
		NOT DB_Crime_RequestedDialogWithTension(_CrimeType,_Dialog,_Warner,_Criminal1,_Criminal2,_Criminal3,_Criminal4);
		ObjectClearFlag(_Player,_Flag,0);
		NOT DB_Crime_WarningCount(_Pos,_CrimeType,_Player,_Warner);
		DB_Crime_WarningCount(_NewPos,_CrimeType,_Player,_Warner);
		
		IF
		AutomatedDialogEnded(_Dialog,_Inst)
		AND
		DB_DialogNPCs(_Inst,_Warner,_)
		AND
		DB_Crime_WarningAD_Target(_CrimeType,(CHARACTERGUID)_Warner,(CHARACTERGUID)_TargetPlayer)
		THEN
		NOT DB_Crime_WarningAD_Target(_CrimeType,_Warner,_TargetPlayer);
		
		PROC
		ProcHandleCrimeDialog((CHARACTERGUID)_Warner,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_Dialog,0,(INTEGER)_MarkForInteractive)
		THEN
		DB_CrimeDialogStartFailed(_Warner,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_Dialog);
		
		IF
		OnCrimeResolved(_CrimeID,_Victim,_Criminal1,_Criminal2,_Criminal3,_Criminal4)
		AND
		DB_CrimeDialogStartFailed(_Warner,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_Dialog)
		AND
		DB_Crime_RequestedDialogWithTension(_CrimeType,_Dialog,_Warner,_Criminal1,_Criminal2,_Criminal3,_Criminal4)
		AND
		DB_Crime_WarningCount(_Pos,_CrimeType,(CHARACTERGUID)_Player,_Warner)
		AND
		IntegertoString(_Pos,_StrPos)
		AND
		StringConcatenate("GEB_CrimeWarning_",_StrPos,_Flag)
		AND
		ObjectGetFlag(_Player,_Flag,1)
		AND
		IntegerSum(_Pos,1,_NewPos)
		THEN
		NOT DB_CrimeDialogStartFailed(_Warner,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_Dialog);
		NOT DB_Crime_RequestedDialogWithTension(_CrimeType,_Dialog,_Warner,_Criminal1,_Criminal2,_Criminal3,_Criminal4);
		ObjectClearFlag(_Player,_Flag,0);
		NOT DB_Crime_WarningAD_Target(_CrimeType,_Warner,_Player);
		NOT DB_Crime_WarningCount(_Pos,_CrimeType,_Player,_Warner);
		DB_Crime_WarningCount(_NewPos,_CrimeType,_Player,_Warner);
		
		
		//REGION Prepare the characters for the dialog
		PROC
		ProcHandleCrimeDialog((CHARACTERGUID)_Warner,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_WarningDialog,1,(INTEGER)_MarkForInteractive)
		AND
		GetPosition(_Warner,_x,_y,_z)
		THEN
		SetVarFloat3(_Warner,"NPCOrgPos",_x,_y,_z);
		
		PROC
		ProcHandleCrimeDialog((CHARACTERGUID)_Warner,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_WarningDialog,1,1)
		THEN
		CharacterLookAt(_Warner,_Criminal1,0);
		CharacterLookAt(_Criminal1,_Warner,0);
		CharacterMakeStoryNpc(_Warner,1);
		CharacterMakeStoryNpc(_Criminal1,1);
		CharacterMakeStoryNpc(_Criminal2,1);
		CharacterMakeStoryNpc(_Criminal3,1);
		CharacterMakeStoryNpc(_Criminal4,1);
		
		PROC
		ProcHandleCrimeDialog((CHARACTERGUID)_Warner,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_WarningDialog,1,0)
		THEN
		CharacterLookAt(_Warner,_Criminal1,0);
		
		PROC
		ProcHandleCrimeDialog((CHARACTERGUID)_Warner,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_WarningDialog,1,_)
		AND
		DB_CRIME_ForbiddenStatus(_Status)
		AND
		HasActiveStatus(_Warner,_Status,1)
		THEN
		RemoveStatus(_Warner,_Status);
		
		IF
		CharacterLeftParty(_Summon)
		AND
		ObjectExists(_Summon,1)
		AND
		IsTagged(_Summon,"SUMMON",1)
		AND
		DB_Crime_WarningCount(_Pos,_CrimeType,_Summon,_Warner)
		THEN
		NOT DB_Crime_WarningCount(_Pos,_CrimeType,_Summon,_Warner);
		
		//END_REGION
		
		//REGION Check Prison Cell in Warning
		
		IF
		CharacterOnCrimeSensibleActionNotification(_Warner,_CrimeRegion,_CrimeID,"CRIME_OsirisReaction",_Dialog,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_)
		THEN
		ObjectClearFlag(_Warner,"GEB_Arrest_HavePrison",0);
		
		IF
		CharacterOnCrimeSensibleActionNotification(_Warner,_CrimeRegion,_CrimeID,"CRIME_OsirisReaction",_Dialog,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_)
		AND
		DB_RegionPrison(_CrimeRegion,_)
		THEN
		ObjectSetFlag(_Warner,"GEB_Arrest_HavePrison");
		
		//END_REGION
		//END_REGION
		
		//REGION Summon check
		
		//--- Only summon (or null) in criminals
		QRY
		QryCrimeOnlyHasSummonCriminal((CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4)
		AND
		QryCrimeCharacterIsSummonOrNull(_Criminal1)
		AND
		QryCrimeCharacterIsSummonOrNull(_Criminal2)
		AND
		QryCrimeCharacterIsSummonOrNull(_Criminal3)
		AND
		QryCrimeCharacterIsSummonOrNull(_Criminal4)
		THEN
		DB_NOOP(1);
		
		QRY
		QryCrimeCharacterIsSummonOrNull((CHARACTERGUID)_Char)
		AND
		QRY_CharacterIsNull(_Char)
		THEN
		DB_NOOP(1);
		
		QRY
		QryCrimeCharacterIsSummonOrNull((CHARACTERGUID)_Char)
		AND
		NOT QRY_CharacterIsNull(_Char)
		AND
		IsTagged(_Char,"SUMMON",1)
		THEN
		DB_NOOP(1);
		
		
		QRY
		QryCrimeAssailantIsNotSummon((CHARACTERGUID)_Char,(CHARACTERGUID)_Summon)
		AND
		_Char == _Summon
		THEN
		DB_NOOP(1);
		
		QRY
		QryCrimeAssailantIsNotSummon((CHARACTERGUID)_Char,(CHARACTERGUID)_Summon)
		AND
		QRY_CharacterIsNull(_Summon)
		THEN
		DB_NOOP(1);
		
		
		//--- Continuous summon crime
		IF
		CharacterJoinedParty(_Char)
		AND
		IsTagged(_Char,"SUMMON",1)
		THEN
		CharacterRegisterCrime(_Char,"ActiveSummon",NULL_00000000-0000-0000-0000-000000000000,NULL_00000000-0000-0000-0000-000000000000,0);
		
		IF
		CharacterLeftParty(_Char)
		AND
		IsTagged(_Char,"SUMMON",1)
		THEN
		CharacterStopCrime(_Char,"ActiveSummon",NULL_00000000-0000-0000-0000-000000000000);
		
		//END_REGION
		
		//REGION Investigation
		// Override crime scene location (needs to be exact to ensure that e.g. in case of assault,
		// we don't have a crime scene too far for the victim to see or hear) with a separate investigation
		// location if appropriate
		IF
		StoryEvent((CHARACTERGUID)_Investigator,"CRIME_SetCrimeInvestigationPos")
		AND
		GetVarInteger(_Investigator,"CrimeID",_CrimeID)
		AND
		DB_CRIME_CrimeInvestigationPos(_CrimeID,_X,_Y,_Z)
		THEN
		// In case it's an alternate position, run rather than walk, because it means
		// that we probably cannot find anything in the default location
		SetVarInteger(_Investigator,"bool_RunToInvestigationScene",1);
		SetVarFloat3(_Investigator,"CrimePos",_X,_Y,_Z);
		
		IF
		StoryEvent((CHARACTERGUID)_Investigator,"CRIME_SetCrimeInvestigationPos")
		THEN
		CharacterSetReactionPriority(_Investigator,"WalkToCrimeScene",30000);
		//END_REGION
		
		//REGION Interrogation
		
		IF
		CrimeInterrogationRequest(_RegionID,_ID,_Interrogator,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_Dialog)
		THEN
		ObjectClearFlag(_Interrogator,"GEB_Arrest_HavePrison",0);
		
		IF
		CrimeInterrogationRequest(_RegionID,_ID,_Interrogator,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_Dialog)
		AND
		DB_RegionPrison((STRING)_RegionID,(TRIGGERGUID)_)
		THEN
		ObjectSetFlag(_Interrogator,"GEB_Arrest_HavePrison");
		
		PROC
		ProcCrimeCheckInterrogationDialog((STRING)_RegionID,(INTEGER)_ID,(CHARACTERGUID)_Interrogator,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_Dialog)
		AND
		IsTagged(_Interrogator,"ANIMAL",0)
		AND
		IsTagged(_Interrogator,"KID",0)
		THEN
		DB_Crime_InterrogationStarted(_ID,_Interrogator);
		ProcStartInterrogationDialog(_ID,_Interrogator,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_Dialog);
		
		PROC
		ProcCrimeCheckInterrogationDialog((STRING)_RegionID,(INTEGER)_ID,(CHARACTERGUID)_Interrogator,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_Dialog)
		AND
		NOT DB_Crime_InterrogationStarted(_ID,_Interrogator)
		AND
		IsTagged(_Interrogator,"ANIMAL",1)
		THEN
		DB_Crime_InterrogationStarted(_ID,_Interrogator);
		CrimeInterrogationDone(_ID,_Interrogator,1,_Criminal1,_Criminal2,_Criminal3,_Criminal4);
		
		PROC
		ProcCrimeCheckInterrogationDialog((STRING)_RegionID,(INTEGER)_ID,(CHARACTERGUID)_Interrogator,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_Dialog)
		AND
		NOT DB_Crime_InterrogationStarted(_ID,_Interrogator)
		AND
		IsTagged(_Interrogator,"AGGRESSIVEANIMAL",1)
		THEN
		DB_Crime_InterrogationStarted(_ID,_Interrogator);
		Proc_StartDialog(1,"GEB_AD_Noticed_AnimalAttackedAnimal",_Interrogator);
		ProcMakeNPCHostile(_Interrogator,_Criminal1);
		ProcMakeNPCHostile(_Interrogator,_Criminal2);
		ProcMakeNPCHostile(_Interrogator,_Criminal3);
		ProcMakeNPCHostile(_Interrogator,_Criminal4);
		
		PROC
		ProcCrimeCheckInterrogationDialog((STRING)_RegionID,(INTEGER)_ID,(CHARACTERGUID)_Interrogator,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_Dialog)
		AND
		NOT DB_Crime_InterrogationStarted(_ID,_Interrogator)
		AND
		IsTagged(_Interrogator,"KID",1)
		THEN
		DB_Crime_InterrogationStarted(_ID,_Interrogator);
		CrimeInterrogationDone(_ID,_Interrogator,1,_Criminal1,_Criminal2,_Criminal3,_Criminal4);
		
		PROC
		ProcCrimeCheckInterrogationDialog((STRING)_RegionID,(INTEGER)_ID,(CHARACTERGUID)_Interrogator,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_Dialog)
		THEN
		NOT DB_Crime_InterrogationStarted(_ID,_Interrogator);
		
		
		//--- Interrogation requested:
		IF
		CrimeInterrogationRequest(_RegionID,_ID,_Interrogator,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_Dialog)
		THEN
		DB_InterrogationRequested(_RegionID,_ID,_Interrogator,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_Dialog);
		CharacterDisableAllCrimes(_Interrogator);
		SetHasDialog(_Interrogator,0);	//TODO: this is not great, we assume these guys have dialogs
		CharacterMoveToAndTalk(_Interrogator,_Criminal1,"",0,"GEB_InterrogationMove",1,6.0);
		
		IF
		CharacterMoveToAndTalkRequestDialog(_Arrester,(CHARACTERGUID)_Criminal,_,_,"GEB_InterrogationMove")
		AND
		DB_InterrogationRequested(_RegionID,_ID,_Arrester,_Criminal,_Criminal2,_Criminal3,_Criminal4,_Dialog)
		THEN
		ProcCrimeCheckInterrogationDialog(_RegionID,_ID,_Arrester,_Criminal,_Criminal2,_Criminal3,_Criminal4,_Dialog);
		
		IF
		CharacterMoveToAndTalkFailed(_Arrester,_,"GEB_InterrogationMove")
		AND
		DB_InterrogationRequested(_RegionID,_ID,_Arrester,_Criminal,_Criminal2,_Criminal3,_Criminal4,_Dialog)
		THEN
		PROC_HandleFailedInterrogation(_Arrester,_ID);
		
		IF
		CharacterMoveToAndTalkRequestDialogFailedEvent(_Arrester,_,"GEB_InterrogationMove")
		AND
		DB_InterrogationRequested(_RegionID,_ID,_Arrester,_Criminal,_Criminal2,_Criminal3,_Criminal4,_Dialog)
		THEN
		PROC_HandleFailedInterrogation(_Arrester,_ID);
		
		PROC
		PROC_HandleFailedInterrogation((CHARACTERGUID)_Arrester,(INTEGER)_ID)
		AND
		DB_InterrogationRequested(_RegionID,_ID,_Arrester,_Criminal,_Criminal2,_Criminal3,_Criminal4,_Dialog)
		THEN
		PROC_CancelInterrogation(_Arrester,_ID,0,_Criminal,_Criminal2,_Criminal3,_Criminal4);
		
		PROC
		PROC_CancelInterrogation((CHARACTERGUID)_Arrester,(INTEGER)_ID,(INTEGER)_FoundEvidence,(CHARACTERGUID)_Criminal,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4)
		THEN
		CrimeInterrogationDone(_ID,_Arrester,_FoundEvidence,_Criminal,_Criminal2,_Criminal3,_Criminal4);
		ProcCleanUpInterrogation(_Arrester);
		NOT DB_IgnoreInterrogation(_Arrester,NULL_00000000-0000-0000-0000-000000000000);
		ProcObjectTimer(_Arrester,"GEB_RestoreInterrogation",4500);
		CrimeEnableInterrogation(_Arrester,0);
		
		PROC //allow others to interrogate them if no evidence was found
		PROC_CancelInterrogation((CHARACTERGUID)_Arrester,(INTEGER)_ID,0,(CHARACTERGUID)_Criminal,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4)
		THEN
		CrimeResetInterrogationForCriminals(_ID,_Criminal,_Criminal2,_Criminal3,_Criminal4);
		
		PROC
		ProcObjectTimerFinished((CHARACTERGUID)_Arrester,"GEB_RestoreInterrogation")
		AND
		NOT DB_CrimeReaction_DoNotInterrogate(_Arrester)
		THEN
		CrimeEnableInterrogation(_Arrester,1);
		
		PROC
		ProcCleanUpInterrogation((CHARACTERGUID)_Arrester)
		AND
		DB_InterrogationRequested(_RegionID,_ID,_Arrester,_Criminal,_Criminal2,_Criminal3,_Criminal4,_Dialog)
		THEN
		ProcRestoreGenericBehaviour(_Arrester);
		SetHasDialog(_Arrester,1);
		NOT DB_InterrogationRequested(_RegionID,_ID,_Arrester,_Criminal,_Criminal2,_Criminal3,_Criminal4,_Dialog);
		
		IF
		CharacterMoveToAndTalkRequestDialog(_Arrester,(CHARACTERGUID)_Criminal,_,_,"GEB_InterrogationMove")
		AND
		NOT DB_InterrogationRequested(_,_,_Arrester,_Criminal,_,_,_,_)
		THEN
		CharacterMoveToAndTalkRequestDialogFailed(_Arrester,_Criminal,"GEB_InterrogationMove");
		
		IF
		DB_Crime_FailedToInterruptStoryDialogs(_CrimeID,_ArrestDialog,_Arrester,_Criminal,_Criminal2,_Criminal3,_Criminal4)
		AND
		DB_InterrogationRequested(_RegionID,_CrimeID,_Arrester,_Criminal,_Criminal2,_Criminal3,_Criminal4,_ArrestDialog)
		THEN
		CharacterMoveToAndTalkRequestDialogFailed(_Arrester,_Criminal,"GEB_InterrogationMove");
		
		IF
		DB_Crime_InterrogationStarted(_CrimeID,_Arrester)
		AND
		DB_InterrogationRequested(_RegionID,_CrimeID,_Arrester,_Criminal,_Criminal2,_Criminal3,_Criminal4,_ArrestDialog)
		THEN
		ProcCleanUpInterrogation(_Arrester);
		
		IF
		OnCrimeResolved(_CrimeID,_,_,_,_,_)
		AND
		DB_InterrogationRequested(_,_CrimeID,_Arrester,_,_,_,_,_)
		THEN
		ProcCleanUpInterrogation(_Arrester);
		
		//--- Start dialog:
		PROC
		ProcStartInterrogationDialog((INTEGER)_CrimeID,(CHARACTERGUID)_Interrogator,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_Dialog)
		AND
		_Dialog == ""
		THEN
		ProcDoStartInterrogationDialog(_CrimeID,_Interrogator,_Criminal1,_Criminal2,_Criminal3,_Criminal4,"GEB_Interrogation");
		
		PROC
		ProcStartInterrogationDialog((INTEGER)_CrimeID,(CHARACTERGUID)_Interrogator,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_Dialog)
		AND
		_Dialog != ""
		THEN
		ProcDoStartInterrogationDialog(_CrimeID,_Interrogator,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_Dialog);
		
		PROC
		ProcDoStartInterrogationDialog((INTEGER)_,(CHARACTERGUID)_Interrogator,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_Dialog)
		AND
		DB_Interrogation(_Interrogator,_CrimeID)
		THEN
		NOT DB_Interrogation(_Interrogator,_CrimeID); // This Database is set on CRIME_Allow_Search
		
		PROC
		ProcDoStartInterrogationDialog((INTEGER)_CrimeID,(CHARACTERGUID)_Interrogator,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_Dialog)
		THEN
		ProcCrimeInterruptStoryDialogs(_CrimeID,_Dialog,1,_Interrogator,_Criminal1,_Criminal2,_Criminal3,_Criminal4);
		ProcCrimeCheckInterrogationDialogSucceeded(_CrimeID,_Interrogator,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_Dialog);
		
		PROC
		ProcCrimeCheckInterrogationDialogSucceeded((INTEGER)_CrimeID,(CHARACTERGUID)_Interrogator,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_Dialog)
		AND
		NOT DB_Crime_FailedToInterruptStoryDialogs(_CrimeID,_Dialog,_Interrogator,_Criminal1,_Criminal2,_Criminal3,_Criminal4)
		THEN
		DB_Crime_Interrogation(_CrimeID,_Interrogator,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_Dialog);
		DB_Interrogation(_Interrogator,_CrimeID);
		
		PROC
		ProcCrimeCheckInterrogationDialogSucceeded((INTEGER)_CrimeID,(CHARACTERGUID)_Interrogator,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_Dialog)
		AND
		DB_Crime_FailedToInterruptStoryDialogs(_CrimeID,_Dialog,_Interrogator,_Criminal1,_Criminal2,_Criminal3,_Criminal4)
		THEN
		CrimeInterrogationDone(_CrimeID,_Interrogator,1,_Criminal1,_Criminal2,_Criminal3,_Criminal4);
		
		IF
		ObjectFlagSet("CRIME_Allow_Search",(CHARACTERGUID)_Interrogator,_ID)
		THEN
		ObjectClearFlag(_Interrogator,"CRIME_Allow_Search",_ID);
		ObjectClearFlag(_Interrogator,"CRIME_EvidenceFound",_ID);
		ObjectClearFlag(_Interrogator,"CRIME_GuiltFound",_ID);
		ObjectClearFlag(_Interrogator,"CRIME_FoundEvidenceCurrentCrime",_ID);
		ObjectClearFlag(_Interrogator,"CRIME_FoundGuiltyPlayer",_ID);
		
		IF
		ObjectFlagSet("CRIME_Allow_Search",(CHARACTERGUID)_Interrogator,_ID)
		AND
		DB_Crime_Interrogation(_CrimeID,_Interrogator,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_)
		AND
		CrimeFindEvidence(_CrimeID,_Interrogator,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_FoundEvidenceCurrentCrime,_FoundEvidence,_FoundGuilty)
		AND
		QRY_GetCriminalGuilty(_CrimeID,_Interrogator,_FoundEvidenceCurrentCrime,_FoundEvidence,_FoundGuilty)
		THEN
		DB_Interrogation(_Interrogator,_CrimeID);
		
		IF
		ObjectFlagSet("CRIME_Resist_Search",(CHARACTERGUID)_Character,_ID)
		THEN
		ObjectClearFlag(_Character,"CRIME_Resist_Search",_ID);
		DB_Crime_CombatAfterDialog(_ID);
		
		QRY
		QRY_GetCriminalGuilty((INTEGER)_CrimeID,(CHARACTERGUID)_Interrogator,(INTEGER)_FoundEvidenceCurrentCrime,(INTEGER)_FoundEvidence,(INTEGER)_FoundGuilty)
		AND
		_FoundEvidence == 1
		THEN
		ObjectSetFlag(_Interrogator,"CRIME_EvidenceFound",0);
		
		QRY
		QRY_GetCriminalGuilty((INTEGER)_CrimeID,(CHARACTERGUID)_Interrogator,(INTEGER)_FoundEvidenceCurrentCrime,(INTEGER)_FoundEvidence,(INTEGER)_FoundGuilty)
		AND
		_FoundGuilty == 1
		THEN
		ObjectSetFlag(_Interrogator,"CRIME_GuiltFound",0);
		
		QRY
		QRY_GetCriminalGuilty((INTEGER)_CrimeID,(CHARACTERGUID)_Interrogator,(INTEGER)_FoundEvidenceCurrentCrime,(INTEGER)_FoundEvidence,(INTEGER)_FoundGuilty)
		AND
		_FoundEvidenceCurrentCrime == 1
		THEN
		ObjectSetFlag(_Interrogator,"CRIME_FoundEvidenceCurrentCrime",0);
		
		//Resolve Crime
		IF
		ObjectFlagSet("CRIME_FoundGuiltyPlayer",(CHARACTERGUID)_Interrogator,_ID)
		AND
		DB_Interrogation(_Interrogator,_CrimeID)
		THEN
		DB_EvidenceFound(_CrimeID,_Interrogator);
		//DebugText(_Interrogator,"Evidence Found");
		
		//Give Evidance Back to investigator
		IF
		ObjectFlagSet("CRIME_ReturnGoodsToOnwer",(CHARACTERGUID)_Interrogator,_ID)
		AND
		DB_Interrogation(_Interrogator,_CrimeID)
		THEN
		ObjectClearFlag(_Interrogator,"CRIME_ReturnGoodsToOnwer",_ID);
		CrimeTransferEvidenceTo(_CrimeID,_Interrogator);
		
		IF
		ObjectFlagSet("CRIME_CallGuardsFromDialog",(CHARACTERGUID)_Interrogator,_ID) // When A Civilian finds a Thief in Interrogation
		AND
		DB_DialogPlayers(_ID,_Criminal,1)
		THEN
		ObjectClearFlag(_Interrogator,"CRIME_CallGuardsFromDialog");
		DB_Crime_CallingGuards(_Interrogator,_Criminal,_ID);
		
		IF
		DialogEnded(_Dialog,_ID)
		AND
		DB_DialogNPCs(_ID,_Interrogator,1)
		AND
		DB_Crime_Interrogation(_CrimeID,(CHARACTERGUID)_Interrogator,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_Dialog)
		AND
		NOT DB_Crime_CallingGuards(_Interrogator,_,_ID)
		THEN
		ProcCheckInterrogationDone(_Interrogator,_Dialog);
		
		PROC
		ProcCheckInterrogationDone((CHARACTERGUID)_Interrogator,(STRING)_Dialog)
		AND
		NOT DB_EvidenceCheckInWarning(_Dialog)
		AND
		DB_Crime_Interrogation(_CrimeID,_Interrogator,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_Dialog)
		THEN
		NOT DB_Crime_Interrogation(_CrimeID,_Interrogator,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_Dialog);
		ProcStopInterrogation(_CrimeID,_Interrogator,_Criminal1,_Criminal2,_Criminal3,_Criminal4);
		
		
		IF
		DialogEnded(_Dialog,_ID)
		AND
		DB_Crime_CallingGuards(_Interrogator,_Criminal,_ID)
		AND
		DB_Interrogation(_Interrogator,_CrimeID)
		THEN
		SetVarObject(_Interrogator,"Criminal1",(CHARACTERGUID)_Criminal); // TODO REMOVE THIS HACK!
		SetVarString(_Interrogator,"ArrestDialog","GEB_Arrest");
		SetVarInteger(_Interrogator,"CrimeID",_CrimeID);
		SetStoryEvent(_Interrogator,"CRIME_CallGuardsFromDialog");
		NOT DB_Crime_CallingGuards(_Interrogator,_Criminal,_ID);
		
		IF
		ObjectFlagSet("CRIME_FleeHelpFromDialog",(CHARACTERGUID)_Interrogator,_ID) // When A Kid finds a Criminal in Interrogation
		AND
		DB_DialogPlayers(_ID,_Criminal,1)
		THEN
		DB_Crime_FleeCallforHelp(_Interrogator,_Criminal,_ID);
		
		IF
		DialogEnded(_Dialog,_ID)
		AND
		DB_Crime_FleeCallforHelp(_Interrogator,_Criminal,_ID)
		AND
		DB_Interrogation(_Interrogator,_CrimeID)
		THEN
		SetVarObject(_Interrogator,"Criminal1",(CHARACTERGUID)_Criminal); // TODO REMOVE THIS HACK!
		SetVarString(_Interrogator,"ArrestDialog","GEB_Arrest");
		SetVarInteger(_Interrogator,"CrimeID",_CrimeID);
		SetStoryEvent(_Interrogator,"CRIME_FleeHelpFromDialog");
		//CrimeInterrogationDone(_CrimeID,_Interrogator,1);
		NOT DB_Crime_FleeCallforHelp(_Interrogator,_Criminal,_ID);
		
		IF
		DialogEnded(_Dialog,_ID)
		AND
		DB_DialogPlayers(_ID,_Player,1)
		AND
		ObjectGetFlag(_Player,"CRIME_PersuasionFailed",1)
		THEN
		ObjectClearFlag(_Player,"CRIME_PersuasionFailed",0);
		
		// Stop Investigation when join combat
		
		
		//REGION Dialog Ended
		IF
		DialogEnded(_Dialog,_ID)
		AND
		DB_Crime_CombatAfterDialog(_ID)
		AND
		DB_DialogNPCs(_ID,_Interrogator,1)
		AND
		DB_DialogPlayers(_ID,_Player,_)
		THEN
		ProcMakeNPCHostile((CHARACTERGUID)_Player,(CHARACTERGUID)_Interrogator);
		NOT DB_Crime_CombatAfterDialog(_ID);
		
		IF
		DialogEnded(_Dialog,_ID)
		AND
		DB_DialogNPCs(_ID,_Interrogator,1)
		AND
		DB_Crime_Interrogation(_CrimeID,(CHARACTERGUID)_Interrogator,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_Dialog)
		THEN
		NOT DB_Crime_Interrogation(_CrimeID,(CHARACTERGUID)_Interrogator,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_Dialog);
		
		PROC
		ProcStopInterrogation((INTEGER)_CrimeID,(CHARACTERGUID)_Interrogator,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4)
		AND
		DB_EvidenceFound(_CrimeID,_Interrogator)
		THEN
		CrimeInterrogationDone(_CrimeID,_Interrogator,1,_Criminal1,_Criminal2,_Criminal3,_Criminal4);
		
		PROC
		ProcStopInterrogation((INTEGER)_CrimeID,(CHARACTERGUID)_Interrogator,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4)
		AND
		NOT DB_EvidenceFound(_CrimeID,_Interrogator)
		THEN
		CrimeInterrogationDone(_CrimeID,_Interrogator,0,_Criminal1,_Criminal2,_Criminal3,_Criminal4);
		
		PROC
		ProcStopInterrogation((INTEGER)_CrimeID,(CHARACTERGUID)_Interrogator,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4)
		THEN
		NOT DB_EvidenceFound(_CrimeID,_Interrogator);
		//END_REGION
		
		//REGION Saw Criminal In Combat While Invesigating
		IF
		OnCrimeSawCriminalInCombat(_CrimeID,_Witness,_Criminal)
		AND
		IsTagged(_Witness,"CIVILIAN",0)
		AND
		IsTagged(_Witness,"ANIMAL",0) //Animals should not investigate should be disabled in excel
		THEN
		ProcMakeNPCHostile(_Witness,_Criminal);
		//END_REGION
		//END_REGION
		
		//REGION Trespassing
		
		//--- Registering DB
		IF
		DB_TrespassTrigger((TRIGGERGUID)_Trigger,(TRIGGERGUID)_OutTrigger)
		THEN
		DB_TrespassTrigger((TRIGGERGUID)_Trigger,(TRIGGERGUID)_OutTrigger,"Trespassing",(CHARACTERGUID)NULL_00000000-0000-0000-0000-000000000000);
		
		IF
		DB_TrespassTrigger((TRIGGERGUID)_Trigger,(TRIGGERGUID)_OutTrigger,(STRING)_CrimeName)
		THEN
		DB_TrespassTrigger((TRIGGERGUID)_Trigger,(TRIGGERGUID)_OutTrigger,(STRING)_CrimeName,(CHARACTERGUID)NULL_00000000-0000-0000-0000-000000000000);
		
		IF
		DB_TrespassTrigger((TRIGGERGUID)_Trigger,(TRIGGERGUID)_OutTrigger,(STRING)_CrimeName,(CHARACTERGUID)_Victim)
		THEN
		DB_TrespassingCrimes((STRING)_CrimeName);
		
		IF
		DB_TrespassTrigger((TRIGGERGUID)_Trigger,(TRIGGERGUID)_,_,_)
		THEN
		ProcTriggerRegisterForPlayers(_Trigger);
		
		
		//--- Removing:
		PROC
		ProcRemoveDBTrespassTrigger((TRIGGERGUID)_Trigger,(TRIGGERGUID)_OutTrigger)
		THEN
		ProcRemoveDBTrespassTrigger((TRIGGERGUID)_Trigger,(TRIGGERGUID)_OutTrigger,(CHARACTERGUID)NULL_00000000-0000-0000-0000-000000000000);
		
		PROC
		ProcRemoveDBTrespassTrigger((TRIGGERGUID)_Trigger,(TRIGGERGUID)_OutTrigger,(CHARACTERGUID)_Victim)
		AND
		DB_TrespassTrigger(_Trigger,_OutTrigger,_CrimeName,_Victim)
		AND
		DB_IsPlayer(_Player)
		THEN
		CharacterStopCrime(_Player, _CrimeName, _Trigger);
		
		PROC
		ProcRemoveDBTrespassTrigger((TRIGGERGUID)_Trigger,(TRIGGERGUID)_OutTrigger,(CHARACTERGUID)_Victim)
		AND
		DB_TrespassTrigger(_Trigger,_OutTrigger,_CrimeName)
		AND
		DB_IsPlayer(_Player)
		THEN
		CharacterStopCrime(_Player, _CrimeName, _Trigger);
		
		PROC
		ProcRemoveDBTrespassTrigger((TRIGGERGUID)_Trigger,(TRIGGERGUID)_OutTrigger,(CHARACTERGUID)_Victim)
		AND
		DB_TrespassTrigger(_Trigger,_OutTrigger)
		AND
		DB_IsPlayer(_Player)
		THEN
		CharacterStopCrime(_Player, "Trespassing", _Trigger);
		
		PROC
		ProcRemoveDBTrespassTrigger((TRIGGERGUID)_Trigger,(TRIGGERGUID)_OutTrigger,(CHARACTERGUID)_Victim)
		AND
		DB_TrespassTrigger(_Trigger,_OutTrigger,_CrimeName,_Victim)
		THEN
		NOT DB_TrespassTrigger(_Trigger,_OutTrigger,_CrimeName,_Victim);
		
		PROC
		ProcRemoveDBTrespassTrigger((TRIGGERGUID)_Trigger,(TRIGGERGUID)_OutTrigger,(CHARACTERGUID)_Victim)
		AND
		DB_TrespassTrigger(_Trigger,_OutTrigger)
		THEN
		NOT DB_TrespassTrigger(_Trigger,_OutTrigger);
		
		PROC
		ProcRemoveDBTrespassTrigger((TRIGGERGUID)_Trigger,(TRIGGERGUID)_OutTrigger,(CHARACTERGUID)_Victim)
		AND
		DB_TrespassTrigger(_Trigger,_OutTrigger,_CrimeName)
		THEN
		NOT DB_TrespassTrigger(_Trigger,_OutTrigger,_CrimeName);
		
		//--- Register/stop crime
		IF
		CharacterEnteredTrigger(_Player,_Trigger)
		AND
		DB_TrespassTrigger(_Trigger,_,_CrimeName,_Victim)
		AND
		DB_IsPlayer(_Player)
		AND
		NOT DB_CharacterCrimeDisabled(_Player,_CrimeName)
		THEN
		ProcCharacterRegisterCrime(_Player, _CrimeName, _Trigger, _Victim, 0, _Victim);
		
		PROC
		ProcCharacterRegisterCrime((CHARACTERGUID)_Char,(STRING)_CrimeType,(GUIDSTRING)_Evidence,(CHARACTERGUID)_CrimeWitness,(INTEGER)_CrimeID,(CHARACTERGUID)_Victim)
		AND
		DB_TrespassTrigger((TRIGGERGUID)_Evidence,_,_CrimeType,_Victim)
		AND
		NOT QRY_CRIME_BlockRegisterCrime(_Char, _CrimeType, _Evidence, _CrimeWitness, _CrimeID, _Victim)
		THEN
		DB_PlayerTrespassing(_Char,_Evidence);
		
		IF
		CharacterLeftTrigger(_Player,_Trigger)
		AND
		DB_TrespassTrigger(_Trigger,_,_CrimeName,_Victim)
		THEN
		CharacterStopCrime(_Player,_CrimeName,_Trigger);
		NOT DB_PlayerTrespassing(_Player,_Trigger);
		
		IF
		ObjectFlagSet("TeleportOutOfTrespass",_Player,_Inst)
		THEN
		DB_CrimeTeleportOutOfTrespass(_Player,_Inst);
		
		IF
		DialogEnded(_,_ID)
		AND
		DB_DialogPlayers(_ID,_FirstPlayer,1)
		AND
		DB_PlayerTrespassing((CHARACTERGUID)_FirstPlayer,_Trigger)
		AND
		DB_CrimeTeleportOutOfTrespass(_FirstPlayer,_ID)
		AND
		DB_TrespassTrigger(_Trigger,_Outside,_,_)
		AND
		DB_DialogPlayers(_ID,_Player,_)
		THEN
		TeleportTo(_Player,_Outside,"",1);
		NOT DB_PlayerTrespassing(_FirstPlayer,_Trigger);
		NOT DB_CrimeTeleportOutOfTrespass(_Player,_ID);
		ObjectClearFlag(_Player,"TeleportOutOfTrespass",0);
		CharacterFlushQueue((CHARACTERGUID)_Player);
		FireOsirisEvents();
		
		IF
		DialogEnded(_,_ID)
		AND
		DB_CrimeTeleportOutOfTrespass(_Player,_ID)
		THEN
		NOT DB_CrimeTeleportOutOfTrespass(_Player,_ID);
		ObjectClearFlag(_Player,"TeleportOutOfTrespass",0);
		
		//////////////////////////////
		// Unavailable Fallback lead
		IF
		CharacterSelectedAsBestUnavailableFallbackLead(_NPC,_RegionID,_CrimeID,_BusyCrimeID,_Criminal1,_Criminal2,_Criminal3,_Criminal4)
		AND
		NOT QryCrimeOnlyHasSummonCriminal(_Criminal1,_Criminal2,_Criminal3,_Criminal4)
		AND
		CrimeGetType(_CrimeID,_CrimeName)
		AND
		DB_TrespassingCrimes(_CrimeName)
		THEN
		ProcCrimeTrespassingCheckDetection(_CrimeID,_NPC,_Criminal1);
		ProcCrimeTrespassingCheckDetection(_CrimeID,_NPC,_Criminal2);
		ProcCrimeTrespassingCheckDetection(_CrimeID,_NPC,_Criminal3);
		ProcCrimeTrespassingCheckDetection(_CrimeID,_NPC,_Criminal4);
		ProcCrimeTrespassingCheckValidLead(_CrimeID,_NPC);
		ProcCrimeTrespassingStopNPCsDialogAndMakeHostileTo(_CrimeID,_BusyCrimeID,_NPC);
		
		PROC
		ProcCrimeTrespassingCheckDetection((INTEGER)_CrimeID,(CHARACTERGUID)_NPC,(CHARACTERGUID)_Player)
		AND
		_Player != NULL_00000000-0000-0000-0000-000000000000
		AND
		GetDistanceTo(_NPC,_Player,_Dist)
		AND
		CrimeGetDetectionRange(_CrimeID,_Range)
		AND
		_Dist <= _Range
		THEN
		DB_Crime_TrespassUnavailableLeadDetected((CHARACTERGUID)_NPC,(CHARACTERGUID)_Player);
		
		PROC
		ProcCrimeTrespassingCheckValidLead((INTEGER)_CrimeID,(CHARACTERGUID)_NPC)
		AND
		QryCrimeTrespassUnavailableLeadDetected(_NPC)
		THEN
		ProcCrimeTrespassingBlockHostileFallback(_CrimeID,_NPC);
		
		QRY
		QryCrimeTrespassUnavailableLeadDetected((CHARACTERGUID)_NPC)
		AND
		DB_Crime_TrespassUnavailableLeadDetected((CHARACTERGUID)_NPC,_)
		THEN
		DB_NOOP(1);
		
		PROC
		ProcCrimeTrespassingBlockHostileFallback((INTEGER)_CrimeID,(CHARACTERGUID)_NPC)
		THEN
		DB_NOOP(1);
		
		PROC
		ProcCrimeTrespassingStopNPCsDialogAndMakeHostileTo((INTEGER)_CrimeID,(INTEGER)_BusyCrimeID,(CHARACTERGUID)_NPC)
		AND
		DB_Crime_TrespassUnavailableLeadDetected(_NPC,_Player)
		AND
		NOT DB_CrimeTrespassingBlockHostile(_CrimeID,_NPC)
		THEN
		ProcTryMergingCrimes(_CrimeID,_BusyCrimeID,_NPC,_Player);
		
		PROC
		ProcTryMergingCrimes((INTEGER)_NewCrime,(INTEGER)_OldCrime,(CHARACTERGUID)_NPC,(CHARACTERGUID)_Player)
		THEN
		NOT DB_CanMergeCrimes(1);
		
		PROC
		ProcTryMergingCrimes((INTEGER)_NewCrime,(INTEGER)_OldCrime,(CHARACTERGUID)_NPC,(CHARACTERGUID)_Player)
		AND
		QryCanMergeCrimes(_NewCrime,_OldCrime,_Player)
		THEN
		DB_CanMergeCrimes(1);
		
		IF
		OnCriminalMergedWithCrime(_Crime,_Criminal)
		AND
		CrimeGetLeadInvestigator(_Crime,_Lead)
		AND
		CrimeGetType(_Crime,_Type)
		AND
		DB_CrimeAttitudeChange(_Type,_Adjust)
		THEN
		ProcCrimeCheckIfAttitudeCauseCombat(_Lead,_Criminal,_Adjust);
		
		PROC
		ProcTryMergingCrimes((INTEGER)_NewCrime,(INTEGER)_OldCrime,(CHARACTERGUID)_NPC,(CHARACTERGUID)_Player)
		AND
		NOT DB_CanMergeCrimes(1)
		AND
		QueryOnlyOnce("CRIME_Trespassing_NPCForceStopDialog")
		THEN
		ProcForceStopDialog(_NPC);
		
		PROC
		ProcTryMergingCrimes((INTEGER)_NewCrime,(INTEGER)_OldCrime,(CHARACTERGUID)_NPC,(CHARACTERGUID)_Player)
		AND
		NOT DB_CanMergeCrimes(1)
		THEN
		//ignore these 2 crimes, since we're dealing with them in our own way
		CrimeIgnoreCrime(_OldCrime,_NPC);
		CrimeIgnoreCrime(_NewCrime,_NPC);
		DB_CrimeTresPassCombatFallback(_NPC);
		ProcTryStartAttackAD(_NPC);
		CharacterSetTemporaryHostileRelation(_NPC,_Player);
		
		PROC
		ProcTryMergingCrimes((INTEGER)_NewCrime,(INTEGER)_OldCrime,(CHARACTERGUID)_NPC,(CHARACTERGUID)_Player)
		AND
		DB_CanMergeCrimes(1)
		AND
		DB_DialogNPCs(_ID,_NPC,_)
		THEN
		CharacterStopCrimeWithID(_Player,_NewCrime);
		DialogAddActor(_ID,_Player);
		
		QRY
		QryCanMergeCrimes((INTEGER)_NewCrime,(INTEGER)_OldCrime,(CHARACTERGUID)_Player)
		AND
		CrimeGetType(_NewCrime,_Type)
		AND
		CrimeGetType(_OldCrime,_Type)
		AND
		CrimeAddCriminal(_OldCrime,_Player,1)
		THEN
		DB_Noop(1);
		
		PROC
		ProcTryStartAttackAD((CHARACTERGUID)_NPC)
		AND
		IsTagged(_NPC,"ANIMAL",0)
		AND
		HasAppliedStatus(_NPC, "UNCONSCIOUS", 0)
		AND
		HasAppliedStatus(_NPC, "LIE_DYING", 0)
		AND
		HasAppliedStatus(_NPC, "MUTED", 0)
		THEN
		Proc_StartDialog(1,"GEB_AD_AttackHelp",_NPC);
		
		//Clearing
		PROC
		ProcCrimeTrespassingStopNPCsDialogAndMakeHostileTo((INTEGER)_CrimeID,(INTEGER)_BusyCrimeID,(CHARACTERGUID)_NPC)
		AND
		DB_Crime_TrespassUnavailableLeadDetected(_NPC,_Player)
		THEN
		NOT DB_OnlyOnce("CRIME_Trespassing_NPCForceStopDialog");
		NOT DB_Crime_TrespassUnavailableLeadDetected(_NPC,_Player);
		
		PROC
		ProcCrimeTrespassingStopNPCsDialogAndMakeHostileTo((INTEGER)_CrimeID,(INTEGER)_BusyCrimeID,(CHARACTERGUID)_NPC)
		THEN
		DB_CrimeTrespassingBlockHostile(_CrimeID,_NPC);
		
		IF
		ObjectEnteredCombat((CHARACTERGUID)_NPC,_)
		AND
		DB_CrimeTresPassCombatFallback(_NPC)
		AND
		DB_CrimeTrespassingBlockHostile(_CrimeID,_NPC)
		THEN
		NOT DB_CrimeTrespassingBlockHostile(_CrimeID,_NPC);
		
		IF
		OnCrimeResolved(_CrimeID,_,_,_,_,_)
		AND
		DB_CrimeTrespassingBlockHostile(_CrimeID,_NPC)
		THEN
		NOT DB_CrimeTrespassingBlockHostile(_CrimeID,_NPC);
		
		//END_REGION
		
		//REGION Crimes against a character that can't react because it's in a dialog
		IF
		CharacterSelectedAsBestUnavailableFallbackLead(_Char,_Region,_NewCrime,_OldCrime,_NewCriminal1,_NewCriminal2,_NewCriminal3,_NewCriminal4)
		AND
		CrimeGetTension(_NewCrime,_Tension)
		AND
		_Tension > 0
		AND
		CrimeGetType(_NewCrime,_CrimeName)
		AND
		NOT DB_TrespassingCrimes(_CrimeName)
		AND
		DB_DialogNPCs(_OldCrimeDialog,_Char,_)
		AND
		CrimeGetCriminals(_OldCrime, _OldCriminal1, _OldCriminal2, _OldCriminal3, _OldCriminal4)
		THEN
		CrimeConfrontationDone(_NewCrime,_Char);
		ProcForceStopDialog(_Char);
		Proc_CharacterSetTemporaryHostileRelation(_Char,_OldCriminal1);
		Proc_CharacterSetTemporaryHostileRelation(_Char,_OldCriminal2);
		Proc_CharacterSetTemporaryHostileRelation(_Char,_OldCriminal3);
		Proc_CharacterSetTemporaryHostileRelation(_Char,_OldCriminal4);
		Proc_CharacterSetTemporaryHostileRelation(_Char,_NewCriminal1);
		Proc_CharacterSetTemporaryHostileRelation(_Char,_NewCriminal2);
		Proc_CharacterSetTemporaryHostileRelation(_Char,_NewCriminal3);
		Proc_CharacterSetTemporaryHostileRelation(_Char,_NewCriminal4);
		//END_REGION
		//----------------------------------- ASSAULT -----------------------------------
		//REGION Chicken touch
		
		IF
		CharacterStatusAttempt((CHARACTERGUID)_NPC,"CHICKEN",(CHARACTERGUID)_Player)
		AND
		DB_IsPlayer(_Player)
		AND
		NOT DB_IsPlayer(_NPC)
		AND
		NOT DB_IgnoreAssault(_NPC)
		AND
		NOT DB_CombatCharacters(_NPC,_)
		AND
		NOT DB_IgnoreAssaultFor(_Player,_NPC)
		AND
		ObjectIsCharacter(_NPC,1)
		AND
		IsTagged(_NPC,"GHOST",0)
		AND
		IsTagged(_NPC,"SUMMON",0)
		AND
		HasAppliedStatus(_NPC,"CHICKEN",1)
		AND
		CharacterIsEnemy(_NPC,_Player,0)
		THEN
		DB_Crime_PolymorphedIgnoreAssault(_NPC,_Player);	//keep this first, the register forces a flush!
		
		//END_REGION
		
		//REGION Player teleported while in dialog with NPC
		
		// Keep track of the original position of the player when the dialog started
		QRY
		QRY_CRIME_PlayerInDialogTeleportedTooFarInit((INTEGER)_DialogID, (CHARACTERGUID)_Player, (REAL)_OldX, (REAL)_OldY, (REAL)_OldZ)
		AND
		NOT DB_CRIME_DialogTeleportInitialPosition(_DialogID, _Player, _, _, _)
		THEN
		DB_CRIME_DialogTeleportInitialPosition(_DialogID, _Player, _OldX, _OldY, _OldZ);
		
		// Ensure it always succeeds
		QRY
		QRY_CRIME_PlayerInDialogTeleportedTooFarInit((INTEGER)_DialogID, (CHARACTERGUID)_Player, (REAL)_OldX, (REAL)_OldY, (REAL)_OldZ)
		THEN
		DB_NOOP(1);
		
		// Teleported further than 5 metres away from the NPC than the original position -> too far
		QRY
		QRY_CRIME_PlayerInDialogTeleportedTooFar((CHARACTERGUID)_Player, (REAL)_OldX, (REAL)_OldY, (REAL)_OldZ)
		AND
		DB_IsPlayer(_Player)
		AND
		DB_DialogPlayers(_DialogID, _Player, _)
		AND
		NOT DB_AutomatedDialog(_DialogID)
		AND
		QRY_CRIME_PlayerInDialogTeleportedTooFarInit(_DialogID, _Player, _OldX, _OldY, _OldZ)
		AND
		DB_CRIME_DialogTeleportInitialPosition(_DialogID, _Player, _OrgX, _OrgY, _OrgZ)
		AND
		DB_DialogNPCs(_DialogID, _NPC, _)
		AND
		ObjectIsCharacter(_NPC, 1)
		AND
		GetDistanceToPosition(_NPC, _OrgX, _OrgY, _OrgZ, _OrgDist)
		AND
		GetDistanceTo(_NPC, _Player, _NewDist)
		AND
		RealSum(_OrgDist, 5.0, _MaxDist)
		AND
		_NewDist > _MaxDist
		THEN
		DB_CRIME_PlayerInDialogTeleportedTooFar(_DialogID, _Player, (CHARACTERGUID)_NPC);
		
		// Clean up
		IF
		DialogEnded(_, _DialogID)
		AND
		DB_CRIME_DialogTeleportInitialPosition(_DialogID, _Player, _OldX, _OldY, _OldZ)
		THEN
		NOT DB_CRIME_DialogTeleportInitialPosition(_DialogID, _Player, _OldX, _OldY, _OldZ);
		
		IF
		CharacterTeleported(_Player, _, _OldX, _OldY, _OldZ, _NewX, _NewY, _NewZ, _)
		AND
		QRY_CRIME_PlayerInDialogTeleportedTooFar(_Player, _OldX, _OldY, _OldZ)
		AND
		DB_CRIME_PlayerInDialogTeleportedTooFar(_ID, _Player, _NPC)
		AND
		CharacterIsCrimeEnabled(_NPC, "TeleportPlayerDialog", 1)
		AND
		RealSum(_NewY,1.0,_NewYUp)
		THEN
		NOT DB_CRIME_PlayerInDialogTeleportedTooFar(_ID, _Player, _NPC);
		// In case this results in investigation, ensures the NPC can start investigating
		// instead of waiting until the end of the dialog (unless it's in a dialog that
		// must not be interrupted due to a crime)
		ProcCrimeTryForceStopDialog(_NPC);
		// OldX/OldY/OldZ would be better, but then investigations fail because they abort
		// when the investigator can see the crime scene, but not the criminal
		ProcCharacterRegisterCrimeWithPosition(_Player, "TeleportPlayerDialog", NULL_00000000-0000-0000-0000-000000000000, _NPC, _NewX, _NewYUp, _NewZ, 0, _NPC);
		
		//END_REGION
		
		//REGION Assault
		
		QRY
		QryHasNeutralBlockTag((CHARACTERGUID)_NPC)
		AND
		DB_NeutralTagIgnore((STRING)_Tag)
		AND
		IsTagged(_NPC,_Tag,1)
		THEN
		DB_NOOP(1);
		
		//--- Checks if the NPC and/or the player/summon are in combat while being neutral to each other, then makes them hostile
		IF
		AttackedByObject((CHARACTERGUID)_NPC,(CHARACTERGUID)_Player,(CHARACTERGUID)_Summon,_,_DamageSource)
		AND
		// Can be equal in case of a hostile status enter due to equiping something
		_NPC != _Summon
		AND
		NOT DB_Crime_Assault(_,_,_NPC)
		AND
		NOT DB_Crime_Assault(_,_Player,_)
		AND
		NOT DB_Crime_PolymorphedIgnoreAssault(_NPC,_Player)
		AND
		NOT QryIgnoreDamageSource(_DamageSource)
		AND
		ObjectIsCharacter(_NPC,1)
		AND
		CharacterIsPlayer(_Player,1)
		AND
		CharacterIsDeadOrFeign(_Player,0)
		AND
		CharacterIsPlayer(_NPC,0)
		AND
		Qry_AreInCombat(_Player,_NPC)
		AND
		CharacterCanFight(_NPC,1)
		AND
		CharacterIsDead(_NPC,0)
		AND
		CharacterIsNeutral(_NPC,_Player,1)
		AND
		NOT QryHasNeutralBlockTag(_NPC)
		AND
		IsTagged(_NPC,"ANIMAL",0)
		AND
		DB_CombatCharacters(_NPC,_ID)
		THEN
		ProcWarnPlayerOfAttack(_NPC,_Player,_ID);
		
		//REGION Combat warnings
		IF
		ObjectLeftCombat((CHARACTERGUID)_NPC,_)
		AND
		DB_CombatWarnings(_NPC,_Cnt)
		THEN
		NOT DB_CombatWarnings(_NPC,_Cnt);
		
		PROC
		ProcWarnPlayerOfAttack((CHARACTERGUID)_NPC,(CHARACTERGUID)_Player,(INTEGER)_ID)
		AND
		NOT DB_CombatWarnings(_NPC,_)
		THEN
		DB_CombatWarnings(_NPC,0);
		
		PROC
		ProcWarnPlayerOfAttack((CHARACTERGUID)_NPC,(CHARACTERGUID)_Player,(INTEGER)_ID)
		AND
		NOT DB_CombatCharacters(_Player,_)
		AND
		DB_CombatWarnings(_NPC,_Count)
		THEN
		NOT DB_CombatWarnings(_NPC,_Count);
		DB_CombatWarnings(_NPC,3);
		
		PROC
		ProcWarnPlayerOfAttack((CHARACTERGUID)_NPC,_,_)
		THEN
		ObjectClearFlag(_NPC,"GEB_Crime_LastNeutralWarning");
		ObjectClearFlag(_NPC,"GEB_Crime_AttackNeutralWarning");
		
		PROC
		ProcWarnPlayerOfAttack((CHARACTERGUID)_NPC,(CHARACTERGUID)_Player,(INTEGER)_ID)
		AND
		DB_CombatWarnings(_NPC,_Old)
		AND
		IntegerSum(_Old,1,_Count)
		THEN
		NOT DB_CombatWarnings(_NPC,_Old);
		DB_CombatWarnings(_NPC,_Count);
		
		PROC
		ProcWarnPlayerOfAttack((CHARACTERGUID)_NPC,(CHARACTERGUID)_Player,(INTEGER)_ID)
		AND
		DB_CombatWarnings(_NPC,_Count)
		AND
		_Count > 3
		THEN
		ObjectSetFlag(_NPC,"GEB_Crime_AttackNeutralWarning");
		ProcMakeNPCHostile(_NPC,_Player);
		
		PROC
		ProcWarnPlayerOfAttack((CHARACTERGUID)_NPC,(CHARACTERGUID)_Player,(INTEGER)_ID)
		AND
		DB_CombatWarnings(_NPC,3)
		THEN
		ObjectSetFlag(_NPC,"GEB_Crime_LastNeutralWarning");
		
		PROC
		ProcWarnPlayerOfAttack((CHARACTERGUID)_NPC,(CHARACTERGUID)_Player,(INTEGER)_ID)
		AND
		DB_CombatWarnings(_NPC,_Count)
		AND
		QryDoNeutralAttackWarning(_Count)
		THEN
		Proc_StartDialog(1,"GEB_AD_WarnFriendlyFire",_NPC);
		
		QRY
		QryDoNeutralAttackWarning((INTEGER)_Count)
		AND
		_Count < 3
		AND
		Random(100,_Rnd)
		AND
		_Rnd <= 40
		THEN
		DB_Noop(1);
		
		QRY
		QryDoNeutralAttackWarning(3)
		THEN
		DB_Noop(1);
		
		//END_REGION
		QRY
		Qry_AreInCombat((CHARACTERGUID)_Player,(CHARACTERGUID)_NPC)
		AND
		DB_CombatCharacters(_NPC,_)
		THEN
		DB_NOOP(1);
		
		QRY
		Qry_AreInCombat((CHARACTERGUID)_Player,(CHARACTERGUID)_NPC)
		AND
		DB_CombatCharacters(_Player,_)
		THEN
		DB_NOOP(1);
		
		PROC
		ProcClearAssaultDBForCrime((INTEGER)_CrimeID)
		AND
		DB_Crime_Assault(_CrimeID,_Criminal,_Victim)
		THEN
		NOT DB_Crime_Assault(_CrimeID,_Criminal,_Victim);
		
		IF
		OnCrimeRemoved(_CrimeID,_Victim,_Criminal1,_Criminal2,_Criminal3,_Criminal4)
		THEN
		ProcClearAssaultDBForCrime(_CrimeID);
		
		IF
		OnCrimeResolved(_CrimeID,_Victim,_Criminal1,_Criminal2,_Criminal3,_Criminal4)
		AND
		_Victim != NULL_00000000-0000-0000-0000-000000000000
		AND
		DB_Crime_Assault(_CrimeID,_,_)
		AND
		IntegertoString(_CrimeID,_CrimeSuffix)
		AND
		StringConcatenate("Timer_ClearAttackDB",_CrimeSuffix,_TimerName)
		THEN
		DB_Crime_PlayerAttacked(_CrimeID,_Criminal1,_Victim); // This is For Murder crime
		DB_Crime_PlayerAttacked(_CrimeID,_Criminal2,_Victim);
		DB_Crime_PlayerAttacked(_CrimeID,_Criminal3,_Victim);
		DB_Crime_PlayerAttacked(_CrimeID,_Criminal4,_Victim);
		DB_AttackTimer(_CrimeID,_TimerName);
		ProcObjectTimer(_Victim,_TimerName,1500);
		NOT DB_Crime_PlayerAttacked(_CrimeID,NULL_00000000-0000-0000-0000-000000000000,_Victim); //Future Feature if needed Generate Murder for every on in combat with the OG DB_Crime_PlayerAttacked _Victim
		
		IF
		OnCrimeResolved(_CrimeID,_Victim,_Criminal1,_Criminal2,_Criminal3,_Criminal4)
		THEN
		ProcClearAssaultDBForCrime(_CrimeID);
		
		PROC
		ProcObjectTimerFinished((CHARACTERGUID)_Victim,_TimerName)
		AND
		DB_AttackTimer(_CrimeID,_TimerName)
		AND
		DB_Crime_PlayerAttacked(_CrimeID,_Player,_Victim)
		AND
		NOT DB_CombatCharacters(_Victim, _)
		THEN
		NOT DB_Crime_PlayerAttacked(_CrimeID,_Player,_Victim);
		
		PROC
		ProcObjectTimerFinished(_Victim,_TimerName)
		AND
		DB_AttackTimer(_CrimeID,_TimerName)
		THEN
		NOT DB_AttackTimer(_CrimeID,_TimerName);
		
		IF
		CrimeInterrogationRequest(_RegionID,_CrimeID,_Interrogator,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_Dialog)
		THEN
		ProcClearAssaultDBForCrime(_CrimeID);
		
		IF
		OnCrimeMergedWith(_Old,_New)
		AND
		DB_Crime_Assault(_Old,_Criminal1,_Victim)
		THEN
		NOT DB_Crime_Assault(_Old,_Criminal1,_Victim);
		DB_Crime_Assault(_New,_Criminal1,_Victim);
		
		//if our vicitim is not selected as lead (incapacitated), don't track this DB because that will mean he won't be able to react anymore
		//update it with the new lead
		IF
		CharacterOnCrimeSensibleActionNotification(_NPC,_,_CrimeID,_,_,_Criminal1,_,_,_,1)
		AND
		DB_Crime_Assault(_CrimeID,_Criminal1,_Victim)
		THEN
		NOT DB_Crime_Assault(_CrimeID,_Criminal1,_Victim);
		DB_Crime_Assault(_CrimeID,_Criminal1,_NPC);
		
		//END_REGION
		
		//REGION General Assault crime -- verifies if the assailant is a summon or not and registers the Assault or AttackAnimal crime
		
		QRY
		QryIgnoreDamageSource((STRING)_Dmg)
		AND
		DB_IgnoreDamageSources(_Dmg)
		THEN
		DB_NOOP(1);
		
		IF
		AttackedByObject((CHARACTERGUID)_NPC,(CHARACTERGUID)_Player,(CHARACTERGUID)_Summon,_,_DamageSource)
		AND
		_NPC != _Summon
		AND
		NOT DB_IgnoreAssault(_NPC)
		AND
		NOT DB_Crime_PolymorphedIgnoreAssault(_NPC,_Player)
		AND
		NOT DB_CombatCharacters(_NPC,_)
		AND
		NOT DB_Crime_Assault(_,_,_NPC)
		AND
		CharacterIsPlayer(_Player,1)
		AND
		NOT QryIgnoreDamageSource(_DamageSource)
		AND
		CharacterIsDeadOrFeign(_Player,0)
		AND
		ObjectIsCharacter(_NPC,1)
		AND
		CharacterIsPlayer(_NPC,0)
		AND
		CharacterIsDead(_NPC,0)
		AND
		IsTagged(_NPC,"GHOST",0)
		AND
		IsTagged(_NPC,"SUMMON",0)
		THEN
		ProcCrimeCheckAssailant(_NPC,_Player,_Summon);
		
		
		//--- Assailant is not a summon
		PROC
		ProcCrimeCheckAssailant((CHARACTERGUID)_NPC,(CHARACTERGUID)_Player,(CHARACTERGUID)_Summon)
		AND
		NOT QRY_CharacterIsNull(_Summon)
		AND
		IsTagged(_Summon,"SUMMON",1)
		AND
		NOT DB_IgnoreAssaultFor(_Summon,_NPC)
		AND
		NOT DB_Crime_Assault(_,_Summon,_)
		AND
		CharacterIsEnemy(_NPC,_Summon,0)
		THEN
		ProcCrimeRegisterAssault(_Summon,_NPC,1);
		
		//--- Assailant is a summon
		PROC
		ProcCrimeCheckAssailant((CHARACTERGUID)_NPC,(CHARACTERGUID)_Player,(CHARACTERGUID)_Summon)
		AND
		QryCrimeAssailantIsNotSummon(_Player,_Summon)
		AND
		NOT DB_IgnoreAssaultFor(_Player,_NPC)
		AND
		NOT DB_Crime_Assault(_,_Player,_)
		AND
		CharacterIsEnemy(_NPC,_Player,0)
		THEN
		ProcCrimeRegisterAssault(_Player,_NPC,0);
		
		//--- Split the type of assault
		// Normal
		PROC
		ProcCrimeRegisterAssault((CHARACTERGUID)_Assailant,(CHARACTERGUID)_NPC,0) //_AssailantIsSummon
		AND
		IsTagged(_NPC,"ANIMAL",0)
		THEN
		ProcCrimeRegisterAssaultType(_Assailant,_NPC,"Assault");
		
		PROC
		ProcCrimeRegisterAssault((CHARACTERGUID)_Assailant,(CHARACTERGUID)_NPC,0)
		AND
		IsTagged(_NPC,"ANIMAL",1)
		THEN
		ProcCrimeRegisterAssaultType(_Assailant,_NPC,"AttackAnimal");
		
		// Summon
		PROC
		ProcCrimeRegisterAssault((CHARACTERGUID)_Assailant,(CHARACTERGUID)_NPC,1)
		AND
		IsTagged(_NPC,"ANIMAL",0)
		THEN
		ProcCrimeRegisterAssaultType(_Assailant,_NPC,"SummonAssault");
		
		PROC
		ProcCrimeRegisterAssault((CHARACTERGUID)_Assailant,(CHARACTERGUID)_NPC,1)
		AND
		IsTagged(_NPC,"ANIMAL",1)
		THEN
		ProcCrimeRegisterAssaultType(_Assailant,_NPC,"SummonAttackAnimal");
		
		//REGION Assault investigation location determination
		// Default: victim location
		// Problem: if attacked from out of sight range, they won't be able to find the attacker
		// Solution: after a while, report the assailant's rather than the victim's location as investigation location
		// If assaulted even more: force combat
		//
		// Reasoning: the more an NPC has been attacked, the more they'll pay attention
		//   regarding where the attack came from. Factors influencing them homing in on
		//   the source: sneaking, invisibility, wits difference between victim and assailant
		
		QRY
		QRY_CRIMES_AssaultCrimeGetCrimeLocationScoreIncrease((CHARACTERGUID)_Assailant,(CHARACTERGUID)_Victim)
		AND
		DB_CRIME_AssaultCrimeGetCrimeLocationScoreIncrease(_Total)
		THEN
		NOT DB_CRIME_AssaultCrimeGetCrimeLocationScoreIncrease(_Total);
		
		QRY
		QRY_CRIMES_AssaultCrimeGetCrimeLocationScoreIncrease((CHARACTERGUID)_Assailant,(CHARACTERGUID)_Victim)
		AND
		HasActiveStatus(_Assailant,"SNEAKING",_IsSneaking)
		AND
		HasActiveStatus(_Assailant,"INVISIBLE",_IsInvisible)
		AND
		CharacterGetAttribute(_Assailant,"WITS",_AssailantWits)
		AND
		CharacterGetAttribute(_Assailant,"WITS",_VictimWits)
		AND
		IntegerSubtract(_VictimWits,_AssailantWits,_WitsRes)
		AND
		QRY_IntegerSign(_WitsRes)
		AND
		DB_IntegerSign(_WitsBonus)
		AND
		DB_CRIME_CrimeLocationScoreIncrease(_IsSneaking,_IsInvisible,_Base,_Rand)
		AND
		Random(_Rand,_Extra)
		AND
		IntegerSum(_Base,_Extra,_BaseTotal)
		AND
		IntegerSum(_BaseTotal,_WitsBonus,_Total)
		THEN
		DB_CRIME_AssaultCrimeGetCrimeLocationScoreIncrease(_Total);
		
		QRY
		QRY_CRIME_AssaultCrimeGetInvestigationPos((CHARACTERGUID)_Assailant,(CHARACTERGUID)_Victim)
		AND
		DB_CRIME_AssaultCrimeInvestigationPos(_x,_yUp,_z)
		THEN
		NOT DB_CRIME_AssaultCrimeInvestigationPos(_x,_yUp,_z);
		
		QRY
		QRY_CRIME_AssaultCrimeGetInvestigationPos((CHARACTERGUID)_Assailant,(CHARACTERGUID)_Victim)
		THEN
		Proc_CharCountHelper(_Victim,"CRIME_CrimeTriggers_AssaultCrimeLocation");
		
		// Update assault score
		QRY
		QRY_CRIME_AssaultCrimeGetInvestigationPos((CHARACTERGUID)_Assailant,(CHARACTERGUID)_Victim)
		AND
		QRY_CRIMES_AssaultCrimeGetCrimeLocationScoreIncrease(_Assailant,_Victim)
		AND
		DB_CRIME_AssaultCrimeGetCrimeLocationScoreIncrease(_Increase)
		THEN
		Proc_CharCountHelper(_Victim,"CRIME_CrimeTriggers_AssaultCrimeLocation",_Increase);
		
		// Assaulted many times -> investigate location of assailant
		QRY
		QRY_CRIME_AssaultCrimeGetInvestigationPos((CHARACTERGUID)_Assailant,(CHARACTERGUID)_Victim)
		AND
		DB_CharCountHelper(_Victim,"CRIME_CrimeTriggers_AssaultCrimeLocation",_Count)
		AND
		DB_CRIME_CrimeLocationScore_GoToAttackerThreshold(_Threshold)
		AND
		_Count >= _Threshold
		AND
		GetPosition(_Assailant,_x,_y,_z)
		AND
		RealSum(_y,1.0,_yUp)
		THEN
		DB_CRIME_AssaultCrimeInvestigationPos(_x,_yUp,_z);
		
		// Fallback if not yet assaulted many times
		QRY
		QRY_CRIME_AssaultCrimeGetInvestigationPos((CHARACTERGUID)_Assailant,(CHARACTERGUID)_Victim)
		AND
		NOT DB_CRIME_AssaultCrimeInvestigationPos(_,_,_)
		AND
		GetPosition(_Victim,_x,_y,_z)
		AND
		RealSum(_y,1.0,_yUp)
		THEN
		DB_CRIME_AssaultCrimeInvestigationPos(_x,_yUp,_z);
		
		// Clean up when dying
		IF
		CharacterDied(_Victim)
		AND
		DB_CharCountHelper(_Victim,"CRIME_CrimeTriggers_AssaultCrimeLocation",_Count)
		THEN
		NOT DB_CharCountHelper(_Victim,"CRIME_CrimeTriggers_AssaultCrimeLocation",_Count);
		
		//END_REGION
		
		//REGION Assaulted really a lot or down on health -> start combat
		// Allows for at least three assaults -> don't cut off warning system
		PROC
		ProcCrimeRegisterAssaultType((CHARACTERGUID)_Assailant,(CHARACTERGUID)_Victim,(STRING)_AssaultType)
		AND
		QRY_CRIME_AssaultCrimeGetInvestigationPos(_Assailant,_Victim)
		AND
		CharacterIsCrimeEnabled(_Victim,_AssaultType,1)
		AND
		DB_CharCountHelper(_Victim,"CRIME_CrimeTriggers_AssaultCrimeLocation",_Count)
		AND
		DB_CRIME_CrimeLocationScore_StartAttackingThreshold(_Threshold)
		AND
		_Count >= _Threshold
		AND
		CharacterCanFight(_Victim,1)
		THEN
		DB_CrimeRegisterAssaultType_Handled(1);
		ProcTryStartAttackAD(_Victim);
		Proc_CharacterSetTemporaryHostileRelation(_Victim,_Assailant);
		EnterCombat(_Victim,_Assailant);
		
		PROC
		ProcCrimeRegisterAssaultType((CHARACTERGUID)_Assailant,(CHARACTERGUID)_Victim,(STRING)_AssaultType)
		AND
		CharacterIsCrimeEnabled(_Victim,_AssaultType,1)
		AND
		CharacterGetHitpointsPercentage(_Victim,_Percentage)
		AND
		DB_CRIME_Assault_HealthStartAttackingThreshold(_Threshold)
		AND
		_Percentage < _Threshold
		AND
		CharacterCanFight(_Victim,1)
		AND
		CharacterIsDead(_Victim,0)
		THEN
		DB_CrimeRegisterAssaultType_Handled(1);
		ProcTryStartAttackAD(_Victim);
		Proc_CharacterSetTemporaryHostileRelation(_Victim,_Assailant);
		EnterCombat(_Victim,_Assailant);
		//END_REGION
		
		PROC
		ProcCrimeRegisterAssaultType((CHARACTERGUID)_Assailant,(CHARACTERGUID)_Victim,(STRING)_AssaultType)
		AND
		NOT DB_CrimeRegisterAssaultType_Handled(1)
		AND
		GetPosition(_Victim,_x,_y,_z)
		AND
		RealSum(_y,1.0,_yUp)
		AND
		CrimeIsAnyNPCGoingToReact(_Assailant,_AssaultType,_Victim,_x,_yUp,_z,_WillReact)
		AND
		CrimeGetNewID(_CrimeID)
		AND
		DB_CRIME_AssaultCrimeInvestigationPos(_XInv,_YInv,_ZInv)
		THEN
		NOT DB_CRIME_AssaultCrimeInvestigationPos(_XInv,_YInv,_ZInv);
		DB_CRIME_CrimeInvestigationPos(_CrimeID,_XInv,_YInv,_ZInv);
		DB_Crime_Assault(_CrimeID,_Assailant,_Victim);
		ProcCheckRegisterAssault(_Assailant,_Victim,_AssaultType,_x,_yUp,_z,_CrimeID,_WillReact);
		
		PROC
		ProcCrimeRegisterAssaultType((CHARACTERGUID)_Assailant,(CHARACTERGUID)_Victim,(STRING)_AssaultType)
		AND
		DB_CrimeRegisterAssaultType_Handled(1)
		THEN
		NOT DB_CrimeRegisterAssaultType_Handled(1);
		
		PROC
		ProcClearAssaultDBForCrime((INTEGER)_CrimeID)
		AND
		DB_CRIME_CrimeInvestigationPos(_CrimeID,_XInv,_YInv,_ZInv)
		THEN
		NOT DB_CRIME_CrimeInvestigationPos(_CrimeID,_XInv,_YInv,_ZInv);
		
		PROC
		ProcCheckRegisterAssault((CHARACTERGUID)_Assailant,(CHARACTERGUID)_Victim,(STRING)_AssaultType,(REAL)_X,(REAL)_Y,(REAL)_Z,(INTEGER)_CrimeID,1)
		THEN
		ProcCharacterRegisterCrimeWithPosition(_Assailant,_AssaultType,NULL_00000000-0000-0000-0000-000000000000,_Victim,_X,_Y,_Z,_CrimeID,_Victim);
		
		//noone reacted to this one, so assume the victim was incapacitated
		PROC
		ProcCheckRegisterAssault((CHARACTERGUID)_Assailant,(CHARACTERGUID)_Victim,(STRING)_AssaultType,(REAL)_X,(REAL)_Y,(REAL)_Z,(INTEGER)_CrimeID,0)
		THEN
		ProcCharacterRegisterCrimeWithPosition(_Assailant,"IncapacitatedAssault",NULL_00000000-0000-0000-0000-000000000000,_Victim,_X,_Y,_Z,_CrimeID,_Victim);
		
		//END_REGION
		
		//REGION Clear PolymorphedIgnoreAssault fact
		
		IF
		AttackedByObject((CHARACTERGUID)_NPC,(CHARACTERGUID)_Player,(CHARACTERGUID)_Summon,_,_)
		AND
		_NPC != _Summon
		AND
		DB_Crime_PolymorphedIgnoreAssault(_NPC,_Player)
		AND
		GetPosition(_NPC,_x,_y,_z)
		AND
		RealSum(_y,1.0,_yUp)
		AND
		CrimeGetNewID(_CrimeID)
		THEN
		NOT DB_Crime_PolymorphedIgnoreAssault(_NPC,_Player);
		CharacterRegisterCrimeWithPosition(_Player,"Polymorphed",NULL_00000000-0000-0000-0000-000000000000,_NPC,_x,_yUp,_z,_CrimeID);
		PROC_CRIME_TryPolymorphedCrimeAttitudeAdjustment(_NPC,_Player);
		
		PROC
		PROC_CRIME_TryPolymorphedCrimeAttitudeAdjustment((CHARACTERGUID)_NPC, (CHARACTERGUID)_Player)
		AND
		CharacterCanSee(_NPC, _Player, 1)
		THEN
		ProcCheckAdjustAttitude(_NPC,_NPC,_Player,NULL_00000000-0000-0000-0000-000000000000,NULL_00000000-0000-0000-0000-000000000000,NULL_00000000-0000-0000-0000-000000000000,-5,1);
		
		//END_REGION
		
		//REGION Teleportation Netherswap
		IF
		CharacterUsedSkillOnTarget(_Player,(CHARACTERGUID)_Npc,"Teleportation_Netherswap",_,_)
		AND
		NOT Qry_AreInCombat(_Player,_NPC)
		AND
		CharacterIsPlayer(_Player,1)
		AND
		ObjectIsCharacter(_Npc,1)
		AND
		CharacterIsDeadOrFeign(_Player,0)
		AND
		CharacterIsPlayer(_NPC,0)
		AND
		CharacterIsDead(_NPC,0)
		THEN
		ProcDoCrimeCheckAssailant(_Player,_NPC);
		
		PROC
		ProcDoCrimeCheckAssailant((CHARACTERGUID)_Summon,(CHARACTERGUID)_NPC)
		AND
		CharacterIsSummon(_Summon,1)
		AND
		CharacterGetOwner(_Summon,_Player)
		THEN
		ProcCrimeCheckAssailant(_NPC,_Player,_Summon);
		
		PROC
		ProcDoCrimeCheckAssailant((CHARACTERGUID)_Player,(CHARACTERGUID)_NPC)
		AND
		CharacterIsSummon(_Player,0)
		THEN
		ProcCrimeCheckAssailant(_NPC,_Player,_Player);
		
		IF
		CharacterUsedSkillOnTarget(_Player,(CHARACTERGUID)_Npc,"Teleportation_Netherswap",_,_)
		AND
		DB_CombatCharacters(_NPC, _)
		AND
		NOT DB_CombatCharacters(_Player, _)
		AND
		CharacterIsPlayer(_Player,1)
		AND
		CharacterIsDeadOrFeign(_Player,0)
		AND
		CharacterIsPlayer(_NPC,0)
		AND
		CharacterIsDead(_NPC,0)
		THEN
		EnterCombat(_Player, _NPC);
		
		//END_REGION
		
		//----------------------------------- /ASSAULT -----------------------------------
		
		//REGION GEB_FleeOutOfSight
		IF
		AutomatedDialogEnded("GEB_AD_CallForHelp",_ID) // For kids looking for help
		AND
		DB_DialogNPCs(_ID,_NPC,1)
		AND
		IsTagged(_NPC,"KID",1)
		AND
		ObjectGetFlag(_NPC,"GEB_FleeOutOfSight",0)
		THEN
		ObjectSetFlag(_NPC,"GEB_FleeOutOfSight");
		
		IF
		ObjectFlagSet("GEB_FleeOutOfSight",(CHARACTERGUID)_NPC,_)
		THEN
		SetHasDialog(_NPC,0);
		ProcCharacterDisappearOutOfSight((CHARACTERGUID)_NPC,0,1,"GEB_NPCFledOutOfSight",1);
		Proc_StartDialog(1,"GEB_AD_CallForHelp",_NPC);
		ProcForceStopDialog(_NPC);
		
		IF
		ObjectFlagSet("GEB_FleeOutOfSight",_NPC,_)
		AND
		NOT DB_GEB_FledOutOfSight(_NPC,_,_,_)
		AND
		GetPosition(_NPC,_X,_Y,_Z)
		THEN
		DB_GEB_FledOutOfSight(_NPC,_X,_Y,_Z);
		
		IF
		ObjectFlagSet("GEB_FleeOutOfSight",(CHARACTERGUID)_NPC,_)
		AND
		DB_Crime_Assault(_CrimeID,_Player,_NPC)
		THEN
		ProcClearAssaultDBForCrime(_CrimeID);
		
		IF
		CharacterWentOnStage(_Victim,0)
		AND
		DB_Crime_Assault(_CrimeID,_Player,_Victim)
		THEN
		ProcClearAssaultDBForCrime(_CrimeID);
		
		IF
		CharacterDied(_Victim)
		AND
		DB_Crime_Assault(_CrimeID,_Player,_Victim)
		THEN
		ProcClearAssaultDBForCrime(_CrimeID);
		
		IF
		CharacterDied(_Player)
		AND
		DB_Crime_Assault(_CrimeID,_Player,_Victim)
		THEN
		ProcClearAssaultDBForCrime(_CrimeID);
		
		IF
		CharacterLeftParty(_Player)
		AND
		DB_Crime_Assault(_CrimeID,_Player,_Victim)
		THEN
		ProcClearAssaultDBForCrime(_CrimeID);
		
		IF
		RegionStarted(_NewRegion)
		AND
		DB_Crime_Assault(_CrimeID,_Player,_Victim)
		THEN
		ProcClearAssaultDBForCrime(_CrimeID);
		
		IF
		StoryEvent(_NPC,"GEB_NPCFledOutOfSight")
		AND
		ObjectGetFlag(_NPC,"GEB_DontAppearAfter",0)
		THEN
		ProcObjectTimer(_NPC,"GEB_AppearNPCOutOfSight",15000);
		
		IF
		ObjectFlagSet("GEB_DontAppearAfter",_Char,_)
		THEN
		ProcObjectTimerCancel(_Char,"GEB_AppearNPCOutOfSight");
		
		IF
		ObjectFlagSet("GEB_DontAppearAfter",(CHARACTERGUID)_Char,_)
		AND
		DB_GEB_NPCAppearAfterCombat(_Char,_CombatID)
		THEN
		NOT DB_GEB_NPCAppearAfterCombat(_Char,_CombatID);
		
		//--- Start trying to reappear
		PROC
		ProcObjectTimerCancel((CHARACTERGUID)_NPC,"GEB_AppearNPCOutOfSight")
		AND
		DB_GEB_FledOutOfSight(_NPC,_X,_Y,_Z)
		THEN
		NOT DB_GEB_FledOutOfSight(_NPC,_X,_Y,_Z);
		
		PROC
		ProcObjectTimerFinished((CHARACTERGUID)_NPC,"GEB_AppearNPCOutOfSight")
		AND
		DB_GEB_FledOutOfSight(_NPC,_X,_Y,_Z)
		AND
		GetClosestPlayerToPosition(_X,_Y,_Z,_Player,_Dist)
		THEN
		ProcCrimeAppearOutOfSightChecks(_NPC,_Player,_Dist);
		
		//--- Check the distance and if the player is dead, in dialog or in combat
		PROC
		ProcCrimeAppearOutOfSightChecks((CHARACTERGUID)_NPC,(CHARACTERGUID)_Player,(REAL)_Dist)
		AND
		_Dist > 20.0
		THEN
		ProcAppearOutOfSightAfterFleeing(_NPC);
		
		PROC
		ProcCrimeAppearOutOfSightChecks((CHARACTERGUID)_NPC,(CHARACTERGUID)_Player,(REAL)_Dist)
		AND
		_Dist <= 20.0
		AND
		Query_CharacterIsAliveAndNotInCombat(_Player)
		AND
		IsSpeakerReserved(_Player,0)
		THEN
		ProcAppearOutOfSightAfterFleeing(_NPC);
		
		PROC
		ProcCrimeAppearOutOfSightChecks((CHARACTERGUID)_NPC,(CHARACTERGUID)_Player,(REAL)_Dist)
		AND
		_Dist <= 20.0
		AND
		DB_CombatCharacters(_Player,_CombatID)
		THEN
		DB_GEB_NPCAppearAfterCombat(_NPC,_CombatID);
		
		PROC
		ProcCrimeAppearOutOfSightChecks((CHARACTERGUID)_NPC,(CHARACTERGUID)_Player,(REAL)_Dist)
		AND
		_Dist <= 20.0
		AND
		CharacterIsDeadOrFeign(_Player,1)
		THEN
		ProcAppearOutOfSight_DeadClosestPlayer(_NPC,_Player);
		
		PROC
		ProcCrimeAppearOutOfSightChecks((CHARACTERGUID)_NPC,(CHARACTERGUID)_Player,(REAL)_Dist)
		AND
		NOT DB_GEB_NPCAppearAfterCombat(_NPC,_)
		AND
		_Dist <= 20.0
		AND
		IsSpeakerReserved(_Player,1)
		AND
		DB_DialogPlayers(_Inst,_Player,1)
		THEN
		DB_GEB_NPCAppearAfterDialog(_NPC,_Inst);
		
		// Try to find a live player
		PROC
		ProcAppearOutOfSight_DeadClosestPlayer((CHARACTERGUID)_NPC,(CHARACTERGUID)_Player)
		AND
		GetClosestAlivePlayer(_Player,_AlivePlayer,_)
		THEN
		DB_GEB_AppearOutOfSight_AlivePlayerFound(_NPC,_AlivePlayer);
		
		PROC
		ProcAppearOutOfSight_DeadClosestPlayer((CHARACTERGUID)_NPC,(CHARACTERGUID)_Player)
		AND
		NOT DB_GEB_AppearOutOfSight_AlivePlayerFound(_NPC,_)
		THEN
		ProcAppearOutOfSightAfterFleeing(_NPC);
		
		PROC
		ProcAppearOutOfSight_DeadClosestPlayer((CHARACTERGUID)_NPC,(CHARACTERGUID)_)
		AND
		DB_GEB_AppearOutOfSight_AlivePlayerFound(_NPC,_AlivePlayer)
		AND
		DB_GEB_FledOutOfSight(_NPC,_X,_Y,_Z)
		AND
		GetDistanceToPosition(_AlivePlayer,_X,_Y,_Z,_Dist)
		THEN
		NOT DB_GEB_AppearOutOfSight_AlivePlayerFound(_NPC,_AlivePlayer);
		ProcCrimeAppearOutOfSightChecks(_NPC,(CHARACTERGUID)_AlivePlayer,_Dist);
		
		//--- Recheck after dialog & combat
		IF
		DialogEnded(_,_Inst)
		AND
		DB_GEB_NPCAppearAfterDialog(_NPC,_Inst)
		THEN
		NOT DB_GEB_NPCAppearAfterDialog(_NPC,_Inst);
		ProcObjectTimer(_NPC,"GEB_AppearNPCOutOfSight",3000); // restart from the beginning (delay in case combat starts after the dialog)
		
		IF
		CombatEnded(_CombatID)
		AND
		DB_GEB_NPCAppearAfterCombat(_NPC,_CombatID)
		THEN
		NOT DB_GEB_NPCAppearAfterCombat(_NPC,_CombatID);
		ProcObjectTimer(_NPC,"GEB_AppearNPCOutOfSight",3000); // restart the checks from the beginning
		
		//--- Appear
		PROC
		ProcAppearOutOfSightAfterFleeing((CHARACTERGUID)_NPC)
		AND
		DB_GEB_FledOutOfSight(_NPC,_X,_Y,_Z)
		THEN
		NOT DB_GEB_FledOutOfSight(_NPC,_X,_Y,_Z);
		SetHasDialog(_NPC,1);
		CharacterAppearAtPositionOutOfSightTo((CHARACTERGUID)_NPC,_X,_Y,_Z,0,0,"GEB_NPCAppeared");
		ObjectClearFlag(_NPC,"GEB_FleeOutOfSight",0);
		Proc_CharacterFullRestore(_NPC);
		
		//END_REGION
		
		//REGION Source Magic
		
		IF
		CharacterUsedSkill(_Character,_Skill,_,_)
		AND
		DB_IsPlayer(_Character)
		AND
		IsSourceSkill(_Skill,1)
		THEN
		CharacterRegisterCrime(_Character,"SourceMagic",NULL_00000000-0000-0000-0000-000000000000,NULL_00000000-0000-0000-0000-000000000000,0);
		
		//END_REGION
		
		//REGION Stealing
		IF
		CharacterStoleItem(_Character,_Item,_X,_Y,_Z,_Victim,_SrcContainer,_)
		AND
		CharacterIsPlayer(_Character,1)
		AND
		_SrcContainer==NULL_00000000-0000-0000-0000-000000000000
		THEN
		//TODO: do not register Steal for stelaing from a container? IE: the problem with doing this is, that NPCs will detect missign items from a barrel without looking into it
		ProcCharacterRegisterCrimeWithPosition(_Character,"Steal",_Item,_Victim,_X,_Y,_Z,0,_Victim);
		
		//END_REGION
		
		//REGION Murder (animals and non-animals)
		
		//REGION Helpers
		// A killed character may get removed from a combat before the CharacterKilledByCharacter event gets triggered
		// -> also check DB_WasInCombat for the _Victim
		QRY
		QryCrimeKillerVictimWereInSameCombat((CHARACTERGUID)_Killer,(CHARACTERGUID)_Victim)
		AND
		DB_CombatCharacters(_Killer,_ID)
		AND
		DB_WasInCombat(_Victim,_ID)
		THEN
		DB_NOOP(1);
		
		QRY
		QryCrimeKillerVictimWereInSameCombat((CHARACTERGUID)_Killer,(CHARACTERGUID)_Victim)
		AND
		DB_CombatCharacters(_Killer,_ID)
		AND
		DB_CombatCharacters(_Victim,_ID)
		THEN
		DB_NOOP(1);
		
		// Killing a totem or a summon is not murder
		QRY
		QryCrimeCharacterCanCreateMurder((CHARACTERGUID)_Char)
		AND
		IsTagged(_Char,"SUMMON",0)
		AND
		IsTagged(_Char,"TOTEM",0)
		THEN
		DB_NOOP(1);
		//END_REGION
		
		//REGION Determine crime type
		// By default, murdering an animal results in "KilledAnimal" and murdering anyone
		// else in "Murder". Can override QryCrimeMurderGetCrimeTypeCustom() to return custom results.
		//
		// Note: QryCrimeMurderGetCrimeTypeCustom() can be called multiple times for the same murder
		//   (-> should not keep state, e.g. don't assume second call is for second murder)
		
		// Define signature for custom query
		QRY
		QryCrimeMurderGetCrimeTypeCustom((CHARACTERGUID)_Killer,(CHARACTERGUID)_Victim)
		AND
		DB_CrimeNeverEverSet__INVALID(1)
		THEN
		DB_NOOP(1);
		
		// Reset previous result, if any
		QRY
		QryCrimeMurderGetCrimeType((CHARACTERGUID)_Killer,(CHARACTERGUID)_Victim)
		AND
		DB_CrimeMurderCrimeType(_Type)
		THEN
		NOT DB_CrimeMurderCrimeType(_Type);
		
		// Query custom overrides
		QRY
		QryCrimeMurderGetCrimeType((CHARACTERGUID)_Killer,(CHARACTERGUID)_Victim)
		AND
		QryCrimeMurderGetCrimeTypeCustom(_Killer,_Victim)
		THEN
		DB_NOOP(1);
		
		// Default fallbacks
		QRY
		QryCrimeMurderGetCrimeType((CHARACTERGUID)_Killer,(CHARACTERGUID)_Victim)
		AND
		NOT DB_CrimeMurderCrimeType(_)
		AND
		IsTagged(_Victim,"ANIMAL",_Animal)
		AND
		HasActiveStatus(_Killer,"SNEAKING",_Sneaking)
		AND
		CharacterIsSummon(_Killer,_Summon)
		AND
		DB_CRIME_MurderType(_Sneaking,_Animal,_Summon,_MurderType)
		THEN
		DB_CrimeMurderCrimeType(_MurderType);
		//END_REGION
		
		//REGION Witnesses that should ignore this murder crime
		// Only have to do something before registering the crime if
		// the witness does not ignore crimes like this in general
		PROC
		ProcCrimeMurderDefineSilentWitness((INTEGER)_CrimeID,(CHARACTERGUID)_Witness,(CHARACTERGUID)_Killer,(CHARACTERGUID)_Victim)
		AND
		QryCrimeMurderGetCrimeType(_Killer,_Victim)
		AND
		DB_CrimeMurderCrimeType(_CrimeType)
		AND
		NOT DB_CharacterCrimeDisabled(_Witness,_CrimeType)
		THEN
		DB_CrimeSilentWitness(_CrimeID,_CrimeType,_Witness);
		// Don't set it to ignore this crime yet, as another crime (murder)
		// could occur between now and when this murder is registered due to
		// the use of an iterator) -- that will be done by ProcCrimeCreateMurder)
		
		// Convert DB_CrimeSilentWitness() to DB_CRIME_CrimeTriggers_SilentWitnessesForCrime(), as used by ProcCharacterRegisterCrimeWithPosition()
		PROC
		PROC_CRIME_CrimeTriggers_GetSilentWitnessesForCrime((INTEGER)_CrimeID,(CHARACTERGUID)_Perpetrator,(STRING)_CrimeType,(GUIDSTRING)_Evidence,(CHARACTERGUID)_Victim)
		AND
		DB_CrimeSilentWitness(_CrimeID,_CrimeType,_Witness)
		THEN
		NOT DB_CrimeSilentWitness(_CrimeID,_CrimeType,_Witness);
		DB_CRIME_CrimeTriggers_SilentWitnessesForCrime(_Witness);
		
		// NPCs that should ignore the murder of this victim should be treated as silent witnesses
		PROC
		PROC_CRIME_CrimeTriggers_GetSilentWitnessesForCrime((INTEGER)_CrimeID,(CHARACTERGUID)_Perpetrator,(STRING)_CrimeType,(GUIDSTRING)_Evidence,(CHARACTERGUID)_Victim)
		AND
		DB_MurderIgnoreFor((CHARACTERGUID)_Witness,(CHARACTERGUID)_Victim)
		THEN
		DB_CRIME_CrimeTriggers_SilentWitnessesForCrime(_Witness);
		//END_REGION
		
		//REGION Register the murder crime
		PROC
		ProcCrimeCreateMurder((CHARACTERGUID)_Killer,(CHARACTERGUID)_Victim,(INTEGER)_CrimeID)
		AND
		QryCrimeMurderGetCrimeType(_Killer,_Victim)
		AND
		DB_CrimeMurderCrimeType(_CrimeType)
		AND
		GetPosition(_Victim,_x,_y,_z)
		AND
		RealSum(_y,1.0,_yUp)
		THEN
		ProcCharacterRegisterCrimeWithPosition(_Killer,_CrimeType,NULL_00000000-0000-0000-0000-000000000000,NULL_00000000-0000-0000-0000-000000000000,_x,_yUp,_z,_CrimeID,_Victim);
		//END_REGION
		
		//REGION 1) Killed a non-enemy NPC outside of combat (one-shot, so combat did not have a chance to start)
		IF
		CharacterKilledBy(_Defender,_AttackerOwner,_Attacker)
		AND
		NOT DB_IsPlayer(_Defender)
		AND
		CharacterIsPlayer(_Attacker,1)
		AND
		CharacterIsPartyFollower(_Attacker,0)
		AND
		CharacterIsEnemy(_Defender,_Attacker,0)
		AND
		NOT DB_DontCreateMurder(_Defender)
		AND
		NOT QryCrimeKillerVictimWereInSameCombat(_Attacker,_Defender)
		AND
		QryCrimeCharacterCanCreateMurder(_Defender)
		AND
		CrimeGetNewID(_CrimeID)
		THEN
		DebugText(_Defender,"OneShot Murder Crime Scene");
		DB_CrimeMurderCreated(_Defender,_Attacker);
		ProcCrimeCreateMurder(_Attacker,_Defender,_CrimeID);
		//END_REGION
		
		//REGION 2) Killed an NPC while it was investigating
		IF
		CharacterKilledBy(_Defender,_AttackerOwner,_Attacker)
		AND
		NOT DB_CrimeMurderCreated(_Defender,_Attacker)
		AND
		NOT DB_IsPlayer(_Defender)
		AND
		NOT DB_DontCreateMurder(_Defender)
		AND
		DB_Crime_Assault(_,_,_Defender) // This DB Will be filled in if the character is still investigating
		AND
		QryCrimeCharacterCanCreateMurder(_Defender)
		AND
		CharacterIsPlayer(_Attacker,1)
		AND
		CharacterIsPartyFollower(_Attacker,0)
		AND
		CrimeGetNewID(_CrimeID)
		THEN
		DebugText(_Defender,"Mid Investigate Murder Crime Scene");
		ProcCrimeCreateMurder(_Attacker,_Defender,_CrimeID);
		//END_REGION
		
		//REGION 3) Killed an NPC in a combat following an assault crime
		// Current logic:
		//  - Create a murder for any NPC that you kill in this combat
		//  - This murder is, however, ignored by anyone within a 25 metre range that was not in combat
		// Reasoning: the characters that joined in the combat due to the assault, presumably would
		// have done the same for murder. The ones that did not, might not join for murder either. They also
		// might, but we don't have a good way to determine this. Creating a murder in this case can easily
		// lead to an avalache where a whole city starts fighting a player, which is not good -> be very
		// restrictive about who will care about such a murder
		//
		// Don't check for CharacterIsEnemy(_NPC,0), because when someone attacks you after you assaulted them,
		// they will obviously be an enemty to you.
		IF
		CharacterKilledBy(_Defender,_AttackerOwner,_Attacker)
		AND
		NOT DB_CrimeMurderCreated(_Defender,_Attacker)
		AND
		// This DB is set after an assault crime, and also for other
		// characters that join a combat in which an assault victim is involved
		DB_Crime_PlayerAttacked(_,_,_Defender)
		AND
		DB_CombatCharacters(_Defender,_ID)
		AND
		NOT DB_IsPlayer(_Defender)
		AND
		NOT DB_DontCreateMurder(_Defender)
		AND
		CharacterIsPlayer(_Attacker,1)
		AND
		CharacterIsPartyFollower(_Attacker,0)
		AND
		QryCrimeCharacterCanCreateMurder(_Defender)
		AND
		CrimeGetNewID(_CrimeID)
		AND
		IntegertoString(_CrimeID,_Iterator)
		AND
		StringConcatenate(_Iterator,"GEB_IgnoreCrime",_IteratorID)
		THEN
		DebugText(_Defender,"Assault murder scene");
		DB_CrimeMurderSilentWitnessCollectionContext(_CrimeID,_Defender,_IteratorID,_Attacker);
		CharacterLaunchIteratorAroundObject(_Defender,25.0,_IteratorID);
		
		PROC
		ProcCrimeMurderMaybeMakeSilentWitness((INTEGER)_CrimeID,(CHARACTERGUID)_Witness,(CHARACTERGUID)_Killer,(CHARACTERGUID)_Victim)
		AND
		NOT DB_CombatCharacters(_Witness,_)
		THEN
		ProcCrimeMurderDefineSilentWitness(_CrimeID,_Witness,_Killer,_Victim);
		
		// Allies let allies commit murders! That's what real friendship is all about.
		PROC
		ProcCrimeMurderMaybeMakeSilentWitness((INTEGER)_CrimeID,(CHARACTERGUID)_Witness,(CHARACTERGUID)_Killer,(CHARACTERGUID)_Victim)
		AND
		DB_CombatCharacters(_Witness,_)
		AND
		CharacterIsAlly(_Witness,_Killer,1)
		THEN
		ProcCrimeMurderDefineSilentWitness(_CrimeID,_Witness,_Killer,_Victim);
		
		// Neutral against killer -> not attacking now -> should not care afterwards either
		PROC
		ProcCrimeMurderMaybeMakeSilentWitness((INTEGER)_CrimeID,(CHARACTERGUID)_Witness,(CHARACTERGUID)_Killer,(CHARACTERGUID)_Victim)
		AND
		DB_CombatCharacters(_Witness,_)
		AND
		CharacterIsNeutral(_Witness,_Killer,1)
		THEN
		ProcCrimeMurderDefineSilentWitness(_CrimeID,_Witness,_Killer,_Victim);
		
		// An ally of my ally is my friend (e.g. Butter in Fort Joy is only allied to the player that charmed her).
		PROC
		ProcCrimeMurderMaybeMakeSilentWitness((INTEGER)_CrimeID,(CHARACTERGUID)_Witness,(CHARACTERGUID)_Killer,(CHARACTERGUID)_Victim)
		AND
		DB_CombatCharacters(_Witness,_)
		AND
		DB_IsPlayer(_Player)
		AND
		CharacterIsAlly(_Witness,_Player,1)
		AND
		CharacterIsAlly(_Player,_Killer,1)
		THEN
		ProcCrimeMurderDefineSilentWitness(_CrimeID,_Witness,_Killer,_Victim);
		
		// Ignore murder seen in combat
		IF
		StoryEvent((CHARACTERGUID)_NPC,_IteratorID)
		AND
		DB_CrimeMurderSilentWitnessCollectionContext(_CrimeID,_DeadMan,_IteratorID,_Killer)
		AND
		_NPC != NULL_00000000-0000-0000-0000-000000000000
		AND
		NOT DB_dead((CHARACTERGUID)_NPC)
		THEN
		ProcCrimeMurderMaybeMakeSilentWitness(_CrimeID,_NPC,_Killer,_DeadMan);
		
		// Create Murder (Last NPC in the Iterator is NULL_00000000-0000-0000-0000-000000000000)
		IF
		StoryEvent(_NPC,_IteratorID)
		AND
		DB_CrimeMurderSilentWitnessCollectionContext(_CrimeID,_DeadMan,_IteratorID,_Killer)
		AND
		_NPC == NULL_00000000-0000-0000-0000-000000000000
		THEN
		NOT DB_CrimeMurderSilentWitnessCollectionContext(_CrimeID,_DeadMan,_IteratorID,_Killer);
		DebugText(_DeadMan,"Normal Murder Crime Scene");
		ProcCrimeCreateMurder(_Killer,_DeadMan,_CrimeID);
		
		QRY
		Qry_HasDontCreateMurderInCombat((INTEGER)_ID)
		AND
		DB_CombatCharacters(_NPCS,_ID)
		AND
		DB_DontCreateMurder((CHARACTERGUID)_NPCS)
		THEN
		DB_NOOP(1);
		
		// One DB_DontCreateMurder() NPC in a combat -> killing others that join the combat should not create murders either
		// (TODO: check that they're allies of one of the DB_DontCreateMurder() NPCs -- especially now that neutrals don't
		//  join random combats anymore)
		IF
		ObjectEnteredCombat(_Obj,_ID)
		AND
		ObjectIsCharacter(_Obj,1)
		AND
		Qry_HasDontCreateMurderInCombat(_ID)
		AND
		DB_CombatCharacters(_NPC,_ID)
		AND
		NOT DB_IsPlayer(_NPC)
		AND
		NOT DB_DontCreateMurder(_NPC)
		THEN
		DB_DontCreateMurder(_NPC);
		DB_CrimeCreateMurderAfterCombat(_NPC,_ID);
		DebugText(_NPC," Killing me won't create a murder in this combat, because I joined a combat with others whose murder gets ignored");
		
		IF
		ObjectSwitchedCombat((CHARACTERGUID)_NPC,_OldCombatID,_NewCombatID)
		AND
		DB_CrimeCreateMurderAfterCombat(_NPC,_OldCombatID)
		THEN
		NOT DB_CrimeCreateMurderAfterCombat(_NPC,_OldCombatID);
		DB_CrimeCreateMurderAfterCombat(_NPC,_NewCombatID);
		
		IF
		CombatEnded(_CombatID)
		AND
		DB_CrimeCreateMurderAfterCombat(_NPC,_CombatID)
		THEN
		NOT DB_CrimeCreateMurderAfterCombat(_NPC,_CombatID);
		NOT DB_DontCreateMurder(_NPC);
		
		IF
		ObjectEnteredCombat(_NPC,_)
		AND
		ObjectIsCharacter(_NPC,1)
		THEN
		ProcCrimeAddToAttackedDBIfAssaultCombat((CHARACTERGUID)_NPC);
		
		IF
		ObjectSwitchedCombat(_NPC,_,_)
		AND
		ObjectIsCharacter(_NPC,1)
		THEN
		ProcCrimeAddToAttackedDBIfAssaultCombat((CHARACTERGUID)_NPC);
		
		IF
		DB_Crime_PlayerAttacked(_CrimeID,_Player,_NPC)
		THEN
		ProcCrimeAddToAttackedDBIfAssaultCombat((CHARACTERGUID)_NPC);
		
		PROC
		ProcCrimeAddToAttackedDBIfAssaultCombat((CHARACTERGUID)_NPC)
		AND
		DB_CombatCharacters(_NPC,_ID)
		AND
		DB_Crime_PlayerAttacked(_CrimeID,_Player,_OrigVic)
		AND
		DB_CombatCharacters(_Player,_ID)
		AND
		DB_CombatCharacters(_NPC2,_ID)
		AND
		NOT DB_Crime_PlayerAttacked(_CrimeID,_Player,_NPC2)
		AND
		CharacterIsPlayer(_NPC2,0)
		AND
		CharacterIsAlly(_OrigVic,_NPC2,1)
		THEN
		DB_Crime_PlayerAttacked(_CrimeID,_Player,_NPC2);
		DebugText(_NPC2," Killing me will create a murder scene (probably joined combat to help assaulted NPC), although it will be ignored by anyone within a 25m radius of this combat");
		
		IF
		ObjectLeftCombat((CHARACTERGUID)_NPC,_)
		AND
		DB_Crime_PlayerAttacked(_CrimeID,_Player,_NPC)
		THEN
		NOT DB_Crime_PlayerAttacked(_CrimeID,_Player,_NPC);
		
		IF
		OnCrimeMergedWith(_Old,_New)
		AND
		DB_CrimeMurderSilentWitnessCollectionContext(_Old,_DeadMan,_IteratorID,_Killer)
		THEN
		NOT DB_CrimeMurderSilentWitnessCollectionContext(_Old,_DeadMan,_IteratorID,_Killer);
		DB_CrimeMurderSilentWitnessCollectionContext(_New,_DeadMan,_IteratorID,_Killer);
		
		IF
		OnCrimeMergedWith(_Old,_New)
		AND
		DB_CrimeSilentWitness(_Old,_CrimeType,_NPC)
		THEN
		NOT DB_CrimeSilentWitness(_Old,_CrimeType,_NPC);
		DB_CrimeSilentWitness(_New,_CrimeType,_NPC);
		//END_REGION
		
		//REGION Reset DB_CrimeMurderCreated
		IF
		CharacterKilledBy(_Defender,_AttackerOwner,_Attacker)
		AND
		DB_CrimeMurderCreated(_Defender,_Attacker)
		THEN
		NOT DB_CrimeMurderCreated(_Defender,_Attacker);
		//END_REGION
		
		//END_REGION
		
		//REGION Pickpocket
		
		IF
		RequestPickpocket(_Player,_Npc)
		AND
		DB_CannotPickpocketTags(_Tag)
		AND
		IsTagged(_Npc, _Tag, 1)
		AND
		CharacterIsPartyMember(_Npc, 0)
		THEN
		DB_PickpocketingBlocked(1);
		Proc_StartDialog(1,"GEB_AD_CannotPickpocket",_Player);
		
		IF
		RequestPickpocket(_Player,_Npc)
		AND
		NOT DB_PickpocketingBlocked(1)
		THEN
		RemoveStatus(_Player,"INVISIBLE");
		
		IF
		CharacterPickpocketFailed(_Player,_)
		THEN
		RemoveStatus(_Player,"INVISIBLE");
		
		
		IF
		RequestPickpocket(_Player,_Npc)
		AND
		DB_PickpocketingBlocked(1)
		THEN
		StartPickpocket(_Player,_Npc,0);
		
		IF
		RequestPickpocket(_Player,_Npc)
		AND
		NOT DB_PickpocketingBlocked(1)
		AND
		CharacterIsPartyMember(_Npc, 0)
		THEN
		GenTradeItems(_Player,_Npc);
		StartPickpocket(_Player,_Npc,1);
		
		IF
		RequestPickpocket(_Player,_Npc)
		THEN
		NOT DB_PickpocketingBlocked(1);
		
		IF
		RequestPickpocket(_Player,_OtherPlayer)
		AND
		CharacterIsPartyMember(_OtherPlayer, 1)
		THEN
		StartPickpocket(_Player,_OtherPlayer,1);
		
		
		//--- PICKPOCKET SUCCESS
		IF
		CharacterPickpocketSuccess(_Thief,_Victim,_Item,_Amount) //TODO: Only trigger on HighValueItems
		AND
		CharacterIsCrimeEnabled(_Victim,"EmptyPocketNoticed",1)
		AND
		CharacterCanSpotCrimes(_Victim,1)
		AND
		Random(10000,_Rand)
		AND
		IntegerSum(_Rand,5000,_Time)
		THEN
		DB_Pickpocketed(_Thief,_Victim,_Item);
		ProcObjectTimerCancel(_Victim,"CRIME_Pickpocket_CheckPockets");
		ProcObjectTimer(_Victim,"CRIME_Pickpocket_CheckPockets",_Time);
		
		
		PROC
		ProcObjectTimerFinished((CHARACTERGUID)_Victim,"CRIME_Pickpocket_CheckPockets")
		AND
		CharacterIsDead(_Victim,0)
		AND
		IsSpeakerReserved(_Victim,1) // Victim is in dialog, restart timer to delay reaction
		AND
		Random(10000,_Rand)
		AND
		IntegerSum(_Rand,5000,_Time)
		THEN
		ProcObjectTimerCancel(_Victim,"CRIME_Pickpocket_CheckPockets");
		ProcObjectTimer(_Victim,"CRIME_Pickpocket_CheckPockets",_Time);
		
		PROC
		ProcObjectTimerFinished((CHARACTERGUID)_Victim,"CRIME_Pickpocket_CheckPockets")
		AND
		QRY_SpeakerIsAvailable(_Victim)
		AND
		DB_Pickpocketed(_Thief,_Victim,_)
		AND
		QueryOnlyOnce("CRIME_Pickpocket_PlayAnimation")
		THEN
		RemoveStatus(_Victim,"SITTING");
		RemoveStatus(_Victim,"LYING");
		PlayAnimation(_Victim,"PickPocket_01");
		
		PROC
		ProcObjectTimerFinished((CHARACTERGUID)_Victim,"CRIME_Pickpocket_CheckPockets")
		AND
		QRY_SpeakerIsAvailable(_Victim)
		AND
		DB_Pickpocketed(_Thief,_Victim,_Item)
		AND
		GetPosition(_Victim,_x,_y,_z)
		THEN
		NOT DB_OnlyOnce("CRIME_Pickpocket_PlayAnimation");
		NOT DB_Pickpocketed(_Thief,_Victim,_Item);
		CharacterRegisterCrimeWithPosition(_Thief,"EmptyPocketNoticed",_Item,_Victim,_x,_y,_z,0);
		
		
		//--- PICKPOCKET FAIL
		//--- Don't create a crime if it failed because of a tag
		IF
		CharacterPickpocketFailed(_Player,_Npc)
		AND
		CharacterIsPartyMember(_Npc, 0)
		AND
		DB_CannotPickpocketTags(_Tag)
		AND
		IsTagged(_Npc, _Tag, 1)
		THEN
		DB_PickpocketingBlocked(1);
		
		//--- Check if player already stole items on that NPC
		//--- Pass the item as evidence if it's the case.
		IF
		CharacterPickpocketFailed(_Player,_Npc)
		AND
		NOT DB_PickpocketingBlocked(1)
		AND
		CharacterIsPartyMember(_Npc, 0)
		THEN
		ProcCrimePickpocketFailedFlow(_Player,_Npc);
		
		PROC
		ProcCrimePickpocketFailedFlow((CHARACTERGUID)_Player,(CHARACTERGUID)_Npc)
		THEN
		ProcObjectTimerCancel(_Npc,"CRIME_Pickpocket_CheckPockets");
		
		PROC
		ProcCrimePickpocketFailedFlow((CHARACTERGUID)_Player,(CHARACTERGUID)_Npc)
		AND
		CharacterIsCrimeEnabled(_Npc,"PickPocketFailed",1)
		THEN
		RemoveStatus(_Player,"SNEAKING");
		RemoveStatus(_Npc,"SLEEPING");
		RemoveStatus(_Npc,"LYING");
		
		PROC
		ProcCrimePickpocketFailedFlow((CHARACTERGUID)_Player,(CHARACTERGUID)_Npc)
		AND
		NOT DB_Pickpocketed(_Player,_Npc,_)
		THEN
		ProcRegisterPickPocketFailed(_Player,_Npc,NULL_00000000-0000-0000-0000-000000000000);
		
		PROC
		ProcCrimePickpocketFailedFlow((CHARACTERGUID)_Player,(CHARACTERGUID)_Npc)
		AND
		DB_Pickpocketed(_Player,_Npc,_)
		AND
		QryCrimeWarningPickPocketFailed_NpcDoesNOTCheckEvidence(_Npc)
		AND
		NOT DB_PickpocketFailedNoEvidenceRegistered(1)
		THEN
		DB_PickpocketFailedNoEvidenceRegistered(1);
		ProcRegisterPickPocketFailed(_Player,_Npc,NULL_00000000-0000-0000-0000-000000000000);
		
		PROC
		ProcCrimePickpocketFailedFlow((CHARACTERGUID)_Player,(CHARACTERGUID)_Npc)
		THEN
		NOT DB_PickpocketFailedNoEvidenceRegistered(1);
		
		// pass item as evidence if NPC must perform a search
		PROC
		ProcCrimePickpocketFailedFlow((CHARACTERGUID)_Player,(CHARACTERGUID)_Npc)
		AND
		DB_Pickpocketed(_Player,_Npc,_Item)
		AND
		NOT QryCrimeWarningPickPocketFailed_NpcDoesNOTCheckEvidence(_Npc)
		THEN
		ProcRegisterPickPocketFailed(_Player,_Npc,_Item);
		NOT DB_Pickpocketed(_Player,_Npc,_Item);
		
		PROC
		ProcRegisterPickPocketFailed((CHARACTERGUID)_Player,(CHARACTERGUID)_Npc,(GUIDSTRING)_Evidence)
		AND
		GetPosition(_Npc,_X,_Y,_Z)
		AND
		RealSum(_Y,1.0,_YUp)
		THEN
		CharacterRegisterCrimeWithPosition(_Player,"PickPocketFailed",_Evidence,_Npc,_X,_YUp,_Z,0);
		
		QRY
		QryCrimeWarningPickPocketFailed_NpcDoesNOTCheckEvidence((CHARACTERGUID)_Npc)
		AND
		CharacterIsPartyMember(_Npc, 0)
		AND
		NOT QryNPCIsGuard(_Npc)
		THEN
		DB_NOOP(1);
		
		PROC
		ProcCrimePickpocketFailedFlow((CHARACTERGUID)_Player,(CHARACTERGUID)_Npc)
		THEN
		NOT DB_PickpocketingBlocked(1);
		
		
		//END_REGION
		
		//REGION NPC Draw Weapons
		// -------------------------- CRIME_Draw Reaction ----------------------------->
		IF
		CharacterOnCrimeSensibleActionNotification(_NPC,_,_CrimeID,"CRIME_Draw",_,_Criminal,_Criminal2,_Criminal3,_Criminal4,_)
		AND
		NOT DB_CombatCharacters(_Criminal,_)
		AND
		NOT DB_CombatCharacters(_NPC,_)
		AND
		NOT DB_NPCDrawForCrimial(_NPC,_CrimeID,_Criminal)
		AND
		CharacterCanSee(_NPC,_Criminal,_)
		THEN
		DB_NPCDrawForCrimial(_NPC,_CrimeID,_Criminal);
		
		IF
		CharacterLostSightOfCharacter(_NPC,_Criminal)
		AND
		NOT DB_CombatCharacters(_NPC,_)
		AND
		DB_NPCDrawForCrimial(_NPC,_CrimeID,_Criminal)
		THEN
		CharacterSetFightMode(_NPC,0,0);
		NOT DB_NPCDrawForCrimial(_NPC,_CrimeID,_Criminal);
		
		// -------------------------- WeaponsDrawn Crime ----------------------------->
		PROC
		ProcStoreFightMode((CHARACTERGUID)_Npc)
		AND
		NOT DB_FightModeState(_Npc,_)
		AND
		CharacterIsInFightMode(_Npc,_FightMode)
		THEN
		DB_FightModeState(_Npc,_FightMode);
		
		PROC
		ProcRestoreFightMode((CHARACTERGUID)_Npc)
		AND
		DB_FightModeState(_Npc,_State)
		AND
		NOT DB_CombatCharacters(_NPC,_)
		THEN
		CharacterSetFightMode(_Npc,_State,0);
		NOT DB_FightModeState(_Npc,_State);
		
		IF
		StoryEvent(_Npc,"CRIME_RestoreUnsheath")
		AND
		ObjectExists(_Npc,1)
		THEN
		ProcRestoreFightMode((CHARACTERGUID)_Npc);
		
		IF
		CharacterOnCrimeSensibleActionNotification(_NPC,_,_CrimeID,_,_,_Criminal,_Criminal2,_Criminal3,_Criminal4,_)
		AND
		NOT DB_CombatCharacters(_NPC,_)
		AND
		CrimeGetType(_CrimeID,"WeaponsDrawn")
		AND
		NOT DB_NPCSheathWeapon(_NPC,_Criminal)
		THEN
		DB_NPCSheathWeapon(_NPC,_Criminal);
		DB_NPCSheathWeapon(_NPC,_Criminal2);
		DB_NPCSheathWeapon(_NPC,_Criminal3);
		DB_NPCSheathWeapon(_NPC,_Criminal4);
		NOT DB_NPCSheathWeapon(_NPC,NULL_00000000-0000-0000-0000-000000000000);
		ProcStoreFightMode(_Npc);
		CharacterSetFightMode(_NPC,1,0);
		
		IF
		CharacterStatusRemoved(_Player,"UNSHEATHED",_)
		AND
		DB_IsPlayer(_Player)
		AND
		DB_NPCSheathWeapon(_NPC,_Player)
		AND
		NOT DB_CombatCharacters(_NPC,_)
		THEN
		NOT DB_NPCSheathWeapon(_NPC,_Player);
		ProcCrimeCheckIfPlayersWeaponsOut((CHARACTERGUID)_NPC);
		
		PROC
		ProcCrimeCheckIfPlayersWeaponsOut((CHARACTERGUID)_NPC)
		AND
		NOT DB_NPCSheathWeapon(_NPC,_)
		AND
		NOT DB_CombatCharacters(_NPC,_)
		THEN
		ProcRestoreFightMode(_NPC);
		SetStoryEvent(_NPC,"NPCReturnToOrginalPos");
		
		IF
		ObjectLeftCombat((CHARACTERGUID)_NPC,_)
		AND
		DB_NPCSheathWeapon(_NPC,_)
		AND
		ObjectExists(_NPC,1)
		AND
		CharacterIsDead(_NPC,0)
		THEN
		ProcRestoreFightMode(_NPC);
		
		IF
		CharacterLostSightOfCharacter(_NPC,_Player)
		AND
		DB_NPCSheathWeapon(_NPC,_Player)
		THEN
		NOT DB_NPCSheathWeapon(_NPC,_Player);
		ProcCrimeCheckIfPlayersWeaponsOut(_NPC);
		
		IF
		DB_BlockThreatenedDialog((CHARACTERGUID)_Char)
		THEN
		CharacterDisableCrime(_Char,"WeaponsDrawn");
		DB_CheckWeaponsDrawnCrime(_Char);
		
		IF
		DB_CheckWeaponsDrawnCrime((CHARACTERGUID)_Char)
		AND
		NOT DB_BlockThreatenedDialog(_Char)
		AND
		NOT DB_CharacterCrimeDisabled(_Char,"WeaponsDrawn")
		THEN
		CharacterEnableCrime(_Char,"WeaponsDrawn");
		
		//END_REGION
		
		//REGION Sneaking Spotted
		IF
		CharacterSawSneakingCharacter(_NPC,_Player)
		AND
		CharacterIsPlayer(_NPC,0)
		THEN
		CharacterRegisterCrime(_Player,"Sneaking",NULL_00000000-0000-0000-0000-000000000000,_NPC,0);
		//END_REGION
		
		//REGION Vandalise - AttackItem
		QRY
		QRY_Crime_ItemHasHPorIndestructible((ITEMGUID)_Item)
		AND
		ItemIsDestructible(_Item,0)
		THEN
		DB_NOOP(1);
		
		QRY
		QRY_Crime_ItemHasHPorIndestructible((ITEMGUID)_Item)
		AND
		ItemIsDestructible(_Item,1)
		AND
		ItemGetHealthPoints(_Item,_INT)
		AND
		_INT > 0
		THEN
		DB_NOOP(1);
		
		//--- 1) Item attacked
		IF
		AttackedByObject((ITEMGUID)_Item,(CHARACTERGUID)_Player,(CHARACTERGUID)_Summon,_,_DamageSource)
		AND
		NOT QryIgnoreDamageSource(_DamageSource)
		AND
		ObjectIsItem(_Item,1)
		AND
		CharacterIsPlayer(_Player,1)
		AND
		QRY_Crime_ItemHasHPorIndestructible(_Item)
		THEN
		ProcCrimeVandaliseCheckOwner(_Item,_Player,_Summon);
		
		//--- 2) Check if the item has an owner
		PROC
		ProcCrimeVandaliseCheckOwner((ITEMGUID)_Item,(CHARACTERGUID)_Player,(CHARACTERGUID)_Summon)
		AND
		ItemGetOwner(_Item,_Owner)
		AND
		_Owner != NULL_00000000-0000-0000-0000-000000000000
		AND
		CharacterIsPlayer(_Owner,0)
		THEN
		ProcCrimeVandaliseCheckVandal(_Item,_Owner,_Player,_Summon,"");
		
		PROC
		ProcCrimeVandaliseCheckOwner((ITEMGUID)_Item,(CHARACTERGUID)_Player,(CHARACTERGUID)_Summon)
		AND
		ItemGetOwner(_Item,_Owner)
		AND
		_Owner == NULL_00000000-0000-0000-0000-000000000000
		AND
		NOT QryCheckforVandaliseTags(_Item)
		THEN
		ProcCrimeVandaliseCheckVandal(_Item,NULL_00000000-0000-0000-0000-000000000000,_Player,_Summon,"NoOwner");
		
		
		//--- 3) Check if the vandal is a summon
		PROC
		ProcCrimeVandaliseCheckVandal((ITEMGUID)_Item,(CHARACTERGUID)_Owner,(CHARACTERGUID)_Player,(CHARACTERGUID)_Summon,(STRING)_Postfix)
		AND
		NOT QRY_CharacterIsNull(_Summon)
		AND
		CharacterIsSummon(_Summon,1)
		AND
		QryShouldTriggerVandaliseCrime(_Item,_Summon)
		AND
		NOT DB_Crime_Vandalise((CHARACTERGUID)_Summon,(ITEMGUID)_Item,(INTEGER)_)
		THEN
		ProcCrimeRegisterVandalise(_Item,_Owner,_Summon,"Summon",_Postfix);
		
		PROC
		ProcCrimeVandaliseCheckVandal((ITEMGUID)_Item,(CHARACTERGUID)_Owner,(CHARACTERGUID)_Player,(CHARACTERGUID)_Summon,(STRING)_Postfix)
		AND
		_Player == _Summon
		AND
		QryShouldTriggerVandaliseCrime(_Item,_Player)
		AND
		NOT DB_Crime_Vandalise(_Player,_Item,_)
		THEN
		ProcCrimeRegisterVandalise(_Item,_Owner,_Player,"",_Postfix);
		
		
		//--- 4) Concatenate the crime's name & register it
		PROC
		ProcCrimeRegisterVandalise((ITEMGUID)_Item,(CHARACTERGUID)_Owner,(CHARACTERGUID)_Vandal)
		THEN
		ProcCrimeRegisterVandalise(_Item,_Owner,_Vandal,"","");
		
		PROC
		ProcCrimeRegisterVandalise((ITEMGUID)_Item,(CHARACTERGUID)_Owner,(CHARACTERGUID)_Vandal,(STRING)_Prefix,(STRING)_Postfix)
		AND
		StringConcatenate(_Prefix,"Vandalise",_Part1)
		AND
		StringConcatenate(_Part1,_Postfix,_CrimeName)
		AND
		GetPosition(_Item,_x,_y,_z)
		AND
		RealSum(_y,1.0,_yUp)
		AND
		CrimeGetNewID(_CrimeID)
		THEN
		DB_Crime_Vandalise(_Vandal,_Item,_CrimeID);
		CharacterRegisterCrimeWithPosition(_Vandal,_CrimeName,_Item,_Owner,_x,_yUp,_z,_CrimeID);
		
		
		QRY
		QryCheckforVandaliseTags((ITEMGUID)_Item)
		AND
		DB_IgnoreVandaliseTag((STRING)_Tag)
		AND
		IsTagged(_Item,_Tag,1)
		THEN
		DB_NOOP(1);
		
		QRY
		QryShouldTriggerVandaliseCrime((ITEMGUID)_Item,(CHARACTERGUID)_Player)
		AND
		NOT DB_CombatCharacters(_Player,_)
		THEN
		DB_NOOP(1);
		
		QRY
		QryShouldTriggerVandaliseCrime((ITEMGUID)_Item,(CHARACTERGUID)_Player)
		AND
		DB_TriggerVandaliseInCombat(_Item)
		THEN
		DB_NOOP(1);
		
		IF
		OnCrimeMergedWith(_Old,_New)
		AND
		DB_Crime_Vandalise(_Player,_Item,_Old)
		THEN
		NOT DB_Crime_Vandalise(_Player,_Item,_Old);
		DB_Crime_Vandalise(_Player,_Item,_New);
		
		QRY
		QryCheckforVandaliseTags((ITEMGUID)_Item)
		AND
		DB_IgnoreVandaliseTag((STRING)_Tag)
		AND
		IsTagged(_Item,_Tag,1)
		THEN
		DB_NOOP(1);
		
		//REGION Resolve Vandalise
		IF
		OnCrimeRemoved(_CrimeID,_Victim,_Criminal1,_Criminal2,_Criminal3,_Criminal4)
		THEN
		ProcCrimeClearVandaliseDB(_Criminal1,_CrimeID);
		ProcCrimeClearVandaliseDB(_Criminal2,_CrimeID);
		ProcCrimeClearVandaliseDB(_Criminal3,_CrimeID);
		ProcCrimeClearVandaliseDB(_Criminal4,_CrimeID);
		
		IF
		OnCrimeResolved(_CrimeID,_Victim,_Criminal1,_Criminal2,_Criminal3,_Criminal4)
		AND
		CrimeGetType(_CrimeID,"Vandalise")
		THEN
		ProcCrimeClearVandaliseDB(_Criminal1,_CrimeID);
		ProcCrimeClearVandaliseDB(_Criminal2,_CrimeID);
		ProcCrimeClearVandaliseDB(_Criminal3,_CrimeID);
		ProcCrimeClearVandaliseDB(_Criminal4,_CrimeID);
		
		IF
		OnCrimeResolved(_CrimeID,_Victim,_Criminal1,_Criminal2,_Criminal3,_Criminal4)
		AND
		CrimeGetType(_CrimeID,"VandaliseNoOwner")
		THEN
		ProcCrimeClearVandaliseDB(_Criminal1,_CrimeID);
		ProcCrimeClearVandaliseDB(_Criminal2,_CrimeID);
		ProcCrimeClearVandaliseDB(_Criminal3,_CrimeID);
		ProcCrimeClearVandaliseDB(_Criminal4,_CrimeID);
		
		PROC
		ProcCrimeClearVandaliseDB((CHARACTERGUID)_Player,(INTEGER)_CrimeID)
		AND
		DB_Crime_Vandalise(_Player,_Item,_CrimeID)
		THEN
		NOT DB_Crime_Vandalise(_Player,_Item,_CrimeID);
		//END_REGION
		//END_REGION
		
		//REGION Vandalise - Destroy Item
		
		IF
		AttackedByObject((ITEMGUID)_Item,(CHARACTERGUID)_Player,(CHARACTERGUID)_Summon,_,_DamageSource)
		AND
		NOT QryIgnoreDamageSource(_DamageSource)
		AND
		ObjectIsItem(_Item,1)
		AND
		CharacterIsPlayer(_Player,1)
		AND
		NOT DB_CombatCharacters(_Player,_)
		AND
		ItemIsDestructible(_Item,1)
		AND
		ItemGetHealthPoints(_Item,_INT)
		AND
		_INT < 1
		AND
		NOT DB_Crime_ItemDestroyed(_Item,_Player)
		AND
		ItemGetOwner(_Item,_Owner)
		AND
		_Owner != NULL_00000000-0000-0000-0000-000000000000
		AND
		CharacterIsPlayer(_Owner,0)
		THEN
		ProcCrimeItemDestroyCheckVandal(_Item,_Owner,_Player,_Summon);
		
		//2. check the criminal
		PROC
		ProcCrimeItemDestroyCheckVandal((ITEMGUID)_Item,(CHARACTERGUID)_Owner,(CHARACTERGUID)_Player,(CHARACTERGUID)_Summon)
		AND
		NOT QRY_CharacterIsNull(_Summon)
		AND
		CharacterIsSummon(_Summon,1)
		AND
		QryShouldTriggerVandaliseCrime(_Item,_Summon)
		AND
		NOT DB_Crime_Vandalise((CHARACTERGUID)_Summon,(ITEMGUID)_Item,(INTEGER)_)
		THEN
		ProcCrimeRegisterItemDestroy(_Item,_Owner,_Summon,"Summon");
		
		PROC
		ProcCrimeItemDestroyCheckVandal((ITEMGUID)_Item,(CHARACTERGUID)_Owner,(CHARACTERGUID)_Player,(CHARACTERGUID)_Summon)
		AND
		_Player == _Summon
		AND
		QryShouldTriggerVandaliseCrime(_Item,_Player)
		AND
		NOT DB_Crime_Vandalise(_Player,_Item,_)
		THEN
		ProcCrimeRegisterItemDestroy(_Item,_Owner,_Player,"");
		
		//3. register the crime
		PROC
		ProcCrimeRegisterItemDestroy((ITEMGUID)_Item,(CHARACTERGUID)_Owner,(CHARACTERGUID)_Vandal,(STRING)_Prefix)
		AND
		StringConcatenate(_Prefix,"ItemDestroy",_CrimeName)
		AND
		GetPosition(_Item,_x,_y,_z)
		AND
		RealSum(_y,1.0,_yUp)
		THEN
		DB_Crime_ItemDestroyed(_Item,_Vandal);
		CharacterRegisterCrimeWithPosition(_Vandal,_CrimeName,_Item,_Owner,_x,_yUp,_z,0);
		
		//END_REGION
		
		//REGION Status Reaction
		IF
		CharacterStatusApplied(_Player,_Status,_)
		AND
		_Status != "UNSHEATHED"
		AND
		DB_IsPlayer(_Player)
		AND
		DB_StatusReaction(_Status,_Crime)
		AND
		HasActiveStatus(_Player,_Status,1)
		THEN
		DB_StatusReactingToPlayer(_Player,_Status);
		CharacterRegisterCrime(_Player,_Crime,NULL_00000000-0000-0000-0000-000000000000,NULL_00000000-0000-0000-0000-000000000000,0);
		
		IF
		CharacterStatusApplied(_Player,_Status,_)
		AND
		_Status == "UNSHEATHED"
		AND
		DB_IsPlayer(_Player)
		AND
		NOT DB_CombatCharacters(_Player,_)
		AND
		DB_StatusReaction(_Status,_Crime)
		AND
		HasActiveStatus(_Player,_Status,1)
		THEN
		DB_StatusReactingToPlayer(_Player,_Status);
		CharacterRegisterCrime(_Player,_Crime,NULL_00000000-0000-0000-0000-000000000000,NULL_00000000-0000-0000-0000-000000000000,0);
		
		
		IF
		CharacterStatusRemoved(_Player, _Status, _)
		AND
		DB_IsPlayer(_Player)
		AND
		DB_StatusReaction(_Status,_Crime)
		THEN
		CharacterStopCrime(_Player,_Crime,NULL_00000000-0000-0000-0000-000000000000);
		NOT DB_StatusReactingToPlayer(_Player,_Status);
		
		//END_REGION
		
		//REGION Is Not Messing Around
		IF
		DB_IsNotMessingAround((CHARACTERGUID)_Char)
		THEN
		DB_AttackOnAssault(_Char);
		SetTag(_Char,"NOT_MESSING_AROUND");
		ProcCharacterEnableCrime(_Char,"Assault");
		
		IF
		DB_RemoveIsNotMessingAround((CHARACTERGUID)_Char)
		THEN
		NOT DB_IsNotMessingAround(_Char);
		NOT DB_RemoveIsNotMessingAround(_Char);
		ClearTag(_Char,"NOT_MESSING_AROUND");
		
		IF
		DB_AttackOnAssault(_Char)
		AND
		NOT DB_IsNotMessingAround(_Char)
		THEN
		NOT DB_AttackOnAssault(_Char);
		ClearTag(_Char,"NOT_MESSING_AROUND");
		//END_REGION
		
		//REGION Attitude Change
		QRY
		QryNPCCaresAboutVictim((CHARACTERGUID)_NPC,(CHARACTERGUID)_Victim,(INTEGER)_)
		AND
		IsTagged(_NPC,"ANIMAL",1)
		AND
		IsTagged(_Victim,"ANIMAL",1)
		THEN
		DB_NOOP(1);
		
		QRY
		QryNPCCaresAboutVictim((CHARACTERGUID)_NPC,(CHARACTERGUID)_Victim,_Primary)
		AND
		IsTagged(_NPC,"ANIMAL",0)
		AND
		QryNonAnimalNPCCaresAboutVictim(_NPC,_Victim,_Primary)
		THEN
		DB_NOOP(1);
		
		
		QRY
		QryNonAnimalNPCCaresAboutVictim((CHARACTERGUID)_NPC,(CHARACTERGUID)_Victim,0)
		AND
		ObjectIsCharacter(_Victim,0)
		THEN
		DB_NOOP(1);
		
		QRY
		QryNonAnimalNPCCaresAboutVictim((CHARACTERGUID)_NPC,(CHARACTERGUID)_Victim,0)
		AND
		ObjectIsCharacter(_Victim,1)
		AND
		CharacterIsAlly(_NPC,_Victim,1)
		THEN
		DB_NOOP(1);
		
		QRY
		QryNonAnimalNPCCaresAboutVictim((CHARACTERGUID)_NPC,(CHARACTERGUID)_Victim,1)
		THEN
		DB_NOOP(1);
		
		IF
		CharacterOnCrimeSensibleActionNotification(_NPC,_Region,_CrimeID,_PriorityName,_Dialog,_Criminal,_Criminal2,_Criminal3,_Criminal4,_Primary)
		AND
		CrimeGetType(_CrimeID,_CrimeName)
		AND
		NOT DB_NPC_CrimeAttitude_DoNotChange(_NPC,_CrimeName)
		AND
		DB_CrimeAttitudeChange(_CrimeName,_AttitudeAmountToSub)
		AND
		CrimeGetVictim(_CrimeID,_Victim)
		THEN
		ProcCheckAdjustAttitude(_NPC,_Victim,_Criminal,_Criminal2,_Criminal3,_Criminal4,_AttitudeAmountToSub,_Primary);
		
		PROC
		ProcCheckAdjustAttitude((CHARACTERGUID)_NPC,(CHARACTERGUID)_Victim,(CHARACTERGUID)_Criminal,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(INTEGER)_AttitudeAmountToSub, (INTEGER)_Primary)
		AND
		QryNPCCaresAboutVictim(_NPC,_Victim,_Primary)
		THEN
		ProcCrimeCheckIfAttitudeCauseCombat(_NPC,_Criminal,_AttitudeAmountToSub);
		ProcCrimeCheckIfAttitudeCauseCombat(_NPC,_Criminal2,_AttitudeAmountToSub);
		ProcCrimeCheckIfAttitudeCauseCombat(_NPC,_Criminal3,_AttitudeAmountToSub);
		ProcCrimeCheckIfAttitudeCauseCombat(_NPC,_Criminal4,_AttitudeAmountToSub);
		
		PROC
		ProcCrimeCheckIfAttitudeCauseCombat((CHARACTERGUID)_NPC,(CHARACTERGUID)_Criminal,(INTEGER)_AttitudeAmountToSub)
		THEN
		CharacterAddAttitudeTowardsPlayer(_NPC,_Criminal,_AttitudeAmountToSub);
		
		PROC
		ProcCrimeCheckIfAttitudeCauseCombat((CHARACTERGUID)_NPC,(CHARACTERGUID)_Criminal,(INTEGER)_AttitudeAmountToSub)
		AND
		CharacterGetAttitudeTowardsPlayer(_NPC,_Criminal,_NPCCurrentAttitude)
		AND
		_NPCCurrentAttitude <= -75 //We Doin't want Lowering Attitude To Start Combat
		AND
		IntegerSubtract(-74,_NPCCurrentAttitude,_NewAttitudeToAdd)
		THEN
		CharacterAddAttitudeTowardsPlayer(_NPC,_Criminal,_NewAttitudeToAdd);
		
		//END_REGION
		
		//REGION Dialog interrupting
		
		QRY
		QRY_CrimeNPCUnAvailableForDialog((CHARACTERGUID)_NPC,(CHARACTERGUID)_Criminal,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4)
		AND
		IsSpeakerReserved(_NPC,1)
		THEN
		DB_NOOP(1);
		
		QRY
		QRY_CrimeNPCUnAvailableForDialog((CHARACTERGUID)_NPC,(CHARACTERGUID)_Criminal,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4)
		AND
		_Criminal != NULL_00000000-0000-0000-0000-000000000000
		AND
		IsSpeakerReserved(_Criminal,1)
		THEN
		DB_NOOP(1);
		
		QRY
		QRY_CrimeNPCUnAvailableForDialog((CHARACTERGUID)_NPC,(CHARACTERGUID)_Criminal,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4)
		AND
		_Criminal2 != NULL_00000000-0000-0000-0000-000000000000
		AND
		IsSpeakerReserved(_Criminal2,1)
		THEN
		DB_NOOP(1);
		
		QRY
		QRY_CrimeNPCUnAvailableForDialog((CHARACTERGUID)_NPC,(CHARACTERGUID)_Criminal,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4)
		AND
		_Criminal3 != NULL_00000000-0000-0000-0000-000000000000
		AND
		IsSpeakerReserved(_Criminal3,1)
		THEN
		DB_NOOP(1);
		
		QRY
		QRY_CrimeNPCUnAvailableForDialog((CHARACTERGUID)_NPC,(CHARACTERGUID)_Criminal,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4)
		AND
		_Criminal4 != NULL_00000000-0000-0000-0000-000000000000
		AND
		IsSpeakerReserved(_Criminal4,1)
		THEN
		DB_NOOP(1);
		
		QRY
		QRY_CrimeNPCUnAvailableForDialog((CHARACTERGUID)_NPC,(CHARACTERGUID)_Criminal,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4)
		AND
		CharacterIsDead(_NPC,1)
		THEN
		DB_NOOP(1);
		
		QRY
		QRY_CrimeNPCUnAvailableForDialog((CHARACTERGUID)_NPC,(CHARACTERGUID)_Criminal,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4)
		AND
		GetRegion(_NPC,_Region)
		AND
		NOT DB_CurrentLevel(_Region)
		THEN
		DB_NOOP(1);
		
		QRY
		QRY_CrimeNPCUnAvailableForDialog((CHARACTERGUID)_NPC,(CHARACTERGUID)_Criminal,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4)
		AND
		CombatGetIDForCharacter(_NPC,_ID)
		AND
		_ID!=0
		THEN
		DB_NOOP(1);
		
		QRY
		QRY_CrimeNPCUnAvailableForDialog((CHARACTERGUID)_NPC,(CHARACTERGUID)_Criminal,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4)
		AND
		CharacterIsEnemy(_NPC,_Criminal,1)
		THEN
		DB_NOOP(1);
		
		QRY
		QRY_CrimeNPCUnAvailableForDialog((CHARACTERGUID)_NPC,(CHARACTERGUID)_Criminal,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4)
		AND
		_Criminal2 != NULL_00000000-0000-0000-0000-000000000000
		AND
		CharacterIsEnemy(_NPC,_Criminal2,1)
		THEN
		DB_NOOP(1);
		
		QRY
		QRY_CrimeNPCUnAvailableForDialog((CHARACTERGUID)_NPC,(CHARACTERGUID)_Criminal,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4)
		AND
		_Criminal3 != NULL_00000000-0000-0000-0000-000000000000
		AND
		CharacterIsEnemy(_NPC,_Criminal3,1)
		THEN
		DB_NOOP(1);
		
		QRY
		QRY_CrimeNPCUnAvailableForDialog((CHARACTERGUID)_NPC,(CHARACTERGUID)_Criminal,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4)
		AND
		_Criminal4 != NULL_00000000-0000-0000-0000-000000000000
		AND
		CharacterIsEnemy(_NPC,_Criminal4,1)
		THEN
		DB_NOOP(1);
		
		PROC
		ProcTryStopDialogFor((CHARACTERGUID)_Char)
		AND
		_Char != NULL_00000000-0000-0000-0000-000000000000
		AND
		CharacterIsPlayer(_Char,1)
		AND
		DB_DialogPlayers(_Inst,_Char,_)
		AND
		DB_DialogName(_CurrentDialog,_Inst)
		AND
		NOT DB_Crime_DoNotStopDialog((STRING)_CurrentDialog)
		THEN
		DialogRequestStop(_Char);
		DB_StoppedDialog(1);
		
		PROC
		ProcTryStopDialogFor((CHARACTERGUID)_Char)
		AND
		_Char != NULL_00000000-0000-0000-0000-000000000000
		AND
		CharacterIsPlayer(_Char,0)
		AND
		DB_DialogNPCs(_Inst,_Char,_)
		AND
		DB_DialogName(_CurrentDialog,_Inst)
		AND
		NOT DB_Crime_DoNotStopDialog(_CurrentDialog)
		THEN
		DialogRequestStop(_Char);
		DB_StoppedDialog(1);
		
		PROC
		ProcCrimeInterruptStoryDialogs((INTEGER)_CrimeID,(STRING)_CrimeDialog,1,(CHARACTERGUID)_NPC,(CHARACTERGUID)_Criminal,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4)
		THEN
		ProcTryStopDialogFor(_NPC);
		ProcTryStopDialogFor(_Criminal);
		ProcTryStopDialogFor(_Criminal2);
		ProcTryStopDialogFor(_Criminal3);
		ProcTryStopDialogFor(_Criminal4);
		
		PROC
		ProcCrimeInterruptStoryDialogs(_,_,1,_,_,_,_,_)
		AND
		DB_StoppedDialog(1)
		THEN
		NOT DB_StoppedDialog(1);
		FireOsirisEvents();
		
		PROC
		ProcCrimeInterruptStoryDialogs((INTEGER)_CrimeID,(STRING)_CrimeDialog,0,(CHARACTERGUID)_NPC,(CHARACTERGUID)_Criminal,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4)
		AND
		DB_DialogNPCs(_Inst,_NPC,_)
		AND
		DB_DialogName(_CurrentDialog,_Inst)
		AND
		NOT DB_Crime_DoNotStopDialog(_CurrentDialog)
		THEN
		DialogRequestStop(_NPC);
		FireOsirisEvents();
		
		PROC
		ProcCrimeInterruptStoryDialogs((INTEGER)_CrimeID,(STRING)_CrimeDialog,0,(CHARACTERGUID)_NPC,(CHARACTERGUID)_Criminal,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4)
		AND
		NOT QRY_CrimeNPCUnAvailableForDialog(_NPC,NULL_00000000-0000-0000-0000-000000000000,NULL_00000000-0000-0000-0000-000000000000,NULL_00000000-0000-0000-0000-000000000000,NULL_00000000-0000-0000-0000-000000000000)
		THEN
		ProcStartCrimeDialog(_CrimeID,_CrimeDialog,0,_NPC,_Criminal,_Criminal2,_Criminal3,_Criminal4);
		
		PROC
		ProcCrimeInterruptStoryDialogs((INTEGER)_CrimeID,(STRING)_CrimeDialog,1,(CHARACTERGUID)_NPC,(CHARACTERGUID)_Criminal,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4)
		AND
		NOT QRY_CrimeNPCUnAvailableForDialog(_NPC,_Criminal,_Criminal2,_Criminal3,_Criminal4)
		THEN
		ProcStartCrimeDialog(_CrimeID,_CrimeDialog,1,_NPC,_Criminal,_Criminal2,_Criminal3,_Criminal4);
		
		PROC
		ProcHandleCrimeDialog((CHARACTERGUID)_Warner,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_CrimeDialog,1,_)
		AND
		DB_CheckInterrupt(_CrimeID,_Warner)
		THEN
		DB_Interrupted(_CrimeID,_Warner,1);
		
		PROC
		ProcHandleCrimeDialog((CHARACTERGUID)_Warner,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_CrimeDialog,1,_)
		AND
		DB_CheckInterrupt(_CrimeID,_Warner)
		THEN
		NOT DB_CheckInterrupt(_CrimeID,_Warner);
		
		PROC
		ProcStartCrimeDialog((INTEGER)_CrimeID,(STRING)_CrimeDialog,(INTEGER)_IsInteractive,(CHARACTERGUID)_NPC,(CHARACTERGUID)_Criminal,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4)
		THEN
		DB_NOOP(1);
		
		PROC
		ProcStartCrimeDialog((INTEGER)_CrimeID,(STRING)_CrimeDialog,1,(CHARACTERGUID)_NPC,(CHARACTERGUID)_Criminal,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4)
		AND
		DialogStartCrimeDialog(_CrimeID,_CrimeDialog,1,_NPC,_Criminal,_Criminal2,_Criminal3,_Criminal4,_Success)
		THEN
		DB_CheckInterrupt(_CrimeID,_NPC);
		DB_CrimeWarner(_CrimeID,_NPC,_CrimeDialog);
		ProcHandleCrimeDialog(_NPC,_Criminal,_Criminal2,_Criminal3,_Criminal4,_CrimeDialog,_Success,1);
		
		PROC
		ProcStartCrimeDialog((INTEGER)_CrimeID,(STRING)_CrimeDialog,0,(CHARACTERGUID)_NPC,(CHARACTERGUID)_Criminal,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4)
		AND
		DialogStartCrimeDialog(_CrimeID,_CrimeDialog,0,_NPC,NULL_00000000-0000-0000-0000-000000000000,NULL_00000000-0000-0000-0000-000000000000,NULL_00000000-0000-0000-0000-000000000000,NULL_00000000-0000-0000-0000-000000000000,_Success)
		AND
		CrimeGetType(_CrimeID,_CrimeType)
		THEN
		DB_Crime_WarningAD_Target(_CrimeType,_NPC,_Criminal); // in AD we don't have player, so to clear Warning flags, store target player in this DB
		DB_CheckInterrupt(_CrimeID,_NPC);
		CrimeConfrontationDone(_CrimeID,_NPC); // confrontation done for ADs
		ProcHandleCrimeDialog(_NPC,_Criminal,_Criminal2,_Criminal3,_Criminal4,_CrimeDialog,_Success,0);
		DB_Interrupted(_CrimeID,_NPC,1);
		
		PROC
		ProcCrimeInterruptStoryDialogs((INTEGER)_CrimeID,(STRING)_CrimeDialog,(INTEGER)_MarkForInteractive,(CHARACTERGUID)_NPC,(CHARACTERGUID)_Criminal,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4)
		AND
		NOT DB_Interrupted(_CrimeID,_NPC,1)
		THEN
		//NPC not available for dialog anymore
		DB_Crime_FailedToInterruptStoryDialogs((INTEGER)_CrimeId,(STRING)_CrimeDialog,(CHARACTERGUID)_NPC,(CHARACTERGUID)_Criminal,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4);
		
		PROC
		ProcCrimeInterruptStoryDialogs((INTEGER)_CrimeID,(STRING)_CrimeDialog,(INTEGER)_MarkForInteractive,(CHARACTERGUID)_NPC,(CHARACTERGUID)_Criminal,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4)
		THEN
		NOT DB_Interrupted(_CrimeID,_NPC,1);
		
		// Only stop an NPCs dialog without starting a new one
		PROC
		ProcCrimeTryForceStopDialog((CHARACTERGUID)_Char)
		THEN
		ProcTryStopDialogFor(_Char);
		
		PROC
		ProcCrimeTryForceStopDialog((CHARACTERGUID)_Char)
		AND
		DB_StoppedDialog(1)
		THEN
		NOT DB_StoppedDialog(1);
		// Ensure that if story wants to start a new dialog on DialogEnded, it
		// can do so before the crime system starts its own dialog
		FireOsirisEvents();
		
		//END_REGION
		
		//REGION -ForbiddenItem crime. Action Requests handling.
		
		/***************************************/
		//--- Crime reactions & Move crime
		/***************************************/
		IF
		DialogStarted("GEB_Warning_UseForbiddenItem",_Inst)
		AND
		DB_DialogPlayers(_Inst,_Player,1)
		AND
		DB_CRIME_ForbiddenStatus(_Status)
		AND
		HasActiveStatus(_Player,_Status,1)
		THEN
		RemoveStatus(_Player,_Status);
		
		IF
		CharacterUsedSkillOnTarget(_Player,_Item,_,"teleportation",_)
		AND
		CharacterIsPlayer(_Player,1)
		AND
		ObjectIsItem(_Item,1)
		AND
		ItemCanSitOn((ITEMGUID)_Item,0)
		AND
		ItemGetOwner(_Item,_Owner)
		AND
		NOT QRY_CharacterIsNull(_Owner)
		AND
		CharacterIsPlayer(_Owner,0)
		THEN
		CharacterRegisterCrime(_Player,"MoveForbiddenItem",_Item,(CHARACTERGUID)_Owner,0);
		
		PROC
		ProcCrimeTryRegisteringMoveForbiddenItem((CHARACTERGUID)_Player,(ITEMGUID)_Item,(INTEGER)_RequestID)
		AND
		CharacterIsPlayer(_Player,1)
		AND
		ItemCanSitOn(_Item,0)
		AND
		ItemGetOwner(_Item,_Owner)
		AND
		NOT QRY_CharacterIsNull(_Owner)
		AND
		CharacterIsPlayer(_Owner,0)
		AND
		CharacterIsSummon(_Player,_IsSummon)
		AND
		DB_CRIME_MoveForbiddenCrime(_IsSummon, _CrimeName)
		THEN
		ProcSendMoveRequestResult(_Player,_Item,_RequestID);
		CharacterRegisterCrime(_Player,_CrimeName,_Item,(CHARACTERGUID)_Owner,0);
		DB_MoveCrimeRegistered(1);
		
		PROC
		ProcSendMoveRequestResult((CHARACTERGUID)_Player,(ITEMGUID)_Item,(INTEGER)_RequestID)
		AND
		GetPosition(_Item,_X,_Y,_Z)
		AND
		ItemGetOwner(_Item,_Owner)
		AND
		CrimeIsAnyNPCGoingToReact(_Player,"MoveForbiddenItem",_Owner,_X,_Y,_Z,_Result)
		AND
		DB_Negate(_Result,_Inverse)
		THEN
		RequestProcessed(_Player,_RequestID,_Inverse);
		
		PROC
		ProcCrimeTryRegisteringMoveForbiddenItem((CHARACTERGUID)_Player,(ITEMGUID)_Item,(INTEGER)_RequestID)
		AND
		NOT DB_MoveCrimeRegistered(1)
		THEN
		RequestProcessed(_Player,_RequestID,1);
		
		PROC
		ProcCrimeTryRegisteringMoveForbiddenItem((CHARACTERGUID)_Player,(ITEMGUID)_Item,(INTEGER)_RequestID)
		THEN
		NOT DB_MoveCrimeRegistered(1);
		
		/***************************************/
		//--- REQUESTS
		/***************************************/
		IF
		CanUseItem(_Char,_Item,_RequestID)
		THEN
		ProcBlockUseOfItem(_Char,_Item);
		ProcProcessUseOfItemWithStatus(_Char,_Item);
		ProcProcessUseOfItem(_Char,_Item,_RequestID);
		
		IF
		CanMoveItem(_Char,_Item,_RequestID)
		THEN
		ProcBlockMoveOfItem(_Char,_Item);
		ProcProcessMoveOfItem(_Char,_Item,_RequestID);
		
		IF
		CanPickupItem(_Char,_Item,_RequestID)
		THEN
		ProcBlockPickupOfItem(_Char,_Item);
		ProcProcessPickupOfItem(_Char,_Item,_RequestID);
		
		IF
		CanLockpickItem(_Char,_Item,_RequestID)
		THEN
		ProcBlockLockpickItem(_Char,_Item);
		ProcProcessLockpickItem(_Char,_Item,_RequestID);
		
		IF
		CanCombineItem(_Char,_ItemA,_ItemB,_ItemC,_ItemD,_ItemE,_RequestID)
		THEN
		ProcBlockCombineItem(_Char,_ItemA);
		ProcBlockCombineItem(_Char,_ItemB);
		ProcBlockCombineItem(_Char,_ItemC);
		ProcBlockCombineItem(_Char,_ItemD);
		ProcBlockCombineItem(_Char,_ItemE);
		ProcProcessCombineItem(_Char,_ItemA,_ItemB,_ItemC,_ItemD,_ItemE,_RequestID);
		
		
		/***************************************/
		//--- BLOCK ACTIONS
		/***************************************/
		/*	Catch one of the following PROCs to set the appropriate DB:
			DB_CustomUseItemResponse((CHARACTERGUID)_Char,(ITEMGUID)_Item,(INTEGER)_Result)
			DB_CustomMoveItemResponse((CHARACTERGUID)_Char,(ITEMGUID)_Item,(INTEGER)_Result)
			DB_CustomPickupItemResponse((CHARACTERGUID)_Char,(ITEMGUID)_Item,(INTEGER)_Result)
			DB_CustomLockpickItemResponse((CHARACTERGUID)_Char,(ITEMGUID)_Item,(INTEGER)_Result)
			DB_CustomCombineItemResponse((CHARACTERGUID)_Char,(ITEMGUID)_Item,(INTEGER)_Result)
		*/
		
		PROC
		ProcBlockUseOfItem((CHARACTERGUID)_Char,(ITEMGUID)_Item)
		THEN
		DB_NOOP(1);
		
		PROC
		ProcBlockMoveOfItem((CHARACTERGUID)_Char,(ITEMGUID)_Item)
		THEN
		DB_NOOP(1);
		
		PROC
		ProcBlockPickupOfItem((CHARACTERGUID)_Char,(ITEMGUID)_Item)
		THEN
		DB_NOOP(1);
		
		PROC
		ProcBlockLockpickItem((CHARACTERGUID)_Char,(ITEMGUID)_Item)
		THEN
		DB_NOOP(1);
		
		PROC
		ProcBlockCombineItem((CHARACTERGUID)_Char,(ITEMGUID)_Item)
		THEN
		DB_NOOP(1);
		
		
		/***************************************/
		//--- BURNING AND ELECTRIFIED items apply status
		/***************************************/
		PROC
		ProcProcessUseOfItemWithStatus((CHARACTERGUID)_Char,(ITEMGUID)_Item)
		AND
		DB_IsPlayer(_Char) // apply only on player not to break story events with NPCs using items
		AND
		NOT DB_CustomUseItemResponse(_Char,_Item,0) // if handled in story, don't apply effect
		AND
		DB_ItemStatusAffectCharacterOnUse(_Status)
		AND
		HasActiveStatus(_Item,_Status,1)
		AND
		NOT QRYItemStatusIsNotAppliedToUser(_Item,_Status)
		THEN
		ApplyStatus(_Char,_Status,12.0);
		
		QRY
		QRYItemStatusIsNotAppliedToUser((ITEMGUID)_Item,(STRING)_Status)
		AND
		_Status == "BURNING"
		AND
		ItemIsTorch(_Item,1)
		THEN
		DB_NOOP(1);
		
		/***************************************/
		//--- PROCESS
		/***************************************/
		// Use
		PROC
		ProcProcessUseOfItem((CHARACTERGUID)_Char,(ITEMGUID)_Item,(INTEGER)_RequestID)
		AND
		DB_CustomUseItemResponse(_Char,_Item,(INTEGER)_Result)
		THEN
		RequestProcessed(_Char,_RequestID,_Result);
		
		PROC
		ProcProcessUseOfItem((CHARACTERGUID)_Char,(ITEMGUID)_Item,(INTEGER)_RequestID)
		AND
		NOT DB_CustomUseItemResponse(_Char,_Item,_)
		AND
		ItemCanSitOn(_Item,0)
		AND
		ItemIsLadder(_Item,0)
		AND
		ItemIsPublicDomain(_Item,0)
		THEN
		DB_HandledRequest(_Char,_Item,_RequestID);
		ProcCrimeTryRegisteringUseForbiddenItem(_Char,_Item,_RequestID);
		
		PROC
		ProcProcessUseOfItem((CHARACTERGUID)_Char,(ITEMGUID)_Item,(INTEGER)_RequestID)
		AND
		NOT DB_CustomUseItemResponse(_Char,_Item,_)
		AND
		NOT DB_HandledRequest(_Char,_Item,_RequestID)
		THEN
		RequestProcessed(_Char,_RequestID,1);
		
		PROC
		ProcProcessUseOfItem((CHARACTERGUID)_Char,(ITEMGUID)_Item,(INTEGER)_RequestID)
		AND
		DB_HandledRequest(_Char,_Item,_RequestID)
		THEN
		NOT DB_HandledRequest(_Char,_Item,_RequestID);
		
		// Move (registers MoveForbiddenItem instead of UseForbiddenItem)
		PROC
		ProcProcessMoveOfItem((CHARACTERGUID)_Char,(ITEMGUID)_Item,(INTEGER)_RequestID)
		AND
		DB_CustomMoveItemResponse(_Char,_Item,(INTEGER)_Result)
		THEN
		RequestProcessed(_Char,_RequestID,_Result);
		
		PROC
		ProcProcessMoveOfItem((CHARACTERGUID)_Char,(ITEMGUID)_Item,(INTEGER)_RequestID)
		AND
		NOT DB_CustomMoveItemResponse(_Char,_Item,_)
		THEN
		ProcCrimeTryRegisteringMoveForbiddenItem(_Char,_Item,_RequestID);
		
		// Pickup
		PROC
		ProcProcessPickupOfItem((CHARACTERGUID)_Char,(ITEMGUID)_Item,(INTEGER)_RequestID)
		AND
		DB_CustomPickupItemResponse(_Char,_Item,(INTEGER)_Result)
		THEN
		RequestProcessed(_Char,_RequestID,_Result);
		
		PROC
		ProcProcessPickupOfItem((CHARACTERGUID)_Char,(ITEMGUID)_Item,(INTEGER)_RequestID)
		AND
		NOT DB_CustomPickupItemResponse(_Char,_Item,_)
		THEN
		ProcCrimeTryRegisteringStealItem(_Char,_Item,_RequestID);
		
		// Lockpick
		PROC
		ProcProcessLockpickItem((CHARACTERGUID)_Char,(ITEMGUID)_Item,(INTEGER)_RequestID)
		AND
		DB_CustomLockpickItemResponse(_Char,_Item,(INTEGER)_Result)
		THEN
		RequestProcessed(_Char,_RequestID,_Result);
		
		PROC
		ProcProcessLockpickItem((CHARACTERGUID)_Char,(ITEMGUID)_Item,(INTEGER)_RequestID)
		AND
		NOT DB_CustomLockpickItemResponse(_Char,_Item,_)
		THEN
		ProcCrimeTryRegisteringUseForbiddenItem(_Char,_Item,_RequestID);
		
		// Combine
		PROC
		ProcProcessCombineItem(_Player,_ItemA,_ItemB,_ItemC,_ItemD,_ItemE,_RequestID)
		AND
		NOT QryCombineItemHasCustomResult(_Player,_ItemA,_ItemB,_ItemC,_ItemD,_ItemE)
		AND
		CharacterIsPlayer(_Player,1)
		THEN
		ProcCrimeCheckRegisterUseForbiddenItem(_Player,_ItemA,_RequestID);
		ProcCrimeCheckRegisterUseForbiddenItem(_Player,_ItemB,_RequestID);
		ProcCrimeCheckRegisterUseForbiddenItem(_Player,_ItemC,_RequestID);
		ProcCrimeCheckRegisterUseForbiddenItem(_Player,_ItemD,_RequestID);
		ProcCrimeCheckRegisterUseForbiddenItem(_Player,_ItemE,_RequestID);
		
		PROC
		ProcProcessCombineItem((CHARACTERGUID)_Char,(ITEMGUID)_ItemA,(ITEMGUID)_ItemB,(ITEMGUID)_ItemC,(ITEMGUID)_ItemD,(ITEMGUID)_ItemE,(INTEGER)_RequestID)
		AND
		QryCombineItemHasCustomResult(_Char,_ItemA,_ItemB,_ItemC,_ItemD,_ItemE)
		THEN
		ProcProcessCustomCombineResponse(_Char,_ItemA,_ItemB,_ItemC,_ItemD,_ItemE,_RequestID);
		
		PROC
		ProcProcessCustomCombineResponse((CHARACTERGUID)_Char,(ITEMGUID)_ItemA,(ITEMGUID)_ItemB,(ITEMGUID)_ItemC,(ITEMGUID)_ItemD,(ITEMGUID)_ItemE,(INTEGER)_RequestID)
		AND
		QryCombineItemIsBlocked(_Char,_ItemA,_ItemB,_ItemC,_ItemD,_ItemE)
		THEN
		RequestProcessed(_Char,_RequestID,0);
		
		PROC
		ProcProcessCustomCombineResponse((CHARACTERGUID)_Char,(ITEMGUID)_ItemA,(ITEMGUID)_ItemB,(ITEMGUID)_ItemC,(ITEMGUID)_ItemD,(ITEMGUID)_ItemE,(INTEGER)_RequestID)
		AND
		NOT QryCombineItemIsBlocked(_Char,_ItemA,_ItemB,_ItemC,_ItemD,_ItemE)
		THEN
		RequestProcessed(_Char,_RequestID,1);
		
		
		//--- General proc:
		PROC
		ProcCrimeTryRegisteringUseForbiddenItem((CHARACTERGUID)_Char,(ITEMGUID)_Item,(INTEGER)_RequestID)
		AND
		CharacterIsPlayer(_Char,1)
		THEN
		ProcCrimeCheckRegisterUseForbiddenItem(_Char,_Item,_RequestID);
		
		PROC
		ProcCrimeTryRegisteringUseForbiddenItem((CHARACTERGUID)_Char,(ITEMGUID)_Item,(INTEGER)_RequestID)
		AND
		CharacterIsPlayer(_Char,0)
		THEN
		RequestProcessed(_Char,_RequestID,1);
		
		PROC
		ProcCrimeTryRegisteringStealItem((CHARACTERGUID)_Char,(ITEMGUID)_Item,(INTEGER)_RequestID)
		AND
		CharacterIsPlayer(_Char,0)
		THEN
		DB_StealRequestHandled(1);
		RequestProcessed(_Char,_RequestID,1);
		
		PROC
		ProcCrimeTryRegisteringStealItem((CHARACTERGUID)_Char,(ITEMGUID)_Item,(INTEGER)_RequestID)
		AND
		NOT DB_StealRequestHandled(1)
		AND
		NOT QryCrimeItemHasNPCOwner(_Item)
		THEN
		DB_StealRequestHandled(1);
		RequestProcessed(_Char,_RequestID,1);
		
		//we only register a crime here if they're going ot react, sicne we then block the pickup
		//in the case they won't the reaction to the steal event will register the crime
		PROC
		ProcCrimeTryRegisteringStealItem((CHARACTERGUID)_Char,(ITEMGUID)_Item,(INTEGER)_RequestID)
		AND
		NOT DB_StealRequestHandled(1)
		AND
		ItemGetOwner(_Item,_Victim)
		AND
		CharacterIsPlayer(_Victim,0)
		AND
		GetPosition(_Item,_X,_Y,_Z)
		AND
		CrimeIsAnyNPCGoingToReact(_Char,"Steal",_Victim,_X,_Y,_Z,1)
		THEN
		DB_StealRequestHandled(1);
		RequestProcessed(_Char,_RequestID,0);
		CharacterRegisterCrimeWithPosition(_Char,"Steal",_Item,_Victim,_X,_Y,_Z,0);
		
		PROC
		ProcCrimeTryRegisteringStealItem((CHARACTERGUID)_Char,(ITEMGUID)_Item,(INTEGER)_RequestID)
		AND
		NOT DB_StealRequestHandled(1)
		THEN
		RequestProcessed(_Char,_RequestID,1);
		
		PROC
		ProcCrimeTryRegisteringStealItem(_,_,_)
		THEN
		NOT DB_StealRequestHandled(1);
		
		/***************************************/
		//--- CLEAR custom response facts
		/***************************************/
		PROC
		ProcProcessUseOfItem((CHARACTERGUID)_Char,(ITEMGUID)_Item,(INTEGER)_RequestID)
		AND
		DB_CustomUseItemResponse(_Char,_Item,_Result)
		THEN
		NOT DB_CustomUseItemResponse(_Char,_Item,_Result);
		
		PROC
		ProcProcessMoveOfItem((CHARACTERGUID)_Char,(ITEMGUID)_Item,(INTEGER)_RequestID)
		AND
		DB_CustomMoveItemResponse(_Char,_Item,_Result)
		THEN
		NOT DB_CustomMoveItemResponse(_Char,_Item,_Result);
		
		PROC
		ProcProcessPickupOfItem((CHARACTERGUID)_Char,(ITEMGUID)_Item,(INTEGER)_RequestID)
		AND
		DB_CustomPickupItemResponse(_Char,_Item,_Result)
		THEN
		NOT DB_CustomPickupItemResponse(_Char,_Item,_Result);
		
		PROC
		ProcProcessLockpickItem((CHARACTERGUID)_Char,(ITEMGUID)_Item,(INTEGER)_RequestID)
		AND
		DB_CustomLockpickItemResponse(_Char,_Item,_Result)
		THEN
		NOT DB_CustomLockpickItemResponse(_Char,_Item,_Result);
		
		PROC
		ProcProcessCombineItem((CHARACTERGUID)_Char,(ITEMGUID)_Item,(INTEGER)_RequestID)
		AND
		DB_CustomCombineItemResponse(_Char,_Item,_Result)
		THEN
		NOT DB_CustomCombineItemResponse(_Char,_Item,_Result);
		
		
		/***************************************/
		//--- REGISTERING CRIMES and responding to the requests
		/***************************************/
		PROC
		ProcCrimeCheckRegisterUseForbiddenItem((CHARACTERGUID)_Player,(ITEMGUID)_Item,(INTEGER)_RequestID)
		AND
		NOT QryCrimeItemHasNPCOwner(_Item)
		AND
		NOT DB_DontCreateUseForbiddenItem(_Item)
		THEN
		RequestProcessed(_Player,_RequestID,1);
		
		PROC
		ProcCrimeCheckRegisterUseForbiddenItem((CHARACTERGUID)_Player,(ITEMGUID)_Item,(INTEGER)_RequestID)
		AND
		DB_DontCreateUseForbiddenItem(_Item)
		THEN
		RequestProcessed(_Player,_RequestID,1);
		
		PROC
		ProcCrimeCheckRegisterUseForbiddenItem((CHARACTERGUID)_Player,(ITEMGUID)_Item,(INTEGER)_RequestID)
		AND
		NOT DB_DontCreateUseForbiddenItem(_Item)
		AND
		QryCrimeItemHasNPCOwner(_Item)
		AND
		HasActiveStatus(_Player,"SNEAKING",1)
		THEN
		DB_Crime_UseForbiddenItem(_Player,"SneakUseForbiddenItem",_Item);
		RequestProcessed(_Player,_RequestID,1);
		CharacterRegisterCrime(_Player,"SneakUseForbiddenItem",_Item,NULL_00000000-0000-0000-0000-000000000000,0);
		
		PROC
		ProcCrimeCheckRegisterUseForbiddenItem((CHARACTERGUID)_Player,(ITEMGUID)_Item,(INTEGER)_RequestID)
		AND
		NOT DB_DontCreateUseForbiddenItem(_Item)
		AND
		QryCrimeItemHasNPCOwner(_Item)
		AND
		HasActiveStatus(_Player,"SNEAKING",0)
		AND
		GetPosition(_Item,_X,_Y,_Z)
		AND
		ItemGetOwner(_Item,_Owner)
		AND
		CrimeIsAnyNPCGoingToReact(_Player,"UseForbiddenItem",_Owner,_X,_Y,_Z,_NPCWillReact)
		THEN
		ProcCrimeRegisterUseForbiddenItem(_Player,_Item,_RequestID,_NPCWillReact);
		
		PROC
		ProcCrimeRegisterUseForbiddenItem((CHARACTERGUID)_Player,(ITEMGUID)_Item,(INTEGER)_RequestID,(INTEGER)_NPCWillReact)
		AND
		DB_Negate(_NPCWillReact,_Result)
		THEN
		DB_Crime_UseForbiddenItem(_Player,"UseForbiddenItem",_Item);
		RequestProcessed(_Player,_RequestID,_Result);
		CharacterRegisterCrime(_Player,"UseForbiddenItem",_Item,NULL_00000000-0000-0000-0000-000000000000,0);
		
		/***************************************/
		//--- CHECK CRIME REACTIONS
		/***************************************/
		/*
		IF
		CharacterOnCrimeSensibleActionNotification(_,_,_CrimeID,_,_,_,_Criminal1,_Criminal2,_Criminal3,_Criminal4)
		AND
		CrimeGetType(_CrimeID,"UseForbiddenItem")
		THEN
		ProcCrimeForbiddenItemGetEvidence(_CrimeID,_Criminal1,"UseForbiddenItem");
		
		IF
		CharacterOnCrimeSensibleActionNotification(_,_,_CrimeID,_,_,_,_Criminal1,_Criminal2,_Criminal3,_Criminal4)
		AND
		CrimeGetType(_CrimeID,"SneakUseForbiddenItem")
		THEN
		ProcCrimeForbiddenItemGetEvidence(_CrimeID,_Criminal1,"SneakUseForbiddenItem");
		*/
		
		IF
		OnCrimeConfrontationDone(_CrimeID,_Investigator,1,_Criminal1,_Criminal2,_Criminal3,_Criminal4)
		AND
		CrimeGetType(_CrimeID,"UseForbiddenItem")
		THEN
		ProcCrimeForbiddenItemGetEvidence(_CrimeID,_Criminal1,"UseForbiddenItem");
		
		IF
		OnCrimeConfrontationDone(_CrimeID,_Investigator,1,_Criminal1,_Criminal2,_Criminal3,_Criminal4)
		AND
		CrimeGetType(_CrimeID,"SneakUseForbiddenItem")
		THEN
		ProcCrimeForbiddenItemGetEvidence(_CrimeID,_Criminal1,"SneakUseForbiddenItem");
		
		PROC
		ProcCrimeForbiddenItemGetEvidence((INTEGER)_CrimeID,(CHARACTERGUID)_Criminal,(STRING)_CrimeType)
		AND
		NOT QRY_CharacterIsNull(_Criminal)
		AND
		CrimeGetNumberOfEvidence(_CrimeID,_NumEvidence)
		AND
		_NumEvidence > 0
		AND
		CrimeGetEvidence(_CrimeID,1,(ITEMGUID)_Item)
		THEN
		ProcCrimeStopForbiddenItem(_Criminal,_CrimeType,_Item);
		
		PROC
		ProcCrimeForbiddenItemGetEvidence((INTEGER)_CrimeID,(CHARACTERGUID)_Criminal,(STRING)_CrimeType)
		AND
		NOT QRY_CharacterIsNull(_Criminal)
		AND
		CrimeGetNumberOfEvidence(_CrimeID,_NumEvidence)
		AND
		_NumEvidence < 1
		THEN
		ProcCrimeStopForbiddenItem(_Criminal,_CrimeType,NULL_00000000-0000-0000-0000-000000000000);
		
		PROC
		ProcCrimeStopForbiddenItem((CHARACTERGUID)_Criminal,(STRING)_CrimeType,(ITEMGUID)_Evidence)
		THEN
		CharacterStopCrime(_Criminal,_CrimeType,_Evidence);
		
		PROC
		ProcCrimeStopForbiddenItem((CHARACTERGUID)_Criminal,(STRING)_CrimeType,(ITEMGUID)_Evidence)
		AND
		DB_Crime_UseForbiddenItem(_Player,_CrimeType,_Evidence)
		THEN
		NOT DB_Crime_UseForbiddenItem(_Player,_CrimeType,_Evidence);
		
		
		/***************************************/
		//--- STOPPING CRIMES
		/***************************************/
		IF
		CharacterStoppedUsingItem(_Player,_Item)
		AND
		DB_Crime_UseForbiddenItem(_Player,_CrimeType,_Item)
		THEN
		NOT DB_Crime_UseForbiddenItem(_Player,_CrimeType,_Item);
		CharacterStopCrime(_Player,_CrimeType,_Item);
		
		/*
		IF
		CharacterMovedItem(_Player,_Item)
		CharacterStoppedMovingItem(_Player,_Item)
		AND
		DB_Crime_UseForbiddenItem(_Player,_CrimeType,_Item)
		THEN
		NOT DB_Crime_UseForbiddenItem(_Player,_CrimeType,_Item);
		CharacterStopCrime(_Player,_CrimeType,_Item);
		
		IF
		CharacterStoppedPickingUpItem(_Player,_Item)
		AND
		DB_Crime_UseForbiddenItem(_Player,_CrimeType,_Item)
		THEN
		NOT DB_Crime_UseForbiddenItem(_Player,_CrimeType,_Item);
		CharacterStopCrime(_Player,_CrimeType,_Item);
		*/
		
		IF
		CharacterStoppedLockpickingItem(_Player,_Item)
		AND
		DB_Crime_UseForbiddenItem(_Player,_CrimeType,_Item)
		THEN
		NOT DB_Crime_UseForbiddenItem(_Player,_CrimeType,_Item);
		CharacterStopCrime(_Player,_CrimeType,_Item);
		
		IF
		CharacterStoppedCombiningItems(_Player,_ItemA,_ItemB,_ItemC,_ItemD,_ItemE)
		THEN
		ProcCrimeStopCombineItemCrime(_Player,_ItemA);
		ProcCrimeStopCombineItemCrime(_Player,_ItemB);
		ProcCrimeStopCombineItemCrime(_Player,_ItemC);
		ProcCrimeStopCombineItemCrime(_Player,_ItemD);
		ProcCrimeStopCombineItemCrime(_Player,_ItemE);
		
		PROC
		ProcCrimeStopCombineItemCrime((CHARACTERGUID)_Player,(ITEMGUID)_Item)
		AND
		DB_Crime_UseForbiddenItem(_Player,_CrimeType,_Item)
		THEN
		CharacterStopCrime(_Player,_CrimeType,_Item);
		
		QRY
		QryCrimeClearCombineItemBD((CHARACTERGUID)_Player,(STRING)_CrimeType)
		AND
		DB_Crime_UseForbiddenItem(_Player,_CrimeType,_Item)
		THEN
		NOT DB_Crime_UseForbiddenItem(_Player,_CrimeType,_Item);
		
		
		/***************************************/
		//--- QUERIES
		/***************************************/
		
		QRY
		QryCrimeIsValidItemRequest((CHARACTERGUID)_Char,(ITEMGUID)_Item)
		AND
		CharacterIsPlayer(_Char,0)
		THEN
		DB_NOOP(1);
		
		QRY
		QryCrimeIsValidItemRequest((CHARACTERGUID)_Char,(ITEMGUID)_Item)
		AND
		CharacterIsPlayer(_Char,1)
		AND
		NOT QryCrimeItemHasNPCOwner((ITEMGUID)_Item)
		THEN
		DB_NOOP(1);
		
		QRY
		QryCrimeCombinedItemsAreValid((ITEMGUID)_ItemA,(ITEMGUID)_ItemB,(ITEMGUID)_ItemC,(ITEMGUID)_ItemD,(ITEMGUID)_ItemE)
		AND
		NOT QryCrimeItemHasNPCOwner(_ItemA)
		AND
		NOT QryCrimeItemHasNPCOwner(_ItemB)
		AND
		NOT QryCrimeItemHasNPCOwner(_ItemC)
		AND
		NOT QryCrimeItemHasNPCOwner(_ItemD)
		AND
		NOT QryCrimeItemHasNPCOwner(_ItemE)
		THEN
		DB_NOOP(1);
		
		QRY
		QryCrimeItemHasNPCOwner((ITEMGUID)_Item)
		AND
		ItemGetOwner(_Item,_Char)
		AND
		NOT QRY_CharacterIsNull(_Char)
		AND
		CharacterIsPlayer(_Char,0)
		THEN
		DB_NOOP(1);
		
		/**** Combine item custom result ****/
		QRY
		QryCombineItemHasCustomResult((CHARACTERGUID)_Player,(ITEMGUID)_ItemA,(ITEMGUID)_ItemB,(ITEMGUID)_ItemC,(ITEMGUID)_ItemD,(ITEMGUID)_ItemE)
		AND
		DB_CustomCombineItemResponse(_Player,_ItemA,_)
		THEN
		DB_NOOP(1);
		
		QRY
		QryCombineItemHasCustomResult((CHARACTERGUID)_Player,(ITEMGUID)_ItemA,(ITEMGUID)_ItemB,(ITEMGUID)_ItemC,(ITEMGUID)_ItemD,(ITEMGUID)_ItemE)
		AND
		DB_CustomCombineItemResponse(_Player,_ItemB,_)
		THEN
		DB_NOOP(1);
		
		QRY
		QryCombineItemHasCustomResult((CHARACTERGUID)_Player,(ITEMGUID)_ItemA,(ITEMGUID)_ItemB,(ITEMGUID)_ItemC,(ITEMGUID)_ItemD,(ITEMGUID)_ItemE)
		AND
		DB_CustomCombineItemResponse(_Player,_ItemC,_)
		THEN
		DB_NOOP(1);
		
		QRY
		QryCombineItemHasCustomResult((CHARACTERGUID)_Player,(ITEMGUID)_ItemA,(ITEMGUID)_ItemB,(ITEMGUID)_ItemC,(ITEMGUID)_ItemD,(ITEMGUID)_ItemE)
		AND
		DB_CustomCombineItemResponse(_Player,_ItemD,_)
		THEN
		DB_NOOP(1);
		
		QRY
		QryCombineItemHasCustomResult((CHARACTERGUID)_Player,(ITEMGUID)_ItemA,(ITEMGUID)_ItemB,(ITEMGUID)_ItemC,(ITEMGUID)_ItemD,(ITEMGUID)_ItemE)
		AND
		DB_CustomCombineItemResponse(_Player,_ItemE,_)
		THEN
		DB_NOOP(1);
		
		
		/**** Combine item is blocked ****/
		QRY
		QryCombineItemIsBlocked((CHARACTERGUID)_Player,(ITEMGUID)_ItemA,(ITEMGUID)_ItemB,(ITEMGUID)_ItemC,(ITEMGUID)_ItemD,(ITEMGUID)_ItemE)
		AND
		DB_CustomCombineItemResponse(_Player,_ItemA,1)
		THEN
		DB_NOOP(1);
		
		QRY
		QryCombineItemIsBlocked((CHARACTERGUID)_Player,(ITEMGUID)_ItemA,(ITEMGUID)_ItemB,(ITEMGUID)_ItemC,(ITEMGUID)_ItemD,(ITEMGUID)_ItemE)
		AND
		DB_CustomCombineItemResponse(_Player,_ItemB,1)
		THEN
		DB_NOOP(1);
		
		QRY
		QryCombineItemIsBlocked((CHARACTERGUID)_Player,(ITEMGUID)_ItemA,(ITEMGUID)_ItemB,(ITEMGUID)_ItemC,(ITEMGUID)_ItemD,(ITEMGUID)_ItemE)
		AND
		DB_CustomCombineItemResponse(_Player,_ItemC,1)
		THEN
		DB_NOOP(1);
		
		QRY
		QryCombineItemIsBlocked((CHARACTERGUID)_Player,(ITEMGUID)_ItemA,(ITEMGUID)_ItemB,(ITEMGUID)_ItemC,(ITEMGUID)_ItemD,(ITEMGUID)_ItemE)
		AND
		DB_CustomCombineItemResponse(_Player,_ItemD,1)
		THEN
		DB_NOOP(1);
		
		QRY
		QryCombineItemIsBlocked((CHARACTERGUID)_Player,(ITEMGUID)_ItemA,(ITEMGUID)_ItemB,(ITEMGUID)_ItemC,(ITEMGUID)_ItemD,(ITEMGUID)_ItemE)
		AND
		DB_CustomCombineItemResponse(_Player,_ItemE,1)
		THEN
		DB_NOOP(1);
		
		//END_REGION
		
		//----------------------------------- CUSTOM -----------------------------------
		//REGION Override Sensible Action
		
		// ------ Setting
		PROC
		ProcCrimeSetAllCustomSensibleAction((CHARACTERGUID)_Character,(STRING)_CrimeName,(STRING)_CustomReactionName)
		THEN
		ProcCrimeSetCustomPrimarySensibleAction(_Character,_CrimeName,_CustomReactionName);
		ProcCrimeSetCustomSecondarySensibleAction(_Character,_CrimeName,_CustomReactionName);
		
		
		// Primary
		PROC
		ProcCrimeSetCustomPrimarySensibleAction((CHARACTERGUID)_Character,(STRING)_CrimeName,(STRING)_CustomReactionName)
		AND
		DB_CrimeReaction_CustomSensibleAction(_Character,_CrimeName,1)
		AND
		StringConcatenate("Setting a custom primary sensible action [",_CustomReactionName,_Part1)
		AND
		StringConcatenate(_Part1,"] on a character that already have one for crime: ",_Part2)
		AND
		StringConcatenate(_Part2,_CrimeName,_Message)
		THEN
		DebugBreak(_Message);
		
		PROC
		ProcCrimeSetCustomPrimarySensibleAction((CHARACTERGUID)_Character,(STRING)_CrimeName,(STRING)_)
		THEN
		DB_CrimeReaction_CustomSensibleAction(_Character,_CrimeName,1);
		
		PROC
		ProcCrimeSetCustomPrimarySensibleAction((CHARACTERGUID)_Character,(STRING)_CrimeName,(STRING)_CustomReactionName)
		AND
		_CustomReactionName == ""
		THEN
		ProcCrimeSetCustomSensibleActionVariable(_Character,_CrimeName,"CRIME_UndefinedSensibleAction","Primary_");
		
		PROC
		ProcCrimeSetCustomPrimarySensibleAction((CHARACTERGUID)_Character,(STRING)_CrimeName,(STRING)_CustomReactionName)
		AND
		_CustomReactionName != ""
		THEN
		ProcCrimeSetCustomSensibleActionVariable(_Character,_CrimeName,_CustomReactionName,"Primary_");
		
		
		// Secondary
		PROC
		ProcCrimeSetCustomSecondarySensibleAction((CHARACTERGUID)_Character,(STRING)_CrimeName,(STRING)_CustomReactionName)
		AND
		DB_CrimeReaction_CustomSensibleAction(_Character,_CrimeName,0)
		AND
		StringConcatenate("Setting a custom secondary sensible action [",_CustomReactionName,_Part1)
		AND
		StringConcatenate(_Part1,"] on a character that already have one for crime: ",_Part2)
		AND
		StringConcatenate(_Part2,_CrimeName,_Message)
		THEN
		DebugBreak(_Message);
		
		PROC
		ProcCrimeSetCustomSecondarySensibleAction((CHARACTERGUID)_Character,(STRING)_CrimeName,(STRING)_)
		THEN
		DB_CrimeReaction_CustomSensibleAction(_Character,_CrimeName,0);
		
		PROC
		ProcCrimeSetCustomSecondarySensibleAction((CHARACTERGUID)_Character,(STRING)_CrimeName,(STRING)_CustomReactionName)
		AND
		_CustomReactionName == ""
		THEN
		ProcCrimeSetCustomSensibleActionVariable(_Character,_CrimeName,"CRIME_UndefinedSensibleAction","Secondary_");
		
		PROC
		ProcCrimeSetCustomSecondarySensibleAction((CHARACTERGUID)_Character,(STRING)_CrimeName,(STRING)_CustomReactionName)
		AND
		_CustomReactionName != ""
		THEN
		ProcCrimeSetCustomSensibleActionVariable(_Character,_CrimeName,_CustomReactionName,"Secondary_");
		
		PROC
		ProcCrimeSetCustomSensibleActionVariable((CHARACTERGUID)_Character,(STRING)_CrimeName,(STRING)_CustomReactionName,(STRING)_Type)
		AND
		StringConcatenate("Custom",_Type,_Prefix)
		AND
		StringConcatenate(_Prefix,_CrimeName,_VarName)
		THEN
		SetVarFixedString(_Character,_VarName,_CustomReactionName);
		
		
		// --- Clearing
		PROC
		ProcCrimeClearCustomPrimarySensibleAction((CHARACTERGUID)_Character,(STRING)_CrimeName)
		AND
		StringConcatenate("CustomPrimary_",_CrimeName,_VarName)
		THEN
		SetVarFixedString(_Character,_VarName,"");
		
		PROC
		ProcCrimeClearCustomPrimarySensibleAction((CHARACTERGUID)_Character,(STRING)_CrimeName)
		AND
		DB_CrimeReaction_CustomSensibleAction(_Character,_CrimeName,1)
		THEN
		NOT DB_CrimeReaction_CustomSensibleAction(_Character,_CrimeName,1);
		
		PROC
		ProcCrimeClearCustomSecondarySensibleAction((CHARACTERGUID)_Character,(STRING)_CrimeName)
		AND
		StringConcatenate("CustomSecondary_",_CrimeName,_VarName)
		THEN
		SetVarFixedString(_Character,_VarName,"");
		
		PROC
		ProcCrimeClearCustomSecondarySensibleAction((CHARACTERGUID)_Character,(STRING)_CrimeName)
		AND
		DB_CrimeReaction_CustomSensibleAction(_Character,_CrimeName,0)
		THEN
		NOT DB_CrimeReaction_CustomSensibleAction(_Character,_CrimeName,0);
		
		PROC
		ProcCrimeClearAllCustomSensibleAction((CHARACTERGUID)_Character,(STRING)_CrimeName)
		AND
		StringConcatenate("CustomPrimary_",_CrimeName,_PrimaryVarName)
		AND
		StringConcatenate("CustomSecondary_",_CrimeName,_SecondaryVarName)
		THEN
		SetVarFixedString(_Character,_PrimaryVarName,"");
		SetVarFixedString(_Character,_SecondaryVarName,"");
		
		PROC
		ProcCrimeClearAllCustomSensibleAction((CHARACTERGUID)_Character,(STRING)_CrimeName)
		AND
		DB_CrimeReaction_CustomSensibleAction(_Character,_CrimeName,_Type)
		THEN
		NOT DB_CrimeReaction_CustomSensibleAction(_Character,_CrimeName,_Type);
		
		
		// --- Throwing a proc to allow reacting in story
		IF
		CharacterOnCrimeSensibleActionNotification(_NPC,_Region,_CrimeID,_PriorityName,_Dialog,_Criminal,_Criminal2,_Criminal3,_Criminal4,_IsPrimary)
		AND
		CrimeGetType(_CrimeID,_CrimeName)
		AND
		DB_CrimeReaction_CustomSensibleAction(_NPC,_CrimeName,_IsPrimary)
		THEN
		ProcCrimeOnCustomSensibleAction(_NPC,_Region,_CrimeID,_PriorityName,_Dialog,_Criminal,_Criminal2,_Criminal3,_Criminal4,_IsPrimary);
		
		PROC
		ProcCrimeOnCustomSensibleAction((CHARACTERGUID)_NPC, (STRING)_RegionID, (INTEGER)_CrimeID, (STRING)_PriorityName, (STRING)_PrimaryDialog, (CHARACTERGUID)_Criminal1, (CHARACTERGUID)_Criminal2, (CHARACTERGUID)_Criminal3, (CHARACTERGUID)_Criminal4, (INTEGER)_IsPrimary)
		THEN
		DB_NOOP(1);
		
		/**
		 * IMPORTANT! Call this event on the NPC who's reacting to the crime:
		
		SetStoryEvent(_NPC,"Crime_CustomSensibleActionDone");
		
		 */
		//END_REGION
		
		//REGION Override investigation
		
		/* Put your character in this fact to disable the interractive interrogation dialog:
			DB_CrimeReaction_DoNotInterrogate(_Interrogator)
		*/
		
		IF
		DB_CrimeReaction_DoNotInterrogate((CHARACTERGUID)_Char)
		THEN
		DB_Crime_CheckInterrogate(_Char);
		CrimeEnableInterrogation(_Char,0);
		
		IF
		DB_Crime_CheckInterrogate(_Char)
		AND
		NOT DB_CrimeReaction_DoNotInterrogate(_Char)
		THEN
		NOT DB_Crime_CheckInterrogate(_Char);
		CrimeEnableInterrogation(_Char,1);
		
		PROC
		ProcCrimeSetCustomInvestigationAD((CHARACTERGUID)_Character,(STRING)_Dialog)
		THEN
		SetVarString(_Character,"CRIME_InvestigateAD",_Dialog);
		
		
		//END_REGION
		
		//REGION Linked crimes
		PROC
		ProcCharacterDisableCrime((CHARACTERGUID)_Char,_Crime)
		AND
		DB_LinkedCrimes(_Crime,_LinkedCrime)
		THEN
		DB_CharacterCrimeDisabled(_Char,_LinkedCrime);
		CharacterDisableCrime(_Char,_LinkedCrime);
		
		PROC
		ProcCharacterEnableCrime((CHARACTERGUID)_Char,_Crime)
		AND
		DB_LinkedCrimes(_Crime,_LinkedCrime)
		THEN
		DB_CharacterCrimeEnabled(_Char,_LinkedCrime);
		CharacterEnableCrime(_Char,_LinkedCrime);
		
		IF
		DB_CrimeAttitudeChange("Assault",_Amount)
		THEN
		DB_CrimeAttitudeChange("IncapacitatedAssault",_Amount);
		
		//END_REGION
		
		
		//REGION Zero-tension crimes without fleeing
		// Zero-tension crimes that don't cause people to flee explicitly should not cause people to
		// return to their starting position at the end (DOSTWO-24283)
		IF
		CharacterOnCrimeSensibleActionNotification(_Char,_,_ID,_Reaction,_,_,_,_,_,_)
		AND
		DB_CRIME_FleeReaction(_Reaction)
		AND
		CrimeGetTension(_ID,0)
		THEN
		DB_CRIME_ZeroTensionFlee(_ID,_Char);
		
		IF
		OnCrimeConfrontationDone(_ID,_Investigator,_,_,_,_,_)
		AND
		CrimeGetTension(_ID,0)
		AND
		NOT DB_CRIME_ZeroTensionFlee(_ID,_Investigator)
		THEN
		SetStoryEvent(_Investigator,"ClearCrimeReturnPos");
		
		IF
		OnCrimeConfrontationDone(_ID,_Investigator,_,_,_,_,_)
		THEN
		NOT DB_CRIME_ZeroTensionFlee(_ID,_Investigator);
		//END_REGION
		
	}
	EXIT
	{
			
		
	}
}
Goal(18).Title("_CRIME_ItemOwnership");
Goal(18)
{
	INIT
	{
		DB_ItemOwnerShipIgnoreTemplates("LTS_Campfire_A_6fee7bbb-4adc-4222-a5b1-82fcfb8d1230");
		DB_ItemOwnerShipIgnoreTemplates("LTS_Campfire_B_130692f2-a065-4168-be66-27cf4df2fff0");
		DB_ItemOwnerShipIgnoreTemplates("LTS_Campfire_C_1086cce2-9164-4746-b3c3-2f8c943cb8fc");
		DB_ItemOwnerShipIgnoreTemplates("FUR_Humans_Camping_Sleepingbag_A_d76d0118-23cd-42af-b693-449c96c71d6d");
		DB_ItemOwnerShipIgnoreTemplates("FUR_Humans_Citz_Mattress_A_DarkBrown_eae64571-4e99-4036-b3e2-1dcc6da78c89");
		DB_ItemOwnerShipIgnoreTemplates("LTS_Candle_A_f21393ff-31bc-46ff-a024-985e72cd83f5");
		DB_ItemOwnerShipIgnoreTemplates("LTS_Candle_B_d5e83188-69f5-428f-8bca-64f00b441aef");
		DB_ItemOwnerShipIgnoreTemplates("LTS_Candle_C_b98b4f53-5cf3-46b1-8ecd-278f178a9816");
		DB_ItemOwnerShipIgnoreTemplates("LTS_Candle_D_511c5c17-2ed0-4b2e-a4b5-425621cb61ac");
		DB_ItemOwnerShipIgnoreTemplates("LTS_Candle_E_f497d3af-8837-4183-9bf4-aef2ef1145d1");
		DB_ItemOwnerShipIgnoreTemplates("LTS_Candle_F_0121d78b-8831-4607-9c2f-db63edcdfbb6");
		DB_ItemOwnerShipIgnoreTemplates("LTS_Candle_G_83e373a2-ca7b-4c35-8761-d04605aaabca");
		DB_ItemOwnerShipIgnoreTemplates("LTS_Candle_H_49acf8f4-946e-4f62-a12e-e85d332f3d96");
		DB_ItemOwnerShipIgnoreTemplates("LTS_Candle_I_728b84a6-3929-48eb-9368-631a0614e38d");
		DB_ItemOwnerShipIgnoreTemplates("LTS_Candle_J_b8b63ed1-7c28-4c68-90b2-e83db433467b");
		DB_ItemOwnerShipIgnoreTemplates("LTS_Candle_K_ef4d1dd9-8d2a-4677-98c3-bb9dd52c0865");
		DB_ItemOwnerShipIgnoreTemplates("BLD_Humans_Dungeon_Stairs_A_5H_4L_B_Dynamic_0b674c38-44c6-4d69-84fe-b88c1df30fa4");
		
	}
	KB
	{
		PROC
		PROC_Init_SetItemOwners((STRING)_Region)
		AND
		DB_ItemOwnerShipTriggers(_Region,_Trigger,_Owner)
		THEN
		TriggerSetItemOwner(_Trigger,_Owner);
		ProcTriggerRegisterForPlayers(_Trigger);
		NOT DB_ItemOwnerShipTriggers(_Region,_Trigger,_Owner);
		DB_TempItemOwnerShipTrigger(_Region,_Trigger);
		DB_OwnershipTrigger(_Trigger);
		
		PROC
		PROC_Init_ClearItemOwners((STRING)_Region)
		AND
		DB_ItemOwnerShipClearItem(_Region,_Item)
		THEN
		ItemClearOwner(_Item);
		NOT DB_ItemOwnerShipClearItem(_Region,_Item);
		
		PROC
		PROC_Init_ClearItemOwners((STRING)_Region)
		AND
		DB_TempItemOwnerShipTrigger((STRING)_Region,(TRIGGERGUID)_Trigger)
		AND
		DB_ItemOwnerShipIgnoreTemplates(_Temp)
		THEN
		NOT DB_TempItemOwnerShipTrigger(_Region,_Trigger);
		TriggerClearItemTemplateOwners(_Trigger,_Temp);
		
		IF
		DB_ItemOwnerShipTriggers(_Region,_Trigger,_Owner)
		AND
		DB_CurrentLevel(_Region)
		THEN
		PROC_Init_SetItemOwners(_Region);
		PROC_Init_ClearItemOwners(_Region);
		
		IF
		RegionStarted(_Region)
		THEN
		PROC_Init_SetItemOwners(_Region);
		PROC_Init_ClearItemOwners(_Region);
		
	}
	EXIT
	{
		
	}
}
Goal(19).Title("_CRIME_Prison");
Goal(19)
{
	INIT
	{
		//Setting up Flags for the Arrest Dialogs
		DB_ArrestDialogFlags("Assault","GEB_Arrest_Assault");
		DB_ArrestDialogFlags("SpiritTalk","GEB_Arrest_Source");
		DB_ArrestDialogFlags("SourceMagic","GEB_Arrest_Source");
		DB_ArrestDialogFlags("Steal","GEB_Arrest_Theft");
		DB_ArrestDialogFlags("PickPocketFailed","GEB_Arrest_Theft");
		DB_ArrestDialogFlags("PickPocket","GEB_Arrest_Theft");
		DB_ArrestDialogFlags("ItemDestroy","GEB_Arrest_Vandalise");
		DB_ArrestDialogFlags("Vandalise","GEB_Arrest_Vandalise");
		DB_ArrestDialogFlags("VandaliseNoOwner","GEB_Arrest_Vandalise");
		DB_ArrestDialogFlags("Trespassing","GEB_Arrest_Trespassing");
		DB_ArrestDialogFlags("UseForbiddenItem","GEB_Arrest_UseForbiddenItem");
		DB_ArrestDialogFlags("SneakUseForbiddenItem","GEB_Arrest_UseForbiddenItem");
		
		DB_ReactOutOfRegion("RED PRINCE");
		DB_ReactOutOfRegion("IFAN");
		DB_ReactOutOfRegion("LOHSE");
		DB_ReactOutOfRegion("SEBILLE");
		DB_ReactOutOfRegion("BEAST");
		DB_ReactOutOfRegion("FANE");
		DB_ReactOutOfRegion("AGGRESSIVEANIMAL");
		
	}
	KB
	{
		IF
		DB_RegionPrison(_RegionName,(TRIGGERGUID)_PrisonTrigger)
		THEN
		ProcTriggerRegisterForPlayers(_PrisonTrigger);
		
		QRY
		QryNPCIsGuard((GUIDSTRING)_NPC)
		AND
		IsTagged(_Npc,"GUARD",1)
		THEN
		DB_Noop(1);
		
		QRY
		QryNPCIsGuard((GUIDSTRING)_NPC)
		AND
		IsTagged(_Npc,"PALADIN",1)
		THEN
		DB_Noop(1);
		
		QRY
		QryNPCIsGuard((GUIDSTRING)_NPC)
		AND
		IsTagged(_Npc,"MAGISTER",1)
		THEN
		DB_Noop(1);
		
		//REGION Start Arrest 
		//Wait for dialog to end to arrest Player // Needs to be removed
		IF
		ObjectFlagSet("Start_Arrest_AfterDialog",(CHARACTERGUID)_Character,_ID)
		THEN
		ObjectClearFlag(_Character,"Start_Arrest_AfterDialog",0);
		DB_ArrestAfterDialog(_Character,_ID);
		
		
		///////// Handle Evidence ////////////
		IF
		ObjectFlagSet("Allow_Arrest",(CHARACTERGUID)_Player,_ID)
		THEN
		DB_ArrestDialog(_Player,_ID);
		
		IF
		DialogEnded(_,_ID)
		AND
		DB_ArrestDialog(_Player,_ID)
		AND
		DB_DialogNPCs(_ID,_NPC,1)
		AND
		ObjectGetFlag((CHARACTERGUID)_NPC,"CRIME_FoundEvidenceCurrentCrime",1)
		AND
		DB_Interrogation(_NPC,_CrimeID)
		THEN
		ProcCrimeHandleEvidence(_Player,_NPC,_CrimeID);
		
		PROC
		ProcCrimeHandleEvidence((CHARACTERGUID)_Player,(CHARACTERGUID)_Arrester,(INTEGER)_CrimeID)
		AND
		CharacterGetCrimeRegion(_Player,_CrimeRegionID)
		AND
		DB_RegionPrison(_CrimeRegionID,_PrisonTrigger)
		AND
		DB_PrisonEvidenceChest((TRIGGERGUID)_PrisonTrigger,(ITEMGUID)_EvidenceChest)
		THEN
		CrimeTransferEvidenceTo(_CrimeID,_EvidenceChest);
		
		PROC
		ProcCrimeHandleEvidence((CHARACTERGUID)_Player,(CHARACTERGUID)_Arrester,(INTEGER)_CrimeID)
		AND
		CharacterGetCrimeRegion(_Player,_CrimeRegionID)
		AND
		DB_RegionPrison(_CrimeRegionID,_PrisonTrigger)
		AND
		NOT DB_PrisonEvidenceChest((TRIGGERGUID)_PrisonTrigger,_)
		THEN
		CrimeTransferEvidenceTo(_CrimeID,_Arrester);
		
		
		///////// Start Arrest ////////////
		IF
		DialogEnded(_,_ID)
		AND
		DB_ArrestAfterDialog(_Character,_ID)
		THEN
		NOT DB_ArrestAfterDialog(_Character,_ID);
		ProcCrimeStartArrest((CHARACTERGUID)_Character,_ID);
		
		PROC
		ProcCrimeStartArrest((CHARACTERGUID)_Character,(INTEGER)_ID)
		AND
		CharacterGetCrimeRegion(_Character,_CrimeRegion)
		THEN
		ProcCrimeDoPerformArrest(_ID,_CrimeRegion);
		
		PROC
		ProcCrimeDoPerformArrest((INTEGER)_Inst,(STRING)_Region)
		AND
		DB_DialogNPCs(_Inst,_Player,_)
		AND
		CharacterIsPlayer((CHARACTERGUID)_Player,1)
		THEN
		ProcCrimePerformArrest(_Player,_Region);
		
		PROC
		ProcCrimeDoPerformArrest((INTEGER)_Inst,(STRING)_Region)
		AND
		DB_DialogPlayers(_Inst,_Player,_)
		AND
		CharacterIsPlayer((CHARACTERGUID)_Player,1)
		THEN
		ProcCrimePerformArrest(_Player,_Region);
		
		PROC
		ProcCrimePerformArrest((CHARACTERGUID)_Character,(STRING)_CrimeRegionID)
		AND
		DB_RegionPrison(_CrimeRegionID,_PrisonTrigger)
		THEN
		ProcCrimeTeleportCharacterToPrison(_Character,_PrisonTrigger);
		
		PROC //--- can be used outside of the Crime System
		ProcCrimeTeleportCharacterToPrison((CHARACTERGUID)_Character,(TRIGGERGUID)_PrisonTrigger)
		THEN
		ObjectSetFlag(_Character,"IsInPrison");
		RemoveStatus(_Character,"FUGITIVE");
		CharacterDetachFromGroup(_Character);
		Proc_TeleportSmoke(_Character);
		TeleportTo(_Character,_PrisonTrigger,"",0);
		Proc_TeleportSmoke(_Character);
		DB_IsArrested(_Character);
		CharacterFlushQueue(_Character);
		LeaveCombat(_Character);
		CharacterRemoveTension(_Character);
		
		PROC
		ProcCrimeTeleportCharacterToPrison((CHARACTERGUID)_Character,(TRIGGERGUID)_PrisonTrigger)
		AND
		DB_PrisonChest((TRIGGERGUID)_PrisonTrigger,(ITEMGUID)_PrisonChest)
		THEN
		MoveAllItemsTo(_Character,_PrisonChest,0,1,1);
		
		//END_REGION
		
		//REGION Arrest dialog starting 
		
		IF
		CharacterOnCrimeSensibleActionNotification(_Arrester,_,_CrimeID,"CRIME_Arrest",_,_,_,_,_,_)
		AND
		CrimeGetType(_CrimeID,_CrimeName)
		AND
		NOT DB_CrimeReaction_CustomSensibleAction(_Arrester,_CrimeName)
		THEN
		Proc_StartArrestDialog(_Arrester);
		
		IF
		StoryEvent(_Arrester,"ArrestOnRequest")
		AND
		GetVarInteger(_Arrester,"CrimeID",_CrimeID)
		THEN
		SetVarString(_Arrester,"ArrestDialog","GEB_Arrest");
		ProcStartArrest((CHARACTERGUID)_Arrester,(INTEGER)_CrimeID);
		
		IF
		StoryEvent((CHARACTERGUID)_Arrester,"ArrestOnRequest")
		AND
		DB_Arresting(_Arrester,_CrimeID,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,_ArrestDialog)
		THEN
		CharacterMoveToAndTalk(_Arrester,_Criminal1,"",0,"GEB_ArrestMove",1,10.0);
		
		IF
		StoryEvent((CHARACTERGUID)_Arrester, "CRIME_Perform_Arrest")
		AND
		GetVarInteger(_Arrester,"CrimeID",_CrimeID)
		THEN
		ProcStartArrest(_Arrester,_CrimeID);
		
		PROC
		ProcStartArrest((CHARACTERGUID)_Arrester,(INTEGER)_CrimeID)
		AND
		GetVarObject(_Arrester,"Criminal1",_Criminal1)
		AND
		GetVarObject(_Arrester,"Criminal2",_Criminal2)
		AND
		GetVarObject(_Arrester,"Criminal3",_Criminal3)
		AND
		GetVarObject(_Arrester,"Criminal4",_Criminal4)
		AND
		GetVarString(_Arrester,"ArrestDialog",_ArrestDialog)
		THEN
		DB_Arresting(_Arrester,_CrimeID,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,_ArrestDialog);
		SetHasDialog(_Arrester,0);
		CharacterDisableAllCrimes(_Arrester);
		DialogRequestStop(_Arrester);
		FireOsirisEvents();
		
		IF
		DialogEnded(_,_Instance)
		AND
		DB_DialogPlayers(_Instance,_Criminal,1)
		AND
		DB_Arresting(_Arrester,_CrimeID,(CHARACTERGUID)_Criminal,_,_,_,_ArrestDialog)
		THEN
		CharacterMoveToAndTalk(_Arrester,_Criminal,"",0,"GEB_ArrestMove",1,10.0);
		
		PROC
		ProcStartArrest((CHARACTERGUID)_Arrester,(INTEGER)_CrimeID)
		AND
		NOT DB_Arresting(_Arrester,_CrimeID,_,_,_,_,_)
		THEN
		CrimeConfrontationDone(_CrimeID,_Arrester);
		
		PROC
		ProcCleanupArrest((CHARACTERGUID)_Arrester)
		AND
		DB_Arresting(_Arrester,_CrimeID,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_ArrestDialog)
		THEN
		ProcRestoreFightMode(_Arrester);
		ProcRestoreGenericBehaviour(_Arrester);
		SetHasDialog(_Arrester,1);
		NOT DB_Arresting(_Arrester,_CrimeID,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_ArrestDialog);
		SetStoryEvent(_Arrester,"CRIME_StartArrest");
		
		IF
		CharacterMoveToAndTalkRequestDialog(_Arrester,(CHARACTERGUID)_Criminal,_,_,"GEB_ArrestMove")
		AND
		DB_Arresting(_Arrester,_CrimeID,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_ArrestDialog)
		THEN
		SetStoryEvent(_Arrester,"CRIME_StartArrest");
		Proc_StartArrestDialog(_Arrester,_CrimeID,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_ArrestDialog);
		
		IF
		CharacterMoveToAndTalkFailed(_Arrester,_,"GEB_ArrestMove")
		AND
		DB_Arresting(_Arrester,_CrimeID,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_ArrestDialog)
		THEN
		CrimeConfrontationDone(_CrimeID,_Arrester);
		ProcCleanupArrest(_Arrester);
		
		IF
		CharacterMoveToAndTalkRequestDialogFailedEvent(_Arrester,_,"GEB_ArrestMove")
		AND
		DB_Arresting(_Arrester,_CrimeID,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_ArrestDialog)
		THEN
		CrimeConfrontationDone(_CrimeID,_Arrester);
		ProcCleanupArrest(_Arrester);
		
		IF
		DB_Crime_FailedToInterruptStoryDialogs(_CrimeID,_ArrestDialog,_Arrester,_Criminal,_Criminal2,_Criminal3,_Criminal4)
		AND
		DB_Arresting(_Arrester,_CrimeID,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_ArrestDialog)
		THEN
		CharacterMoveToAndTalkRequestDialogFailed(_Arrester,_Criminal,"GEB_ArrestMove");
		
		IF
		ObjectFlagSet(_ActiveFlag,(CHARACTERGUID)_Arrester,_)
		AND
		DB_ArrestDialogFlags(_CrimeName,_ActiveFlag)
		AND
		DB_Arresting(_Arrester,_CrimeID,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_ArrestDialog)
		THEN
		ProcCleanupArrest(_Arrester);
		
		IF
		ObjectEnteredCombat((CHARACTERGUID)_Arrester,_)
		AND
		DB_Arresting(_Arrester,_,_,_,_,_,_)
		THEN
		ProcCleanupArrest(_Arrester);
		
		PROC 
		Proc_StartArrestDialog((CHARACTERGUID)_Arrester)
		AND
		GetVarObject(_Arrester,"Criminal1",(CHARACTERGUID)_Criminal1)
		AND
		GetVarObject(_Arrester,"Criminal2",(CHARACTERGUID)_Criminal2)
		AND
		GetVarObject(_Arrester,"Criminal3",(CHARACTERGUID)_Criminal3)
		AND
		GetVarObject(_Arrester,"Criminal4",(CHARACTERGUID)_Criminal4)
		AND
		GetVarInteger(_Arrester,"CrimeID",_CrimeID)
		AND
		GetVarString(_Arrester,"ArrestDialog",_ArrestDialog)
		THEN
		Proc_StartArrestDialog(_Arrester,_CrimeID,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_ArrestDialog);
		
		PROC 
		Proc_StartArrestDialog((CHARACTERGUID)_Arrester,(INTEGER)_CrimeID,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_ArrestDialog)
		THEN
		ObjectClearFlag(_Arrester,"GEB_Arrest_HavePrison",0);
		
		PROC
		Proc_StartArrestDialog((CHARACTERGUID)_Arrester,(INTEGER)_CrimeID,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_ArrestDialog)
		AND
		DB_ArrestDialogFlags(_CrimeName,_ActiveFlag)
		AND
		ObjectGetFlag(_Arrester,_ActiveFlag,1)
		THEN
		ObjectClearFlag(_Arrester,_ActiveFlag,0);
		
		PROC 
		Proc_StartArrestDialog((CHARACTERGUID)_Arrester,(INTEGER)_CrimeID,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_ArrestDialog)
		AND
		CrimeGetType(_CrimeID,_CrimeName)
		AND
		DB_ArrestDialogFlags(_CrimeName,_ActiveFlag)
		THEN
		ObjectSetFlag(_Arrester,_ActiveFlag);
		
		
		//--- Setup the Arrester's script
		PROC 
		Proc_StartArrestDialog((CHARACTERGUID)_Arrester,(INTEGER)_CrimeID,(CHARACTERGUID)_Criminal1,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,(STRING)_ArrestDialog)
		AND
		GetVarFixedString(_Arrester,"RegionID",_RegionID)
		AND
		CrimeGetType(_CrimeID,_CrimeType)
		THEN
		ProcCrimeSetupCountFlag(_CrimeID,_Arrester,_Criminal1,_Criminal2,_Criminal3,_Criminal4,_CrimeType,_ArrestDialog);
		ProcCrimeStartRegionArrestInterrogation(_RegionID,_CrimeID,_ArrestDialog,_Arrester,_Criminal1,_Criminal2,_Criminal3,_Criminal4);
		
		PROC
		ProcCheckStartArrestInterrogation((INTEGER)_CrimeID,(STRING)_ArrestDialog,(CHARACTERGUID)_Arrester,(CHARACTERGUID)_Criminal,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4)
		AND
		NOT DB_Crime_FailedToInterruptStoryDialogs(_CrimeID,_ArrestDialog,_Arrester,_Criminal,_Criminal2,_Criminal3,_Criminal4)
		THEN
		ProcCrimeStartArrestInterrogation(_CrimeID,_Arrester,_Criminal,_Criminal2,_Criminal3,_Criminal4,1);
		
		PROC
		ProcCheckStartArrestInterrogation((INTEGER)_CrimeID,(STRING)_ArrestDialog,(CHARACTERGUID)_Arrester,(CHARACTERGUID)_Criminal,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4)
		AND
		DB_Crime_FailedToInterruptStoryDialogs(_CrimeID,_ArrestDialog,_Arrester,_Criminal,_Criminal2,_Criminal3,_Criminal4)
		THEN
		ProcCrimeStartArrestInterrogation(_CrimeID,_Arrester,_Criminal,_Criminal2,_Criminal3,_Criminal4,0);
		NOT DB_Crime_FailedToInterruptStoryDialogs(_CrimeID,_ArrestDialog,_Arrester,_Criminal,_Criminal2,_Criminal3,_Criminal4);
		
		PROC
		ProcCrimeStartRegionArrestInterrogation((STRING)_RegionID,(INTEGER)_CrimeID,(STRING)_ArrestDialog,(CHARACTERGUID)_Arrester,(CHARACTERGUID)_Criminal,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4)
		AND
		DB_RegionPrison(_RegionID,_)
		THEN
		ObjectSetFlag(_Arrester,"GEB_Arrest_HavePrison");
		
		PROC
		ProcCrimeStartRegionArrestInterrogation((STRING)_RegionID,(INTEGER)_CrimeID,(STRING)_ArrestDialog,(CHARACTERGUID)_Arrester,(CHARACTERGUID)_Criminal,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4)
		AND
		_RegionID != ""
		THEN
		ProcCrimeInterruptStoryDialogs(_CrimeID,_ArrestDialog,1,_Arrester,_Criminal,_Criminal2,_Criminal3,_Criminal4);
		ProcCheckStartArrestInterrogation(_CrimeID,_ArrestDialog,_Arrester,_Criminal,_Criminal2,_Criminal3,_Criminal4);
		
		PROC
		ProcCrimeStartRegionArrestInterrogation((STRING)_RegionID,(INTEGER)_CrimeID,(STRING)_ArrestDialog,(CHARACTERGUID)_Arrester,(CHARACTERGUID)_Criminal,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4)
		AND
		_RegionID == ""
		AND
		DB_ReactOutOfRegion(_Tag)
		AND
		IsTagged(_Arrester,_Tag,1)
		AND
		NOT DB_ReactingCharOutOfRegion(_Arrester,_)
		THEN
		ProcCrimeInterruptStoryDialogs(_CrimeID,_ArrestDialog,1,_Arrester,_Criminal,_Criminal2,_Criminal3,_Criminal4);
		ProcCheckStartArrestInterrogation(_CrimeID,_ArrestDialog,_Arrester,_Criminal,_Criminal2,_Criminal3,_Criminal4);
		DB_ReactingCharOutOfRegion(_Arrester,_Tag);
		
		
		// We change crime dialog in the next section, so replace it in the DB which is used to clean some stuff on crime end
		PROC
		ProcCrimeStartRegionArrestInterrogation((STRING)_RegionID,(INTEGER)_CrimeID,(STRING)_ArrestDialog,(CHARACTERGUID)_Arrester,(CHARACTERGUID)_Criminal,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4)
		AND
		_RegionID == ""
		AND
		NOT DB_ReactingCharOutOfRegion(_Arrester,_)
		THEN
		ProcCrimeStartRegionArrestInterrogation_SubActions(_RegionID,_CrimeID,_ArrestDialog,_Arrester,_Criminal,_Criminal2,_Criminal3,_Criminal4);
		
		PROC
		ProcCrimeStartRegionArrestInterrogation_SubActions((STRING)_RegionID,(INTEGER)_CrimeID,(STRING)_ArrestDialog,(CHARACTERGUID)_Arrester,(CHARACTERGUID)_Criminal,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4)
		AND
		DB_Crime_RequestedDialogWithTension(_CrimeName,_ArrestDialog,_Arrester,_Criminal,_Criminal2,_Criminal3,_Criminal4)
		THEN
		NOT DB_Crime_RequestedDialogWithTension(_CrimeName,_ArrestDialog,_Arrester,_Criminal,_Criminal2,_Criminal3,_Criminal4);
		DB_Crime_RequestedDialogWithTension(_CrimeName,"GEB_Attack",_Arrester,_Criminal,_Criminal2,_Criminal3,_Criminal4);
		
		PROC
		ProcCrimeStartRegionArrestInterrogation_SubActions((STRING)_RegionID,(INTEGER)_CrimeID,(STRING)_ArrestDialog,(CHARACTERGUID)_Arrester,(CHARACTERGUID)_Criminal,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4)
		THEN
		ProcCrimeInterruptStoryDialogs(_CrimeID,"GEB_Attack",1,_Arrester,_Criminal,_Criminal2,_Criminal3,_Criminal4);
		ProcCheckStartArrestInterrogation(_CrimeID,"GEB_Attack",_Arrester,_Criminal,_Criminal2,_Criminal3,_Criminal4);
		
		PROC
		ProcCrimeStartRegionArrestInterrogation((STRING)_RegionID,(INTEGER)_CrimeID,(STRING)_ArrestDialog,(CHARACTERGUID)_Arrester,(CHARACTERGUID)_Criminal,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4)
		AND
		DB_ReactingCharOutOfRegion(_Arrester,_Tag)
		THEN
		NOT DB_ReactingCharOutOfRegion(_Arrester,_Tag);
		
		PROC 
		ProcCrimeStartArrestInterrogation((INTEGER)_CrimeID,(CHARACTERGUID)_Arrester,(CHARACTERGUID)_Criminal,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,_)
		AND
		DB_EvidenceFound(_CrimeID,_Interrogator)
		AND
		DB_Crime_CallingGuards(_Interrogator,_Criminal,_ID)
		THEN
		NOT DB_Crime_CallingGuards(_Interrogator,_Criminal,_ID);
		NOT DB_EvidenceFound(_CrimeID,_Interrogator);
		DB_EvidenceFound(_CrimeID,_Arrester);
		
		PROC 
		ProcCrimeStartArrestInterrogation((INTEGER)_CrimeID,(CHARACTERGUID)_Arrester,(CHARACTERGUID)_Criminal,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,1)
		AND
		DB_EvidenceFound(_CrimeID,_Interrogator)
		AND
		DB_Crime_CallingGuards(_Interrogator,_Criminal,_ID)
		THEN
		DB_StopInterrogationAfterDialog(_CrimeID,_Arrester,_Criminal,_Criminal2,_Criminal3,_Criminal4);
		
		PROC 
		ProcCrimeStartArrestInterrogation((INTEGER)_CrimeID,(CHARACTERGUID)_Arrester,(CHARACTERGUID)_Criminal,(CHARACTERGUID)_Criminal2,(CHARACTERGUID)_Criminal3,(CHARACTERGUID)_Criminal4,0)
		AND
		DB_Crime_Interrogation(_CrimeID,_,_,_,_,_,_)
		THEN
		ProcStopInterrogation(_CrimeID,_Arrester,_Criminal,_Criminal2,_Criminal3,_Criminal4);
		
		IF
		DialogEnded(_,_Instance)
		AND
		DB_DialogPlayers(_Instance,_Player,1)
		AND
		DB_DialogNPCs(_Instance,_NPC,1)
		AND
		ObjectGetFlag(_Player,"Resist_Arrest",1)
		AND
		DB_DialogPlayers(_Instance,_Players,_)
		THEN
		ObjectClearFlag(_Player,"Resist_Arrest",0);
		proc_CriminalMakeHostileAfterDialog((CHARACTERGUID)_Players,(CHARACTERGUID)_NPC);
		
		PROC
		proc_CriminalMakeHostileAfterDialog((CHARACTERGUID)_Player,(CHARACTERGUID)_NPC)
		AND
		_Player != NULL_00000000-0000-0000-0000-000000000000
		THEN
		ProcMakeNPCHostile((CHARACTERGUID)_Player,(CHARACTERGUID)_NPC);
		
		IF
		DialogEnded(_,_Instance)
		AND
		DB_ArrestDialog(_Player,_Instance)
		THEN
		ObjectClearFlag(_Player,"Allow_Arrest",0);
		NOT DB_ArrestDialog(_Player,_Instance);
		ProcCrimeStartArrest((CHARACTERGUID)_Player,_Instance);
		
		IF
		DialogEnded(_,_Instance)
		AND
		DB_DialogNPCs(_Instance,_NPC,1)
		AND
		DB_StopInterrogationAfterDialog(_CrimeID,(CHARACTERGUID)_NPC,_Criminal,_Criminal2,_Criminal3,_Criminal4)
		THEN
		ProcStopInterrogation(_CrimeID,_NPC,_Criminal,_Criminal2,_Criminal3,_Criminal4);
		NOT DB_StopInterrogationAfterDialog(_CrimeID,_NPC,_Criminal,_Criminal2,_Criminal3,_Criminal4);
		
		// TODO Remove the DB_ReactingCharOutOfRegion(_Arrester,_Tag) On Tag Removed
		//END_REGION
		
		//REGION Arrest Play As AD 
		IF
		StoryEvent((CHARACTERGUID)_Arrester,"GLO_PlayArrestAsAD")
		AND
		GetVarString(_Arrester,"ArrestDialog",_ArrestDialog)
		THEN
		Proc_StartDialog(1,_ArrestDialog,_Arrester);
		//END_REGION
		
		//REGION Escape Prison
		IF
		CharacterEnteredTrigger(_Player,_PrisonTrigger)
		AND
		DB_IsArrested(_Player)
		AND
		DB_IsPlayer(_Player)
		AND
		DB_PlayerPrison_Door(_PrisonTrigger,(ITEMGUID)_CellDoor,(STRING)_KeyName)
		THEN
		ItemCloseAndLock(_CellDoor,_KeyName);
		
		IF
		CharacterLeftTrigger(_Player,_PrisonTrigger)
		AND
		DB_IsArrested(_Player)
		AND
		DB_IsPlayer(_Player)
		AND
		DB_PlayerPrison((TRIGGERGUID)_PrisonTrigger,(TRIGGERGUID)_CellDoorTrigger,(STRING)_PrisonCrimeName,(STRING)_PrisonCrimeNameAD)
		AND
		GetPosition(_CellDoorTrigger,_x,_y,_z)
		THEN
		//ProcRestoreGenericBehaviourAfterScene(_Player);
		PROC_CRIME_Prison_Escaped(_Player, _PrisonCrimeName, _PrisonCrimeNameAD);
		
		PROC
		PROC_CRIME_Prison_Escaped((CHARACTERGUID)_Player, (STRING)_PrisonCrimeName, (STRING)_PrisonCrimeNameAD)
		AND
		QRY_AnyRegionActive()
		THEN
		DB_PlayerEscapedPrison(_Player,_PrisonCrimeName,_PrisonCrimeNameAD);
		ApplyStatus(_Player,"FUGITIVE",100.0,1);
		
		PROC
		PROC_CRIME_Prison_Escaped((CHARACTERGUID)_Player, (STRING)_PrisonCrimeName, (STRING)_PrisonCrimeNameAD)
		THEN
		ObjectClearFlag(_Player,"IsInPrison",0);
		NOT DB_IsArrested(_Player);
		
		IF
		CharacterStatusApplied(_Player,"FUGITIVE",_)
		AND
		DB_IsPlayer(_Player)
		AND
		DB_PlayerEscapedPrison(_Player,_PrisonCrimeName,_PrisonCrimeNameAD)
		THEN
		ObjectSetFlag(_Player,"IsFugitive"); // This is for Arrest_EscapedPrison Dialog
		CharacterRegisterCrime(_Player,_PrisonCrimeName,NULL_00000000-0000-0000-0000-000000000000,NULL_00000000-0000-0000-0000-000000000000,0);
		
		IF
		CharacterStatusApplied(_Player,"FUGITIVE",_)
		AND
		DB_IsPlayer(_Player)
		AND
		DB_PlayerEscapedPrison(_Player,_PrisonCrimeName,_PrisonCrimeNameAD)
		AND
		_PrisonCrimeNameAD != ""
		THEN
		CharacterRegisterCrime(_Player,_PrisonCrimeNameAD,NULL_00000000-0000-0000-0000-000000000000,NULL_00000000-0000-0000-0000-000000000000,0);
		
		IF
		CharacterStatusRemoved(_Player,"FUGITIVE",_)
		AND
		DB_IsPlayer(_Player)
		AND
		DB_PlayerEscapedPrison(_Player,_PrisonCrimeName,_PrisonCrimeNameAD)
		THEN
		NOT DB_PlayerEscapedPrison(_Player,_PrisonCrimeName,_PrisonCrimeNameAD);
		CharacterStopCrime(_Player,_PrisonCrimeName,NULL_00000000-0000-0000-0000-000000000000);
		CharacterStopCrime(_Player,_PrisonCrimeNameAD,NULL_00000000-0000-0000-0000-000000000000);
		ObjectClearFlag(_Player,"IsFugitive",0);
		
		IF
		ObjectFlagSet("GEB_ClearTag_FUGITIVE",_Player,_) //set in GEB_Arrest_EscapedPrison
		AND
		HasActiveStatus(_Player,"FUGITIVE",1)
		THEN
		RemoveStatus(_Player,"FUGITIVE");
		
		IF
		ObjectFlagSet("GEB_ClearTag_FUGITIVE",_Player,_ID) //set in GEB_Arrest_EscapedPrison
		AND
		DB_DialogNPCs(_ID,_NPC,1)
		THEN
		ProcCrimeBribedGuards(_NPC,_Player);
		
		PROC
		ProcCrimeBribedGuards((GUIDSTRING)_NPC,(GUIDSTRING)_Player)
		THEN
		CrimeIgnoreAllCrimesForCriminal(_Player,_NPC,300000);
		DB_CrimeBribeSource(_Player);
		CharacterLaunchIteratorAroundObject((CHARACTERGUID)_Player,20.0,"GEB_CrimeBribeGuards");
		FireOsirisEvents();
		NOT DB_CrimeBribeSource(_Player);
		
		IF
		StoryEvent((CHARACTERGUID)_NPC,"GEB_CrimeBribeGuards")
		AND
		NOT DB_CombatCharacters(_NPC,_)
		AND
		DB_CrimeBribeSource(_Player)
		AND
		NOT DB_Dead(_NPC)
		AND
		CharacterIsPlayer(_NPC,0)
		AND
		QryNPCIsGuard(_NPC)
		THEN
		CrimeIgnoreAllCrimesForCriminal(_Player,_NPC,300000);
		
		IF
		ObjectFlagSet("GEB_ClearTag_FUGITIVE",_Player,_) //set in GEB_Arrest_EscapedPrison
		THEN
		ObjectClearFlag(_Player,"GEB_ClearTag_FUGITIVE",0);
		
		//END_REGION
		
		//REGION GUARD CALLING
		IF
		ObjectFlagSet("GEB_Arrest_Player",_NPC,_Inst)
		AND
		DB_DialogNPCs(_Inst,_OldLead,1)
		THEN
		DB_CrimeArrestCallingGuards((CHARACTERGUID)_OldLead,_Inst);
		
		IF
		ObjectFlagSet("GEB_Arrest_Player",_NPC,_Inst)
		AND
		DB_DialogNPCs(_Inst,_OldLead,1)
		AND
		NOT DB_CombatCharacters((CHARACTERGUID)_NPC,_)
		AND
		NOT DB_PickedLeadToHelp(_,_Inst)
		AND
		GetVarInteger(_OldLead,"CrimeID",_CrimeID)
		AND
		CrimeTransferLeadershipTo((CHARACTERGUID)_OldLead,_CrimeID,_NPC,1)
		AND
		GetVarObject(_OldLead,"Criminal1",_Criminal1)
		AND
		GetVarObject(_OldLead,"Criminal2",_Criminal2)
		AND
		GetVarObject(_OldLead,"Criminal3",_Criminal3)
		AND
		GetVarObject(_OldLead,"Criminal4",_Criminal4)
		AND
		GetVarFixedString(_OldLead,"RegionID",_RegionID)
		THEN
		SetHasDialog(_OldLead,0);
		CharacterDisableAllCrimes(_OldLead);
		CharacterEnableCrime(_OldLead,"Assault");
		CharacterEnableCrime(_OldLead,"SummonAssault");
		CharacterEnableCrime(_OldLead,"IncapacitatedAssault");
		DB_GuardCaller(_CrimeID,_OldLead,_NPC);
		CharacterSetReactionPriority(_OldLead,"CRIME_Flee",2800);
		DB_PickedLeadToHelp(_NPC,_Inst);
		ProcStoreFightMode(_Npc);
		CharacterSetFightMode(_NPC,1,0);
		SetVarObject(_NPC,"Criminal1",_Criminal1); 
		SetVarObject(_NPC,"Criminal2",_Criminal2); 
		SetVarObject(_NPC,"Criminal3",_Criminal3); 
		SetVarObject(_NPC,"Criminal4",_Criminal4); 
		SetVarString(_NPC,"ArrestDialog","GEB_Arrest");
		SetVarFixedString(_NPC,"RegionID",_RegionID);
		SetVarInteger(_NPC,"CrimeID",_CrimeID);
		SetStoryEvent(_NPC,"CRIME_Perform_Arrest");
		
		IF
		DialogEnded(_Dialog,_Inst)
		AND
		DB_CrimeArrestCallingGuards(_OldLead,_Inst)
		AND
		NOT DB_PickedLeadToHelp(_,_Inst)
		AND
		DB_DialogPlayers(_Inst,_Player,1)
		THEN
		NOT DB_CrimeArrestCallingGuards(_OldLead,_Inst);
		//failed to transfer leadership, start combat as fallback
		Proc_StartDialog(1,"GEB_AD_DealWithCrime",_OldLead);
		CharacterSetTemporaryHostileRelation((CHARACTERGUID)_Player,_OldLead);
		
		IF
		DialogEnded(_Dialog,_Inst)
		AND
		DB_PickedLeadToHelp(_NPC,_Inst)
		AND
		DB_DialogNPCs(_Inst,_OldLead,1)
		THEN
		NOT DB_PickedLeadToHelp(_NPC,_Inst);
		NOT DB_CrimeArrestCallingGuards((CHARACTERGUID)_OldLead,_Inst);
		
		IF
		OnCrimeConfrontationDone(_CrimeID,_OldLead,_,_,_,_,_)
		AND
		DB_GuardCaller(_CrimeID,_OldLead,_NPC)
		THEN
		SetHasDialog(_OldLead,1);
		ProcRestoreGenericBehaviour(_OldLead);
		NOT DB_GuardCaller(_CrimeID,_OldLead,_NPC);
		
		
		
		//END_REGION
		
		
		//REGION Debug
		
		IF
		TextEventSet("LookatPrison")
		THEN
		CharacterLookAt(S_FTJ_PrisonGuardTest_0ad9aa6c-c8df-4591-be1a-d4f0a94d89ac,S_FortJoy_PlayerPrisonDoor_2dd80040-28aa-4445-8438-1e2424d7228f);
		
		IF
		TextEventSet("Lookatme")
		THEN
		CharacterLookAt(S_FTJ_PrisonGuardTest_0ad9aa6c-c8df-4591-be1a-d4f0a94d89ac,CHARACTERGUID_Player_Ifan_ad9a3327-4456-42a7-9bf4-7ad60cc9e54f);
		
		//END_REGION
		
	}
	EXIT
	{
		
	}
}
Goal(20).Title("_GLO_Homestead_PlayerChests");
Goal(20)
{
	INIT
	{
		// DB_GLO_LVHub_PlayerChests_Chest(_Chest): one of the user chests (in use or not)
		// DB_GLO_LVHub_PlayerChests_Host(_Chest): Host's primary chest
		// DB_GLO_LVHub_PlayerChests_HostSecondary(_ProfileName,_Chest): chest that is currently not assigned to anyone -> fallback to host (but keep track whom it belonged to, so we can give it back)
		// DB_GLO_LVHub_PlayerChests_Cient(_ProfileName,_Chest): chest that was last assigned to the client _profilename
		
	}
	KB
	{
		//REGION Move an item to your chest
		//Client version
		IF
		ItemSendToHomesteadEvent(_Player,_Item)
		AND
		CharacterGetReservedUserID(_Player,_UserID)
		AND
		GetUserProfileID(_UserID,_ProfileName)
		AND
		DB_GLO_LVHub_PlayerChests_Client(_ProfileName,_Chest)
		THEN
		ItemToInventory(_Item,_Chest,-1,1,0);
		
		//Host version
		IF
		ItemSendToHomesteadEvent(_Player,_Item)
		AND
		CharacterGetReservedUserID(_Player,_UserID)
		AND
		CharacterGetHostCharacter(_Host)
		AND
		CharacterGetReservedUserID(_Host,_UserID)
		AND
		DB_GLO_LVHub_PlayerChests_Host(_Chest)
		THEN
		ItemToInventory(_Item,_Chest,-1,1,0);
		//END_REGION
		
		
		//REGION Init
		
		//REGION Init once
		// Set host chest
		PROC
		PROC_GLO_LVHub_PlayerChests_InitOnce()
		AND
		DB_GLO_LVHub_PlayerChests_Chest(_Chest)
		AND
		NOT DB_GLO_LVHub_PlayerChests_Host(_)
		THEN
		DB_GLO_LVHub_PlayerChests_Host(_Chest);
		
		// All other chests are off-stage
		PROC
		PROC_GLO_LVHub_PlayerChests_InitOnce()
		AND
		DB_GLO_LVHub_PlayerChests_Chest(_Chest)
		AND
		NOT DB_GLO_LVHub_PlayerChests_Host(_Chest)
		THEN
		SetOnStage(_Chest,0);
		
		PROC
		PROC_GLO_LVHub_PlayerChests_InitOnce()
		THEN
		PROC_GLO_LVHub_PlayerChests_Init();
		//END_REGION
		
		//REGION Common init
		// Catch users joining during the initial assignment process,
		// so we don't trip over ourselves
		PROC
		PROC_GLO_LVHub_PlayerChests_Init()
		THEN
		DB_GLO_LVHub_PlayerChests_InitialAssignment(1);
		
		IF
		SavegameLoaded(_,_,_,_)
		THEN
		PROC_GLO_LVHub_PlayerChests_Init();
		
		//REGION Paranoia: clean up DBs that should not exist at this point
		PROC
		PROC_GLO_LVHub_PlayerChests_Init()
		AND
		DB_GlobalCounter("GLO_LVHub_Playerchests_Init_UserCount",_Count)
		THEN
		NOT DB_GlobalCounter("GLO_LVHub_Playerchests_Init_UserCount",_Count);
		//END_REGION
		
		// All previous client chests become secondary host chests -> can be automatically reassigned
		PROC
		PROC_GLO_LVHub_PlayerChests_Init()
		AND
		DB_GLO_LVHub_PlayerChests_Client(_ProfileName,_Chest)
		THEN
		PROC_GLO_LVHub_PlayerChests_HostUserAssignChest(_Chest);
		
		// Assign a chest to every client
		PROC
		PROC_GLO_LVHub_PlayerChests_Init()
		AND
		GetUserCount(_Count)
		THEN
		DB_GlobalCounter("GLO_LVHub_Playerchests_Init_Pass1UserCount",_Count);
		IterateUsers("GLO_LVHub_PlayerChests_Init_Pass1");
		
		IF
		UserEvent(_User,"GLO_LVHub_PlayerChests_Init_Pass1")
		AND
		CharacterGetHostCharacter(_HostChar)
		AND
		NOT CharacterGetReservedUserID(_HostChar,_User)
		THEN
		PROC_GLO_LVHub_PlayerChests_UserFindAndAssignChest(_User);
		ProcDecreaseCounter("GLO_LVHub_Playerchests_Init_Pass1UserCount");
		
		// We skipped the host -> 1 user will not have been processed
		IF
		DB_GlobalCounter("GLO_LVHub_Playerchests_Init_Pass1UserCount",1)
		THEN
		NOT DB_GlobalCounter("GLO_LVHub_Playerchests_Init_Pass1UserCount",1);
		PROC_LVHub_UserChests_InitialAssignmentDone();
		//END_REGION
		
		//REGION Handle users that joined while the initial assignment was ongoing
		// Both connecting and disconnecting results in CharacterReservedUserIDChanged events
		IF
		CharacterReservedUserIDChanged(_Player,_,_UserID)
		AND
		DB_GLO_LVHub_PlayerChests_InitialAssignment(1)
		THEN
		DB_GLO_LVHub_PlayerChests_UserChangeDuringInit(1);
		
		PROC
		PROC_LVHub_UserChests_InitialAssignmentDone()
		THEN
		NOT DB_GLO_LVHub_PlayerChests_InitialAssignment(1);
		
		PROC
		PROC_LVHub_UserChests_InitialAssignmentDone()
		AND
		DB_GLO_LVHub_PlayerChests_UserChangeDuringInit(1)
		THEN
		NOT DB_GLO_LVHub_PlayerChests_UserChangeDuringInit(1);
		// Rerun assignment
		PROC_GLO_LVHub_PlayerChests_Init();
		//END_REGION
		
		//END_REGION
		
		
		//REGION Users connecting and disconnecting during the game
		// Existing user got a different user ID -> recalculate everything, because
		// if the host got a different user ID, then we don't want to give them
		// access to chests based on their user id
		// (also catches connects/disconnects, since then a player gets a new ID)
		IF
		CharacterReservedUserIDChanged(_Player,_,_UserID)
		THEN
		PROC_GLO_LVHub_PlayerChests_Init();
		//END_REGION
		
		//REGION Assigning a chest to a user
		
		//REGION Find a chest for a client
		QRY
		QRY_GLO_LVHub_GetUserChest((STRING)_ProfileName)
		AND
		DB_GLO_LVHub_GetUserChestResult(_Chest)
		THEN
		NOT DB_GLO_LVHub_GetUserChestResult(_Chest);
		
		// 1) Own chest
		QRY
		QRY_GLO_LVHub_GetUserChest((STRING)_ProfileName)
		AND
		DB_GLO_LVHub_PlayerChests_Client(_ProfileName,_Chest)
		THEN
		DB_GLO_LVHub_GetUserChestResult(_Chest);
		
		// 2) Previous own chest now assigned as secondary to host
		QRY
		QRY_GLO_LVHub_GetUserChest((STRING)_ProfileName)
		AND
		DB_GLO_LVHub_PlayerChests_HostSecondary(_ProfileName,(ITEMGUID)_Chest)
		THEN
		DB_GLO_LVHub_GetUserChestResult(_Chest);
		
		// 3) Unassigned chest
		QRY
		QRY_GLO_LVHub_GetUserChest((STRING)_ProfileName)
		AND
		DB_GLO_LVHub_PlayerChests_Chest(_Chest)
		AND
		// short-circuit in case one of the previous queries got a result,
		// but still after the DB_GLO_LVHub_PlayerChests_Chest() so it stops
		// iterating once we find a chest here
		NOT DB_GLO_LVHub_GetUserChestResult(_)
		AND
		NOT DB_GLO_LVHub_PlayerChests_Client(_,_Chest)
		AND
		NOT DB_GLO_LVHub_PlayerChests_Host(_Chest)
		AND
		NOT DB_GLO_LVHub_PlayerChests_HostSecondary(_,_Chest)
		AND
		// duplicate check to abort iterating over all chests once we found one
		NOT DB_GLO_LVHub_GetUserChestResult(_)
		THEN
		DB_GLO_LVHub_GetUserChestResult(_Chest);
		
		// 4) secondary host chest that belonged to someone else
		QRY
		QRY_GLO_LVHub_GetUserChest((STRING)_ProfileName)
		AND
		DB_GLO_LVHub_PlayerChests_HostSecondary(_OtherProfile,_Chest)
		AND
		NOT DB_GLO_LVHub_GetUserChestResult(_)
		THEN
		DB_GLO_LVHub_GetUserChestResult(_Chest);
		//END_REGION
		
		//REGION Host chest assignment
		PROC
		PROC_GLO_LVHub_PlayerChests_UserAssignChest((INTEGER)_User,(ITEMGUID)_Chest)
		AND
		CharacterGetHostCharacter(_HostChar)
		AND
		CharacterGetReservedUserID(_HostChar,_User)
		THEN
		PROC_GLO_LVHub_PlayerChests_HostUserAssignChest((ITEMGUID)_Chest);
		
		PROC
		PROC_GLO_LVHub_PlayerChests_HostUserAssignChest((ITEMGUID)_Chest)
		AND
		NOT DB_GLO_LVHub_PlayerChests_Client(_,_Chest)
		THEN
		DebugBreak("Assigning a chest not owned by anyone to the host?");
		
		// Client chest taken over by host
		PROC
		PROC_GLO_LVHub_PlayerChests_HostUserAssignChest((ITEMGUID)_Chest)
		AND
		DB_GLO_LVHub_PlayerChests_Client(_ProfileName,_Chest)
		THEN
		NOT DB_GLO_LVHub_PlayerChests_Client(_ProfileName,_Chest);
		DB_GLO_LVHub_PlayerChests_HostSecondary(_ProfileName,_Chest);
		
		//END_REGION
		
		//REGION Client chest assignment
		PROC
		PROC_GLO_LVHub_PlayerChests_UserAssignChest((INTEGER)_User,(ITEMGUID)_Chest)
		AND
		CharacterGetHostCharacter(_HostChar)
		AND
		NOT CharacterGetReservedUserID(_HostChar,_User)
		THEN
		PROC_GLO_LVHub_PlayerChests_ClientUserAssignChest((INTEGER)_User,(ITEMGUID)_Chest);
		
		PROC
		PROC_GLO_LVHub_PlayerChests_ClientUserAssignChest((INTEGER)_User,(ITEMGUID)_Chest)
		AND
		DB_GLO_LVHub_PlayerChests_Client(_ProfileName,_Chest)
		THEN
		NOT DB_GLO_LVHub_PlayerChests_Client(_ProfileName,_Chest);
		
		PROC
		PROC_GLO_LVHub_PlayerChests_ClientUserAssignChest((INTEGER)_User,(ITEMGUID)_Chest)
		AND
		DB_GLO_LVHub_PlayerChests_HostSecondary(_ProfileName,_Chest)
		THEN
		NOT DB_GLO_LVHub_PlayerChests_HostSecondary(_ProfileName,_Chest);
		
		PROC
		PROC_GLO_LVHub_PlayerChests_ClientUserAssignChest((INTEGER)_User,(ITEMGUID)_Chest)
		AND
		ObjectIsOnStage(_Chest,0)
		THEN
		Foop(_Chest);
		
		PROC
		PROC_GLO_LVHub_PlayerChests_ClientUserAssignChest((INTEGER)_User,(ITEMGUID)_Chest)
		AND
		GetUserProfileID(_User,_ProfileName)
		THEN
		DB_GLO_LVHub_PlayerChests_Client(_ProfileName,_Chest);
		//END_REGION
		
		PROC
		PROC_GLO_LVHub_PlayerChests_UserFindAndAssignChest((INTEGER)_User)
		AND
		GetUserProfileID(_User,_ProfileName)
		AND
		QRY_GLO_LVHub_GetUserChest(_ProfileName)
		AND
		DB_GLO_LVHub_GetUserChestResult(_Chest)
		THEN
		NOT DB_GLO_LVHub_GetUserChestResult(_Chest);
		PROC_GLO_LVHub_PlayerChests_UserAssignChest(_User,_Chest);
		
		//END_REGION
		
		//REGION Access control to chests
		// Client can access own chest
		QRY
		QRY_GLO_LVHub_PlayerChests_PlayerCanAccessChest((CHARACTERGUID)_Player,(ITEMGUID)_Chest)
		AND
		CharacterGetReservedUserID(_Player,_UserID)
		AND
		GetUserProfileID(_UserID,_ProfileName)
		AND
		DB_GLO_LVHub_PlayerChests_Client(_ProfileName,_Chest)
		THEN
		DB_NOOP(1);
		
		// Host-accessible chests
		QRY
		QRY_GLO_LVHub_PlayerChests_HostCanAccessChest((ITEMGUID)_Chest)
		AND
		DB_GLO_LVHub_PlayerChests_Host(_Chest)
		THEN
		DB_NOOP(1);
		
		QRY
		QRY_GLO_LVHub_PlayerChests_HostCanAccessChest((ITEMGUID)_Chest)
		AND
		DB_GLO_LVHub_PlayerChests_HostSecondary(_,_Chest)
		THEN
		DB_NOOP(1);
		
		QRY
		QRY_GLO_LVHub_PlayerChests_PlayerCanAccessChest((CHARACTERGUID)_Player,(ITEMGUID)_Chest)
		AND
		CharacterGetReservedUserID(_Player,_UserID)
		AND
		CharacterGetHostCharacter(_HostPlayer)
		AND
		CharacterGetReservedUserID(_HostPlayer,_UserID)
		AND
		QRY_GLO_LVHub_PlayerChests_HostCanAccessChest(_Chest)
		THEN
		DB_NOOP(1);
		
		PROC
		ProcBlockUseOfItem(_Player,_Chest)
		AND
		DB_GLO_LVHub_PlayerChests_Chest(_Chest)
		AND
		NOT QRY_GLO_LVHub_PlayerChests_PlayerCanAccessChest(_Player,_Chest)
		THEN
		DB_CustomUseItemResponse(_Player,_Chest,0);
		Proc_StartDialog(1,"GLO_AD_CannotUseNow",_Player);
		//END_REGION
		
		//REGION 
		QRY
		QRY_GLO_LVHub_PlayerChests_PlayerHasChest((CHARACTERGUID)_Player)
		AND
		DB_GLO_LVHub_PlayerChests_Chest(_Chest)
		AND
		QRY_GLO_LVHub_PlayerChests_PlayerCanAccessChest(_Player,_Chest)
		THEN
		DB_NOOP(0);
		
		PROC
		ProcSetHomesteadKeyState((CHARACTERGUID)_Player)
		AND
		NOT DB_BlockWaypointUsage(_Player)
		AND
		QRY_GLO_LVHub_PlayerChests_PlayerHasChest(_Player)
		THEN
		PROC_CheckPlayTut(_Player,"TUT_StorageChest");
		
		//END_REGION
		
	}
	EXIT
	{
		
	}
}
Goal(21).Title("_GLO_Shared_Origins");
Goal(21)
{
	INIT
	{
		DB_Origins_MaxPartySize(4);
		
		
	}
	KB
	{
		//REGION Dialogs in which flags are always shared across all shapeshift forms of everyone involved
		// 1) Dialogs involving Origins as NPCs
		IF
		DialogStarted(_,_ID)
		AND
		DB_DialogNPCs(_ID,_NPC,_)
		AND
		DB_Origins_InitialRegion((STRING)_Level)
		AND
		DB_OriginRecruitmentLocation_Region(_Level,(CHARACTERGUID)_NPC,(TRIGGERGUID)_,(STRING)_)
		THEN
		DB_GLO_AllDialogObjectFlagsShared(_ID);
		
		// 2) Dialogs involving multiple player characters
		IF
		DialogStarted(_,_ID)
		AND
		DB_DialogNumPlayers(_ID,_NPlayers)
		AND
		_NPlayers > 1
		THEN
		DB_GLO_AllDialogObjectFlagsShared(_ID);
		
		// Clean up
		IF
		DialogEnded(_,_ID)
		AND
		DB_GLO_AllDialogObjectFlagsShared(_ID)
		THEN
		NOT DB_GLO_AllDialogObjectFlagsShared(_ID);
		//END_REGION
		
		//REGION Alignments as NPC (for GLO_PartyMembers)
		IF
		DB_OriginNPCAlignment((CHARACTERGUID)_Origin,(STRING)_Alignment)
		THEN
		DB_GLO_PartyMembers_OriginalAlignment(_Origin,_Alignment);
		//END_REGION
		
		//REGION Support routines for GLO_PartyMembers
		QRY
		QRY_GLO_PartyMembers_GetInPartyDialog((CHARACTERGUID)_Origin)
		AND
		DB_OriginInPartyDialog(_Origin,(STRING)_Dialog)
		THEN
		DB_GLO_PartyMembers_InPartyDialog(_Origin,_Dialog);
		//END_REGION
		
		//REGION Update origin recruitment location and dialog depending on the region
		IF
		RegionStarted(_Region)
		AND
		StringConcatenate("GLO_Origins_OriginNPCInitForRegion_",_Region,_Mutex)
		AND
		QueryOnlyOnce(_Mutex)
		THEN
		PROC_GLO_OriginNPCInitForRegion(_Region);
		
		
		PROC
		PROC_GLO_OriginNPCInitForRegion((STRING)_Region)
		AND
		DB_OriginRecruitmentLocation((CHARACTERGUID)_Char,(TRIGGERGUID)_Trigger)
		THEN
		NOT DB_OriginRecruitmentLocation(_Char,_Trigger);
		
		PROC
		PROC_GLO_OriginNPCInitForRegion((STRING)_Region)
		AND
		DB_OriginRecruitmentLocation_Region(_Region,(CHARACTERGUID)_Char,(TRIGGERGUID)_Trigger,(STRING)_State)
		THEN
		// We only enter a region once (except when using the debug book...)
		// NOT DB_OriginRecruitmentLocation_Region(_Region,_Char,_Trigger,_State);
		DB_OriginRecruitmentLocation(_Char,_Trigger);
		SetVarFixedString(_Char,"currentState",_State);
		
		PROC
		PROC_GLO_OriginNPCInitForRegion((STRING)_Region)
		AND
		DB_OriginRecruitmentLocation(_Char,_Trigger)
		AND
		NOT DB_IsPlayer(_Char)
		AND
		CharacterIsDead(_Char,0)
		THEN
		PROC_Helper_SafeTeleportTo(_Char,_Trigger);
		
		PROC
		PROC_GLO_Origins_SetNewRegionDialog((CHARACTERGUID)_Origin)
		AND
		QRY_Origin_GetRecruitmentDialog(_Origin)
		AND
		DB_NewOriginRecruitmentDialog(_Origin,_NewDialog)
		THEN
		NOT DB_NewOriginRecruitmentDialog(_Origin,_NewDialog);
		ProcRemoveAllDialogEntriesForSpeaker(_Origin);
		Proc_GLO_Origins_MaybeSetDefaultDialog(_Origin,_NewDialog);
		
		PROC
		PROC_GLO_OriginNPCInitForRegion((STRING)_Region)
		AND
		IsGameLevel(_Region,1)
		AND
		DB_OriginRecruitmentDialog(_Origin,_)
		AND
		NOT DB_IsPlayer(_Origin)
		AND
		CharacterIsDead(_Origin,0)
		THEN
		PROC_GLO_Origins_SetNewRegionDialog(_Origin);
		
		IF
		CharacterResurrected(_Origin)
		AND
		DB_OriginRecruitmentDialog(_Origin,_)
		AND
		NOT DB_IsPlayer(_Origin)
		THEN
		PROC_GLO_Origins_SetNewRegionDialog(_Origin);
		//END_REGION
		
		//REGION Add / Remove from Party
		// Override dialog for origin-as-NPC
		QRY
		QRY_Origin_GetRecruitmentDialog((CHARACTERGUID)_Origin)
		AND
		DB_GLO_PartyMembers_BlockRecruitmentDialog(_Origin)
		THEN
		DB_NewOriginRecruitmentDialog(_Origin,"");
		
		QRY
		QRY_Origin_GetRecruitmentDialog((CHARACTERGUID)_Origin)
		AND
		NOT DB_NewOriginRecruitmentDialog(_Origin,_)
		AND
		DB_CurrentLevel(_Region)
		AND
		DB_OriginRecruitmentDialog_Region(_Region,_Origin,(STRING)_Dialog)
		THEN
		DB_NewOriginRecruitmentDialog(_Origin,_Dialog);
		
		// Default dialog for origin-as-NPC
		QRY
		QRY_Origin_GetRecruitmentDialog((CHARACTERGUID)_Origin)
		AND
		NOT DB_NewOriginRecruitmentDialog(_Origin,_)
		AND
		DB_OriginRecruitmentDialog(_Origin,_Dialog)
		THEN
		DB_NewOriginRecruitmentDialog(_Origin,_Dialog);
		
		IF
		ObjectFlagSet("OriginAddToParty",(CHARACTERGUID)_Origin,_ID)
		AND
		DialogGetInvolvedPlayer(_ID,1,(CHARACTERGUID)_Player)
		THEN
		DB_GLO_PartyMembers_RecruitAfterDialog(_ID,_Origin,_Player);
		ObjectClearFlag(_Origin,"OriginAddToParty",0);
		
		IF
		ObjectFlagSet("OriginRemoveFromPartyAfterDialog",(CHARACTERGUID)_Member,_ID)
		THEN
		ObjectClearFlag(_Member,"OriginRemoveFromPartyAfterDialog",0);
		DB_GLO_PartyMembers_DismissAfterDialog(_ID,_Member);
		
		PROC
		PROC_GLO_PartyMembers_MakeNPCHook((CHARACTERGUID)_Origin)
		AND
		DB_OriginNPCAlignment(_Origin,_)
		AND
		QRY_Origin_GetRecruitmentDialog(_Origin)
		AND
		DB_NewOriginRecruitmentDialog(_Origin,_NewDialog)
		AND
		GetFaction(_Origin,_PlayerFaction)
		AND
		DB_OriginNPCAlignment(_Origin,_NpcFaction)
		THEN
		NOT DB_NewOriginRecruitmentDialog(_Origin,_NewDialog);
		ProcCancelAllRelationshipDialogs(_Origin);
		Proc_ReflectionDialog_CancelForPlayer(_Origin);
		// Proc_ReflectionDialog_CancelForPlayer() restores the previous dialog, so only now cancel all existing dialogs
		ProcRemoveAllDialogEntriesForSpeaker(_Origin);
		Proc_GLO_Origins_MaybeSetDefaultDialog(_Origin,_NewDialog);
		SetHasDialog(_Origin,0); // Origin should not have dialog until AFTER they have returned to recruit position
		
		PROC
		Proc_GLO_Origins_MaybeSetDefaultDialog((CHARACTERGUID)_Origin,(STRING)_NewDialog)
		AND
		NOT DB_Avatars(_Origin)
		AND
		_NewDialog != ""
		THEN
		DB_Dialogs(_Origin,_NewDialog);
		
		PROC
		PROC_GLO_PartyMembers_MakeNPCHook((CHARACTERGUID)_Origin)
		AND
		DB_CompanionAvatarBond(_Origin,_Player)
		THEN
		NOT DB_CompanionAvatarBond(_Origin,_Player);
		Proc_CompanionLeftParty(_Origin,_Player);
		
		PROC
		Proc_GLO_Origins_RemoveRecruitmentDialogs((CHARACTERGUID)_Origin)
		AND
		DB_OriginRecruitmentDialog_Region(_Region,_Origin,_Dialog)
		THEN
		NOT DB_OriginRecruitmentDialog_Region(_Region,_Origin,_Dialog);
		
		PROC
		Proc_GLO_Origins_RemoveRecruitmentDialogs((CHARACTERGUID)_Origin)
		AND
		DB_OriginRecruitmentDialog(_Origin,_Dialog)
		THEN
		NOT DB_OriginRecruitmentDialog(_Origin,_Dialog);
		
		PROC
		PROC_GLO_PartyMembers_MakeNPCHook((CHARACTERGUID)_Origin)
		AND
		DB_OriginNPCAlignment(_Origin,_)
		AND
		NOT DB_GLO_PartyMembers_BlockReturnToRecruitmentPosition(_Origin)
		THEN
		ProcOriginReturnToRecruitmentPos(_Origin);
		
		//REGION Return to Recruitment Pos
		PROC
		ProcOriginReturnToRecruitmentPos((CHARACTERGUID)_Origin)
		AND
		DB_OriginRecruitmentLocation(_Origin,_Location)
		AND
		GetDistanceTo(_Origin,_Location,_Dist)
		AND
		_Dist > 18.0
		THEN
		ProcCharacterDisappearOutOfSight(_Origin,0,0,"Origin_RestoreDialog",0);
		
		PROC
		ProcOriginReturnToRecruitmentPos((CHARACTERGUID)_Origin)
		AND
		DB_OriginRecruitmentLocation(_Origin,_Location)
		AND
		GetDistanceTo(_Origin,_Location,_Dist)
		AND
		_Dist <= 18.0
		THEN
		ProcCharacterMoveTo(_Origin,_Location,0,"Origin_RestoreDialog");
		
		// Character creation
		PROC
		ProcOriginReturnToRecruitmentPos((CHARACTERGUID)_Origin)
		AND
		NOT DB_OriginRecruitmentLocation(_Origin,_)
		AND
		DB_Origins_InitialRegion(_InitialRegion)
		AND
		DB_OriginRecruitmentLocation_Region(_InitialRegion,_Origin,_Location,_)
		THEN
		TeleportTo(_Origin,_Location);
		SetStoryEvent(_Origin,"Origin_RestoreDialog");
		
		// Not character creation
		IF
		StoryEvent((CHARACTERGUID)_Origin,"Origin_RestoreDialog")
		AND
		DB_OriginRecruitmentLocation(_Origin,_Location)
		THEN
		TeleportTo(_Origin,_Location);
		
		// Character Creation
		IF
		StoryEvent((CHARACTERGUID)_Origin,"Origin_RestoreDialog")
		AND
		NOT DB_OriginRecruitmentLocation(_Origin,_)
		AND
		DB_Origins_InitialRegion(_Region)
		AND
		DB_OriginRecruitmentLocation_Region(_Region,_Origin,_Location,_)
		THEN
		TeleportTo(_Origin,_Location);
		
		IF
		StoryEvent((CHARACTERGUID)_Origin,"Origin_RestoreDialog")
		THEN
		SetOnStage(_Origin,1);
		SetHasDialog(_Origin,1);
		//END_REGION
		
		PROC
		PROC_GLO_PartyMembers_RecruiteeAvatarBond((CHARACTERGUID)_Companion,(CHARACTERGUID)_Avatar)
		AND
		DB_OriginNPCAlignment(_Companion,_)
		THEN
		DB_CompanionAvatarBond(_Companion,_Avatar);
		
		PROC
		PROC_GLO_PartyMembers_ClearRecruiteeBonds((CHARACTERGUID)_Companion)
		AND
		DB_CompanionAvatarBond(_Companion,_Avatar)
		THEN
		NOT DB_CompanionAvatarBond(_Companion,_Avatar);
		
		PROC
		Proc_BondedAvatarTutorial((CHARACTERGUID)_Avatar)
		AND
		SysCount("DB_Avatars",1,_AvatarCount)
		AND
		_AvatarCount > 1
		AND
		DB_InitialTutorialsShown(1)
		AND
		DB_IsPlayer(_Player)
		AND
		CharacterIsInPartyWith(_Avatar,_Player,1)
		THEN
		Proc_CheckPlayTut(_Player,"TUT_BondedAvatar");
		
		PROC
		ProcAssignCharacterToPlayer((CHARACTERGUID)_Char,(CHARACTERGUID)_Player)
		AND
		CharacterGetReservedUserID(_Player,_User)
		THEN
		CharacterAssignToUser(_User,_Char);
		
		//REGION Check Party Size
		//Check for Solo Player
		PROC
		Proc_CheckPartyFull()
		AND
		SysCount("DB_IsPlayer",1,_Int)
		AND
		_Int == 1
		THEN
		GlobalSetFlag("GEN_SoloPlayer");
		
		//Check for Max Player count
		PROC
		Proc_CheckPartyFull()
		AND
		SysCount("DB_IsPlayer",1,_Int)
		AND
		_Int != 1
		THEN
		GlobalClearFlag("GEN_SoloPlayer");
		
		PROC
		Proc_CheckPartyFull()
		AND
		SysCount("DB_IsPlayer",1,_Int)
		AND
		DB_Origins_MaxPartySize(_Max)
		AND
		_Int == _Max
		THEN
		GlobalSetFlag("GEN_MaxPlayerCountReached");
		
		PROC
		Proc_CheckPartyFull()
		AND
		SysCount("DB_IsPlayer",1,_Int)
		AND
		DB_Origins_MaxPartySize(_Max)
		AND
		_Int < _Max
		THEN
		GlobalClearFlag("GEN_MaxPlayerCountReached");
		//END_REGION
		//END_REGION
		
		//REGION User Companion Differentiation
		PROC
		PROC_GLOBAL_DialogStartRequested((CHARACTERGUID)_Player,(CHARACTERGUID)_OtherPlayer)
		AND
		DB_IsPlayer(_Player)
		AND
		DB_IsPlayer(_OtherPlayer)
		AND
		CharacterGetReservedUserID(_Player,_PID)
		AND
		CharacterGetReservedUserID(_OtherPlayer,_OPID)
		AND
		_PID == _OPID
		THEN
		ObjectSetFlag(_OtherPlayer,"UserOwnedPlayerCharacter");
		
		IF
		DialogEnded(_,_ID)
		AND
		DialogGetInvolvedPlayer(_ID,1,_Player)
		AND
		ObjectGetFlag(_Player,"UserOwnedPlayerCharacter",1)
		THEN
		ObjectClearFlag(_Player,"UserOwnedPlayerCharacter",0);
		
		//END_REGION
		
		//REGION Origin Hostility
		IF
		ObjectFlagSet("SetOriginHostileAfterDialog",_UnRecruitedOrigin,_)
		THEN
		DB_SetOriginHostileAfterDialog(_UnRecruitedOrigin);
		ObjectClearFlag(_UnRecruitedOrigin,"SetOriginHostileToOtherOrigins",0);
		
		IF
		DialogEnded(_,_ID)
		AND
		DB_SetOriginHostileAfterDialog(_UnRecruitedOrigin)
		AND
		DialogGetInvolvedNPC(_ID,1,(CHARACTERGUID)_UnRecruitedOrigin)
		AND
		GetFaction(_UnRecruitedOrigin,_PreviousFaction)
		THEN
		NOT DB_SetOriginHostileAfterDialog(_UnRecruitedOrigin);
		ProcSetRelationToPlayers(_UnRecruitedOrigin,0);
		DB_ResetOriginAlignmentAfterCombat(_UnRecruitedOrigin,_PreviousFaction);
		
		IF
		ObjectLeftCombat(_UnRecruitedOrigin,_)
		AND
		DB_ResetOriginAlignmentAfterCombat((CHARACTERGUID)_UnRecruitedOrigin,_PreviousFaction)
		THEN
		SetFaction(_UnRecruitedOrigin,_PreviousFaction);
		NOT DB_ResetOriginAlignmentAfterCombat(_UnRecruitedOrigin,_PreviousFaction);
		
		/*
		IF
		ObjectFlagSet("FactionHostileToIndivPlayerAfterDialog",_,_ID)
		AND
		DialogGetInvolvedNPC(_ID,1,(CHARACTERGUID)_Origin)
		AND
		DB_GLO_PartyMembers_DefaultFaction(_Origin,_PlayerFaction)
		THEN
		SetFaction(_Origin,_PlayerFaction);
		*/
		//END_REGION
		 
		//REGION Avatar Tracking
		//Avatar DB_ to keep track of counts
		IF
		ObjectWasTagged((CHARACTERGUID)_Avatar,"AVATAR")
		AND
		NOT DB_Avatars(_Avatar)
		THEN
		DB_Avatars(_Avatar);
		
		//For Story Reloads
		IF
		DB_IsPlayer(_Avatar)
		AND
		IsTagged((CHARACTERGUID)_Avatar,"AVATAR",1)
		AND
		NOT DB_Avatars(_Avatar)
		THEN
		DB_Avatars(_Avatar);
		
		IF
		ObjectLostTag((CHARACTERGUID)_Avatar,"AVATAR")
		AND
		DB_Avatars(_Avatar)
		THEN
		NOT DB_Avatars(_Avatar);
		//END_REGION
		
		//REGION Resurrection Blocking Spell
		IF
		CharacterUsedSkillOnTarget(_,(CHARACTERGUID)_Origin,"Target_AntiResurrection",_,_)
		THEN
		SetTag(_Origin,"BLOCK_RESURRECTION");
		
		IF
		CharacterUsedSkillOnTarget(_,(CHARACTERGUID)_Origin,"Target_AntiResurrection",_,_)
		AND
		IsTagged(_Origin,"AVATAR",0)
		THEN
		DB_GLO_PartyMembers_BlockReturnToRecruitmentPosition(_Origin);
		PROC_GLO_PartyMembers_Remove(_Origin,(CHARACTERGUID)NULL_00000000-0000-0000-0000-000000000000,0);
		CharacterPurgeQueue(_Origin);
		
		//END_REGION
		
		//REGION Relationship changes
		IF
		ObjectFlagSet(_Event,(CHARACTERGUID)_Companion,_Inst)
		AND
		DB_OriginRelationChangeEvent(_Event,(INTEGER)_Amount)
		AND
		DB_CompanionAvatarBond((CHARACTERGUID)_Companion,_Player)
		AND
		CharacterGetAttitudeTowardsPlayer(_Companion,(CHARACTERGUID)_Player,_CurrentAttitude)
		AND
		QRY_OriginRelationModify(_Companion,_Amount)
		AND
		DB_OriginRelationModifiedAmount(_NewAmount)
		AND
		IntegerSum(_CurrentAttitude,_NewAmount,_NewAttitude)
		THEN
		PROC_OriginWarningBlockRemoval(_Companion,_NewAmount);
		ObjectClearFlag(_Companion,_Event);
		PROC_CheckPlayTut(_Player,"TUT_Relationship_Examine");
		DB_SetCompanionAttitude(_Companion,_Player,_NewAttitude);
		
		IF
		ObjectFlagSet(_Event,(CHARACTERGUID)_Companion,_Inst)
		AND
		DB_OriginRelationChangeEvent(_Event,_Amount)
		AND
		NOT DB_CompanionAvatarBond(_Companion,_)
		AND
		DB_DialogPlayers(_Inst,_Player,_)
		AND
		_Player != _Companion
		AND
		CharacterGetAttitudeTowardsPlayer(_Companion,(CHARACTERGUID)_Player,_CurrentAttitude)
		AND
		QRY_OriginRelationModify(_Companion,_Amount)
		AND
		DB_OriginRelationModifiedAmount(_NewAmount)
		AND
		IntegerSum(_CurrentAttitude,_NewAmount,_NewAttitude)
		THEN
		PROC_OriginWarningBlockRemoval(_Companion,_NewAmount);
		ObjectClearFlag(_Companion,_Event);
		DB_SetCompanionAttitude(_Companion,_Player,_NewAttitude);
		
		QRY
		QRY_OriginRelationModify((CHARACTERGUID)_Companion,(INTEGER)_Amount)
		AND
		QRY_OriginRelationModify_Reset() //Resets the return variable, always returns true
		AND
		DB_OriginRelationModifiers(_Companion,(INTEGER)_Multiply,(INTEGER)_Divide)
		AND
		IntegerProduct(_Amount,_Multiply,_Intermediate)
		AND
		IntegerDivide(_Intermediate,_Divide,_NewAmount)
		THEN
		DB_OriginRelationModifiedAmount(_NewAmount);
		
		QRY
		QRY_OriginRelationModify((CHARACTERGUID)_Companion,(INTEGER)_Amount)
		AND
		NOT DB_OriginRelationModifiedAmount(_)
		THEN
		DB_OriginRelationModifiedAmount(_Amount);
		
		QRY
		QRY_OriginRelationModify_Reset()
		AND
		DB_OriginRelationModifiedAmount(_NewAmount)
		THEN
		NOT DB_OriginRelationModifiedAmount(_NewAmount);
		
		QRY
		QRY_OriginRelationModify_Reset()
		THEN
		DB_NoOp(1);
		
		//Every time a warning is given, a block is set on new warnings until a new drop in attitude occurs.
		PROC
		PROC_OriginWarningBlockRemoval((CHARACTERGUID)_Companion,(INTEGER)_Amount)
		AND
		_Amount < 0
		THEN
		NOT DB_OriginWarningBlock(_Companion);
		
		IF
		DB_SetCompanionAttitude(_Companion,_Player,_NewAttitude)
		AND
		_NewAttitude > 100
		THEN
		NOT DB_SetCompanionAttitude(_Companion,_Player,_NewAttitude);
		DB_SetCompanionAttitude(_Companion,_Player,100);
		
		IF
		DB_SetCompanionAttitude(_Companion,_Player,_NewAttitude)
		AND
		_NewAttitude < -50
		THEN
		NOT DB_SetCompanionAttitude(_Companion,_Player,_NewAttitude);
		DB_SetCompanionAttitude(_Companion,_Player,-50);
		
		IF
		DB_SetCompanionAttitude(_Companion,_Player,_NewAttitude)
		AND
		_NewAttitude <= 100
		AND
		_NewAttitude >= -50
		AND
		CharacterGetAttitudeTowardsPlayer(_Companion,_Player,_CurrentAttitude)
		AND
		IntegerSubtract(_NewAttitude,_CurrentAttitude,_Delta)
		THEN
		CharacterAddAttitudeTowardsPlayer(_Companion,_Player,_Delta);
		NOT DB_SetCompanionAttitude(_Companion,_Player,_NewAttitude);
		
		IF
		DB_OriginInPartyDialog(_Companion,_Dialog)
		THEN
		DB_OriginDialog((CHARACTERGUID)_Companion,_Dialog);
		
		PROC
		Proc_RelationshipDialog((CHARACTERGUID)_Companion,(STRING)_Dialog,(CHARACTERGUID)_Anchor)
		THEN
		DB_OriginDialog(_Companion,_Dialog);
		
		IF
		DialogEnded(_Dialog,_ID)
		AND
		NOT DB_Origin_BlockLeavingWarningsDialogs(1)
		AND
		DB_OriginDialog(_Companion,_Dialog)
		AND
		DB_DialogPlayers(_ID,_Companion,_)
		AND
		NOT DB_GLO_PartyMembers_DismissAfterDialog(_ID,_Companion)
		AND
		DB_CompanionAvatarBond((CHARACTERGUID)_Companion,(CHARACTERGUID)_Player)
		AND
		DB_DialogPlayers(_ID,_Player,_)
		AND
		DB_OriginWarning1Dialog(_Companion,_Warning1Dialog)
		AND
		CharacterGetAttitudeTowardsPlayer(_Companion,_Player,_Attitude)
		AND
		_Attitude <= -20
		AND
		QRY_StartDialog(0,_Warning1Dialog,_Companion,_Player)
		THEN
		NOT DB_OriginWarning1Dialog(_Companion,_Warning1Dialog);
		DB_OriginWarningBlock(_Companion);
		
		IF
		DialogEnded(_Dialog,_ID)
		AND
		NOT DB_Origin_BlockLeavingWarningsDialogs(1)
		AND
		DB_OriginDialog(_Companion,_Dialog)
		AND
		NOT DB_OriginWarningBlock(_Companion)
		AND
		NOT DB_GLO_PartyMembers_DismissAfterDialog(_ID,_Companion)
		AND
		DB_DialogPlayers(_ID,_Companion,_)
		AND
		DB_CompanionAvatarBond((CHARACTERGUID)_Companion,(CHARACTERGUID)_Player)
		AND
		DB_DialogPlayers(_ID,_Player,_)
		AND
		DB_OriginWarning2Dialog(_Companion,_Warning2Dialog)
		AND
		CharacterGetAttitudeTowardsPlayer(_Companion,_Player,_Attitude)
		AND
		_Attitude <= -40
		AND
		QRY_StartDialog(0,_Warning2Dialog,_Companion,_Player)
		THEN
		NOT DB_OriginWarning2Dialog(_Companion,_Warning2Dialog);
		DB_OriginWarningBlock(_Companion);
		
		IF
		DialogEnded(_Dialog,_ID)
		AND
		NOT DB_Origin_BlockLeavingWarningsDialogs(1)
		AND
		DB_OriginDialog(_Companion,_Dialog)
		AND
		NOT DB_OriginWarningBlock(_Companion)
		AND
		NOT DB_GLO_PartyMembers_DismissAfterDialog(_ID,_Companion)
		AND
		DB_DialogPlayers(_ID,_Companion,_)
		AND
		DB_CompanionAvatarBond((CHARACTERGUID)_Companion,(CHARACTERGUID)_Player)
		AND
		DB_DialogPlayers(_ID,_Player,_)
		AND
		NOT DB_CompanionLeaving(_Companion,_)
		AND
		CharacterGetAttitudeTowardsPlayer(_Companion,_Player,_Attitude)
		AND
		_Attitude <= -50
		AND
		DB_OriginLeavingDialog(_Companion,_LeaveDialog)
		THEN
		Proc_StartDialog(0,_LeaveDialog,_Companion,_Player);
		
		IF
		DialogEnded(_Dialog,_ID)
		AND
		DB_OriginDialog(_Companion,_Dialog)
		THEN
		NOT DB_OriginDialog(_Companion,_Dialog);
		
		PROC
		PROC_Origins_CompanionLeavePermanently((CHARACTERGUID)_Companion)
		AND
		DB_CompanionAvatarBond(_Companion,_Player)
		THEN
		CharacterSetCorpseLootable(_Companion,1);
		DB_GLO_PartyMembers_BlockReturnToRecruitmentPosition(_Companion);
		Proc_GLO_Origins_RemoveRecruitmentDialogs(_Companion);
		PROC_GLO_PartyMembers_MakeNPC(_Companion);
		NOT DB_NoLowAttitudeDialog(_Companion);
		NOT DB_GLO_PartyMembers_BlockReturnToRecruitmentPosition(_Companion);
		NOT DB_CompanionAvatarBond(_Companion,_Player);
		Proc_CompanionLeftParty(_Companion,_Player);
		Proc_OriginLeft(_Companion,"");
		
		PROC
		PROC_Origins_CompanionLeavePermanently((CHARACTERGUID)_Companion)
		AND
		DB_OriginInPartyDialog(_Companion,_Dialog)
		THEN
		NOT DB_OriginInPartyDialog(_Companion,_Dialog);
		
		PROC
		PROC_Origins_CompanionLeavePermanently((CHARACTERGUID)_Companion)
		AND
		DB_OriginRecruitmentLocation(_Companion,_Location)
		THEN
		NOT DB_OriginRecruitmentLocation(_Companion,_Location);
		
		IF
		DialogEnded(_OriginLeavingDialog,_Inst)
		AND
		DB_OriginLeavingDialog(_Companion,_OriginLeavingDialog)
		AND
		ObjectGetFlag(_Companion,"GLO_Companion_Leave",1)
		AND
		DB_CompanionAvatarBond((CHARACTERGUID)_Companion,(CHARACTERGUID)_Player)
		THEN
		PROC_Origins_CompanionLeavePermanently(_Companion);
		NOT DB_OriginLeavingDialog(_Companion,_OriginLeavingDialog);
		DB_CompanionLeaving(_Companion,_Player);
		CharacterMakeStoryNpc(_Companion,1);
		ProcCharacterDisappearOutOfSight(_Companion,0,1,"GLO_CompanionLeaves_LowRelation",1);
		Proc_OriginLeft(_Companion,"_LowRelation");
		
		IF
		DialogEnded(_OriginLeavingDialog,_Inst)
		AND
		DB_OriginLeavingDialog(_Companion,_OriginLeavingDialog)
		AND
		ObjectGetFlag(_Companion,"GLO_Companion_Murder",1)
		AND
		DB_CompanionAvatarBond((CHARACTERGUID)_Companion,(CHARACTERGUID)_Player)
		AND
		DB_OriginRecruitmentLocation(_Companion,_Location)
		THEN
		NOT DB_OriginLeavingDialog(_Companion,_OriginLeavingDialog);
		CharacterMakeNPC(_Companion);
		NOT DB_OriginRecruitmentLocation(_Companion,_Location);
		CharacterDie(_Companion,1,"DoT");
		NOT DB_IsPlayer(_Companion);
		NOT DB_CompanionAvatarBond(_Companion,_Player);
		Proc_CompanionLeftParty(_Companion,_Player);
		Proc_CheckPartyFull();
		
		IF
		DialogEnded(_OriginLeavingDialog,_Inst)
		AND
		DB_OriginLeavingDialog(_Companion,_OriginLeavingDialog)
		AND
		ObjectGetFlag(_Companion,"GLO_Companion_Combat",1)
		AND
		DB_CompanionAvatarBond((CHARACTERGUID)_Companion,(CHARACTERGUID)_Player)
		AND
		DB_OriginRecruitmentLocation(_Companion,_Location)
		THEN
		PROC_Origins_CompanionLeavePermanently(_Companion);
		NOT DB_OriginLeavingDialog(_Companion,_OriginLeavingDialog);
		SetVarFixedString(_Companion,"currentState","");
		SetRelationIndivFactionToPlayers(_Companion,0);
		Proc_OriginLeft(_Companion,"_LowRelation");
		
		IF
		StoryEvent(_Companion,"GLO_CompanionLeaves_LowRelation")
		AND
		DB_CompanionLeaving((CHARACTERGUID)_Companion,(CHARACTERGUID)_Player)
		THEN
		NOT DB_CompanionLeaving(_Companion,_Player);
		PROC_GLO_PartyMembers_TransferInventoryToPlayer(_Companion,_Player);
		
		IF
		ItemAddedToContainer(_Item,_BackPack)
		AND
		DB_CompanionLeavingBackPack((CHARACTERGUID)_Companion,(CHARACTERGUID)_Player,_BackPack)
		AND
		ItemGetOriginalOwner(_Item,_Companion)
		THEN
		ItemSetOriginalOwner(_Item,_Player);
		
		
		IF
		DB_CompanionAvatarBond(_Companion,_Player)
		AND
		CharacterGetAttitudeTowardsPlayer(_Companion,_Player,_Attitude)
		AND
		DB_OriginRelationThresholdEvents((STRING)_Event,(INTEGER)_Threshold)
		AND
		_Attitude >= _Threshold
		THEN
		ObjectSetFlag(_Companion,_Event);
		
		IF
		DB_CompanionAvatarBond(_Companion,_Player)
		AND
		CharacterGetAttitudeTowardsPlayer(_Companion,_Player,_Attitude)
		AND
		DB_OriginRelationThresholdEvents(_Event,_Threshold)
		AND
		_Attitude < _Threshold
		THEN
		ObjectClearFlag(_Companion,_Event);
		
		
		IF
		CharacterAttitudeTowardsPlayerChanged(_Companion,_Player,_Attitude)
		AND
		DB_CompanionAvatarBond(_Companion,_Player)
		AND
		DB_OriginRelationThresholdEvents(_Event,_Threshold)
		AND
		_Attitude >= _Threshold
		THEN
		ObjectSetFlag(_Companion,_Event);
		
		IF
		CharacterAttitudeTowardsPlayerChanged(_Companion,_Player,_Attitude)
		AND
		DB_CompanionAvatarBond(_Companion,_Player)
		AND
		DB_OriginRelationThresholdEvents(_Event,_Threshold)
		AND
		_Attitude < _Threshold
		THEN
		ObjectClearFlag(_Companion,_Event);
		
		PROC
		Proc_DialogFlagSetup((STRING)_Dialog,(GUIDSTRING)_Companion,(GUIDSTRING)_Player)
		AND
		DB_OriginRecruitmentDialog((CHARACTERGUID)_Companion,_Dialog)
		AND
		CharacterGetAttitudeTowardsPlayer(_Companion,(CHARACTERGUID)_Player,_Attitude)
		AND
		DB_OriginRelationThresholdEvents(_Event,_Threshold)
		AND
		_Attitude >= _Threshold
		THEN
		ObjectSetFlag(_Companion,_Event);
		
		PROC
		Proc_DialogFlagSetup((STRING)_Dialog,(GUIDSTRING)_Companion,(GUIDSTRING)_Player)
		AND
		DB_OriginRecruitmentDialog((CHARACTERGUID)_Companion,_Dialog)
		AND
		CharacterGetAttitudeTowardsPlayer(_Companion,(CHARACTERGUID)_Player,_Attitude)
		AND
		DB_OriginRelationThresholdEvents(_Event,_Threshold)
		AND
		_Attitude < _Threshold
		THEN
		ObjectClearFlag(_Companion,_Event);
		
		//END_REGION
		
		
		//REGION Companions cant recruit companions
		//Companion in party with initiates conversation with unhired companion.
		PROC
		Proc_StartDialog(0,(STRING)_RecruitementDialog,(GUIDSTRING)_UnhiredCompanion,(GUIDSTRING)_NonAvatar)
		AND
		DB_OriginRecruitmentDialog((CHARACTERGUID)_UnhiredCompanion,_RecruitementDialog)
		AND
		NOT DB_Avatars((CHARACTERGUID)_NonAvatar)
		AND
		DB_CompanionAvatarBond((CHARACTERGUID)_NonAvatar,(CHARACTERGUID)_Avatar)
		AND
		QRY_SpeakerIsAvailableAndInDialogRange(_Avatar,_NonAvatar)
		AND
		CharacterIsControlled(_Avatar,0)
		AND
		QRY_StartDialog(0,_RecruitementDialog,_UnhiredCompanion,_Avatar)
		THEN
		PROC_CheckPlayTut(_Avatar,"TUT_Comp_Talking_To_Comp");
		MakePlayerActive(_Avatar);
		
		PROC
		Proc_StartDialog(0,(STRING)_RecruitementDialog,(GUIDSTRING)_UnhiredCompanion,(GUIDSTRING)_NonAvatar)
		AND
		DB_OriginRecruitmentDialog((CHARACTERGUID)_UnhiredCompanion,_RecruitementDialog)
		AND
		QRY_StartDialog(0,_RecruitementDialog,_UnhiredCompanion,_NonAvatar)
		THEN
		DB_NoOp(1);
		
		//Companion in party with initiates conversation with unhired companion.
		IF
		DialogStarted(_RecruitementDialog,_ID)
		AND
		DB_OriginRecruitmentDialog(_UnhiredCompanion,_RecruitementDialog)
		AND
		DB_DialogPlayers(_ID,_Player,1)
		AND
		NOT DB_Avatars((CHARACTERGUID)_Player)
		THEN
		PROC_CheckPlayTut(_Player,"TUT_Comp_Talking_To_Comp");
		//END_REGION
		
		//REGION Profession Tags
		IF
		DB_OriginProfessionTags((CHARACTERGUID)_Char,(STRING)_Tag)
		THEN
		SetTag(_Char,_Tag);
		
		
		//END_REGION
		
		//REGION
		//Res blocked after death
		IF
		ObjectWasTagged((CHARACTERGUID)_Origin,"BLOCK_RESURRECTION")
		AND
		DB_FormerCompanionDeath_QuestUpdate(_Origin,(STRING)_Update)
		AND
		CharacterIsDead(_Origin,1)
		THEN
		PROC_FormerCompanionDeath_QuestUpdate(_Origin,_Update);
		
		//Died when not in party
		IF
		CharacterDied((CHARACTERGUID)_Origin)
		AND
		DB_FormerCompanionDeath_QuestUpdate(_Origin,_Update)
		AND
		NOT DB_IsPlayer(_Origin)
		THEN
		PROC_FormerCompanionDeath_QuestUpdate(_Origin,_Update);
		
		//Died with block res
		IF
		CharacterDied((CHARACTERGUID)_Origin)
		AND
		DB_FormerCompanionDeath_QuestUpdate(_Origin,_Update)
		AND
		IsTagged(_Origin,"BLOCK_RESURRECTION",1)
		THEN
		PROC_FormerCompanionDeath_QuestUpdate(_Origin,_Update);
		
		//Apply update to Avatars
		PROC
		PROC_FormerCompanionDeath_QuestUpdate((CHARACTERGUID)_Origin,(STRING)_Update)
		AND
		GetRegion(_Origin,_Region)
		AND
		_Region != "TUT_Tutorial_A"
		AND
		DB_Avatars(_Avatar)
		THEN
		ObjectSetFlag(_Avatar,_Update);
		
		//END_REGION
		
		//REGION CharacterCreation
		IF
		CharacterStartOriginIntroduction(_Character,_,_Origin)
		AND
		CharacterGetReservedUserID(_Character,_User)
		THEN
		ProcStartOriginIntroduction(_Character,_User,_Origin);
		
		IF
		CharacterStopOriginIntroduction(_Character,_)
		AND
		CharacterGetReservedUserID(_Character,_User)
		THEN
		ProcStopOriginIntroduction(_Character,_User);
		
		IF
		StoryEvent((CHARACTERGUID)_Char,"OriginIntroductionFinished")
		THEN
		CharacterOriginIntroStopped(_Char);
		
		PROC
		ProcStartOriginIntroduction((CHARACTERGUID)_Character,(INTEGER)_User,(STRING)_Origin)
		AND
		DB_InOriginIntroduction(_User)
		THEN
		ProcStopOriginIntroduction(_Character,_User);
		
		PROC
		ProcStartOriginIntroduction(_Character,_User,_Origin)
		AND
		DB_OriginIntroductions((STRING)_Origin,(STRING)_Anim,(STRING)_Music,(STRING)_Jingle)
		THEN
		DB_InOriginIntroduction(_User);
		MusicPlayForPeer(_Character,_Jingle);
		MusicPlayForPeer(_Character,_Music);
		SetVarFixedString(_Character,"CCIntroductionAnim",_Anim);
		SetStoryEvent(_Character,"GLO_StartOriginIntroduction");
		
		PROC
		ProcStopOriginIntroduction((CHARACTERGUID)_Character,(INTEGER)_User)
		AND
		DB_InOriginIntroduction(_User)
		THEN
		NOT DB_InOriginIntroduction(_User);
		MusicPlayForPeer(_Character,"Presentation_Stop");
		SetStoryEvent(_Character,"GLO_StopOriginIntroduction");
		PlaySound(_Character,"Origin_Presentation_Stop");
		//END_REGION
		
		//REGION Orphan Flag Forwarding
		IF
		ObjectFlagSet(_Flag,_Companion,_)
		AND
		DB_OrphanFlagForwarding(_Flag)
		AND
		DB_CompanionAvatarBond((CHARACTERGUID)_Companion,_Avatar)
		THEN
		ObjectClearFlag(_Companion,_Flag);
		ObjectSetFlag(_Avatar,_Flag);
		//END_REGION 
		
	}
	EXIT
	{
		
	}
}
Goal(22).Title("_GLO_Shared_PartyMembers");
Goal(22)
{
	INIT
	{
		DB_Origins_MaxPartySize(4);
		
		
	}
	KB
	{
		//REGION Helpers
		QRY
		QRY_GLO_PartyMembers_GetInPartyDialogReset((CHARACTERGUID)_Member)
		THEN
		PROC_GLO_PartyMembers_ResetInPartyDialogs((CHARACTERGUID)_Member);
		
		PROC
		PROC_GLO_PartyMembers_ResetInPartyDialogs((CHARACTERGUID)_Origin)
		AND
		DB_GLO_PartyMembers_InPartyDialog(_Origin,_Dialog)
		THEN
		NOT DB_GLO_PartyMembers_InPartyDialog(_Origin,_Dialog);
		
		PROC
		PROC_GLO_PartyMembers_SetInpartyDialog((CHARACTERGUID)_Member,(STRING)_Dialog)
		THEN
		ProcRemoveAllDialogEntriesForSpeaker(_Member);
		
		PROC
		PROC_GLO_PartyMembers_SetInpartyDialog((CHARACTERGUID)_Member,(STRING)_Dialog)
		AND
		_Dialog != ""
		THEN
		DB_Dialogs(_Member,_Dialog);
		
		PROC
		ProcAssignCharacterToPlayer((CHARACTERGUID)_Char,(CHARACTERGUID)_Player)
		AND
		CharacterGetReservedUserID(_Player,_User)
		THEN
		CharacterAssignToUser(_User,_Char);
		//END_REGION
		
		//REGION Check Party Size
		//Check for Solo Player
		PROC
		Proc_CheckPartyFull()
		AND
		SysCount("DB_IsPlayer",1,_Int)
		AND
		_Int == 1
		THEN
		GlobalSetFlag("GEN_SoloPlayer");
		
		//Check for Max Player count
		PROC
		Proc_CheckPartyFull()
		AND
		SysCount("DB_IsPlayer",1,_Int)
		AND
		_Int != 1
		THEN
		GlobalClearFlag("GEN_SoloPlayer");
		
		PROC
		Proc_CheckPartyFull()
		AND
		SysCount("DB_IsPlayer",1,_Int)
		AND
		DB_Origins_MaxPartySize(_Max)
		AND
		_Int == _Max
		THEN
		GlobalSetFlag("GEN_MaxPlayerCountReached");
		
		PROC
		Proc_CheckPartyFull()
		AND
		SysCount("DB_IsPlayer",1,_Int)
		AND
		DB_Origins_MaxPartySize(_Max)
		AND
		_Int < _Max
		THEN
		GlobalClearFlag("GEN_MaxPlayerCountReached");
		
		//END_REGION
		
		//REGION Recruit/dismiss after dialog
		IF
		ObjectFlagSet("OriginRemoveFromPartyAfterDialog",(CHARACTERGUID)_Member,_ID)
		THEN
		ObjectClearFlag(_Member,"OriginRemoveFromPartyAfterDialog",0);
		DB_GLO_PartyMembers_DismissAfterDialog(_ID,_Member);
		
		IF
		DialogEnded(_,_ID)
		AND
		DB_GLO_PartyMembers_DismissAfterDialog(_ID,_Member)
		AND
		DialogGetInvolvedPlayer(_ID,2,_Player)
		THEN
		NOT DB_GLO_PartyMembers_DismissAfterDialog(_ID,_Member);
		PROC_GLO_PartyMembers_Remove(_Member,(CHARACTERGUID)_Player,0);
		
		IF
		DialogEnded(_,_ID)
		AND
		DB_GLO_PartyMembers_RecruitAfterDialog(_ID,_Origin,_Player)
		THEN
		PROC_GLO_PartyMembers_CheckAdd(_Origin,_Player);
		NOT DB_GLO_PartyMembers_RecruitAfterDialog(_ID,_Origin,_Player);
		//END_REGION
		
		//REGION Recruit a party member
		PROC
		PROC_GLO_PartyMembers_CheckAdd((CHARACTERGUID)_Origin,(CHARACTERGUID)_Player)
		AND
		GlobalGetFlag("GEN_MaxPlayerCountReached",0)
		THEN
		PROC_GLO_PartyMembers_Add(_Origin,_Player);
		
		// Dummy for adding avatars to the party; can happen after kicking them
		QRY
		QRY_GLO_PartyMembers_GetInPartyDialog((CHARACTERGUID)_Avatar)
		AND
		IsTagged(_Avatar,"AVATAR",1)
		THEN
		DB_GLO_PartyMembers_InPartyDialog(_Avatar,"");
		
		PROC
		Proc_CheckFirstTimeRecruited((CHARACTERGUID)_Companion)
		THEN
		DB_NOOP(1);
		
		PROC
		PROC_GLO_PartyMembers_Add((CHARACTERGUID)_Origin,(CHARACTERGUID)_Player)
		AND
		QRY_GLO_PartyMembers_GetInPartyDialogReset(_Origin)
		AND
		QRY_GLO_PartyMembers_GetInPartyDialog(_Origin)
		AND
		DB_GLO_PartyMembers_InPartyDialog(_Origin,_NewDialog)
		AND
		DB_GLO_PartyMembers_DefaultFaction(_Origin,_PlayerFaction)
		THEN
		CharacterRecruitCharacter(_Origin,_Player);
		ProcCharacterDisableAllCrimes(_Origin);
		ProcAssignCharacterToPlayer(_Origin,_Player);
		ProcRegisterPlayerTriggers(_Origin);
		PROC_GLO_PartyMembers_SetInpartyDialog(_Origin,_NewDialog);
		SetFaction(_Origin,_PlayerFaction);
		DB_IsPlayer(_Origin);
		NOT DB_GLO_PartyMembers_DefaultFaction(_Origin,_PlayerFaction);
		CharacterAttachToGroup(_Origin,_Player);
		Proc_CheckPartyFull();
		Proc_CheckFirstTimeRecruited(_Origin);
		PROC_GLO_PartyMembers_RecruiteeAvatarBond_IfDifferent(_Origin,_Player);
		Proc_BondedAvatarTutorial(_Player);
		CharacterSetCorpseLootable(_Origin, 0);
		PROC_GLO_PartyMembers_AddHook(_Origin,_Player);
		
		PROC
		PROC_GLO_PartyMembers_AddHook((CHARACTERGUID)_Origin,(CHARACTERGUID)_Player)
		THEN
		DB_NOOP(1);
		
		// _Companion can equal _Player in case of ProcAddDebugCharToParty
		PROC
		PROC_GLO_PartyMembers_RecruiteeAvatarBond_IfDifferent((CHARACTERGUID)_Companion,(CHARACTERGUID)_Avatar)
		AND
		_Companion != _Avatar
		THEN
		PROC_GLO_PartyMembers_RecruiteeAvatarBond((CHARACTERGUID)_Companion,(CHARACTERGUID)_Avatar);
		
		PROC
		PROC_GLO_PartyMembers_RecruiteeAvatarBond((CHARACTERGUID)_Companion,(CHARACTERGUID)_Avatar)
		THEN
		DB_GLO_PartyMembers_RecruiteeAvatarBond(_Companion,_Avatar);
		
		PROC
		PROC_GLO_PartyMembers_ClearRecruiteeBonds((CHARACTERGUID)_Companion)
		AND
		DB_GLO_PartyMembers_RecruiteeAvatarBond(_Companion,_Avatar)
		THEN
		NOT DB_GLO_PartyMembers_RecruiteeAvatarBond(_Companion,_Avatar);
		
		
		
		//END_REGION
		
		//REGION Dismiss a party member
		PROC
		PROC_GLO_PartyMembers_Remove((CHARACTERGUID)_Origin,1)
		THEN
		PROC_GLO_PartyMembers_Remove(_Origin,(CHARACTERGUID)NULL_00000000-0000-0000-0000-000000000000,1);
		
		PROC
		PROC_GLO_PartyMembers_Remove((CHARACTERGUID)_Origin,0)
		THEN
		DebugBreak("this should not be called for unforced removals of origins!");
		
		
		PROC
		PROC_GLO_PartyMembers_Remove((CHARACTERGUID)_Origin,(CHARACTERGUID)_Dismisser,(INTEGER)_Force)
		THEN
		PROC_GLO_PartyMembers_Remove(_Origin,_Dismisser,_Force,1);
		
		PROC
		PROC_GLO_PartyMembers_Remove((CHARACTERGUID)_Origin,(CHARACTERGUID)_Dismisser,(INTEGER)_Force,(INTEGER)_TransferItems)
		AND
		CharacterGetHostCharacter(_HostChar)
		AND
		CharacterGetReservedUserID(_HostChar,_HostUser)
		AND
		CharacterGetReservedUserID(_Origin,_OriginUser)
		THEN
		PROC_GLO_PartyMembers_RemoveIfUserHasOtherCharacter(_Origin,_Dismisser,_HostUser,_OriginUser,_Force,_TransferItems);
		Proc_CheckPartyFull();
		
		PROC
		PROC_GLO_PartyMembers_RemoveIfUserHasOtherCharacter((CHARACTERGUID)_Origin,(CHARACTERGUID)_Dismisser,(INTEGER)_HostUser,(INTEGER)_OriginUser,(INTEGER)_ForceRemove,(INTEGER)_TransferItems)
		AND
		_OriginUser == _HostUser
		THEN
		DB_GLO_PartyMember_OriginUserHasOtherCharacter(1);
		
		PROC
		PROC_GLO_PartyMembers_RemoveIfUserHasOtherCharacter((CHARACTERGUID)_Origin,(CHARACTERGUID)_Dismisser,(INTEGER)_HostUser,(INTEGER)_OriginUser,(INTEGER)_ForceRemove,(INTEGER)_TransferItems)
		AND
		_OriginUser != _HostUser
		AND
		DB_IsPlayer(_Player)
		AND
		_Player!=_Origin
		AND
		CharacterGetReservedUserID(_Player,_PlayerUser)
		AND
		_PlayerUser == _OriginUser
		THEN
		DB_GLO_PartyMember_OriginUserHasOtherCharacter(1);
		
		PROC
		PROC_GLO_PartyMembers_RemoveIfUserHasOtherCharacter((CHARACTERGUID)_Origin,(CHARACTERGUID)_Dismisser,(INTEGER)_HostUser,(INTEGER)_OriginUser,1,(INTEGER)_TransferItems)
		THEN
		DB_GLO_PartyMember_OriginUserHasOtherCharacter(1);
		
		PROC
		PROC_GLO_PartyMembers_RemoveIfUserHasOtherCharacter((CHARACTERGUID)_Origin,(CHARACTERGUID)_Dismisser,(INTEGER)_HostUser,(INTEGER)_OriginUser,(INTEGER)_ForceRemove,1)
		AND
		DB_GLO_PartyMember_OriginUserHasOtherCharacter(1)
		THEN
		PROC_GLO_PartyMembers_TransferStoryItems(_Origin,_Dismisser);
		
		PROC
		PROC_GLO_PartyMembers_RemoveIfUserHasOtherCharacter((CHARACTERGUID)_Origin,(CHARACTERGUID)_Dismisser,(INTEGER)_HostUser,(INTEGER)_OriginUser,(INTEGER)_ForceRemove,(INTEGER)_TransferItems)
		AND
		DB_GLO_PartyMember_OriginUserHasOtherCharacter(1)
		THEN
		CharacterDetachFromGroup(_Origin);
		CharacterRemoveFromParty(_Origin);
		PROC_GLO_PartyMembers_MakeNPC(_Origin);
		CharacterSetCorpseLootable(_Origin, 1);
		
		PROC
		PROC_GLO_PartyMembers_TransferStoryItems((CHARACTERGUID)_Origin,(CHARACTERGUID)_Dismisser)
		AND
		NOT DB_BlockStoryItemTransfer(_Origin)
		AND
		_Dismisser != NULL_00000000-0000-0000-0000-000000000000
		AND
		CharacterGetReservedUserID(_Dismisser,_User)
		AND
		CharacterGetReservedUserID(_Origin,_User)
		AND
		CharacterGetGold(_Origin,_Gold)
		AND
		IntegerProduct(_Gold,-1,_MinusGold)
		THEN
		TransferItemsToCharacter(_Origin,_Dismisser);
		CharacterAddGold(_Origin,_MinusGold);
		CharacterAddGold(_Dismisser,_Gold);
		DB_StoryItemsTransfered(1);
		
		PROC
		PROC_GLO_PartyMembers_TransferStoryItems(_Origin,_)
		AND
		NOT DB_BlockStoryItemTransfer(_Origin)
		AND
		NOT DB_StoryItemsTransfered(1)
		THEN
		TransferItemsToUser(_Origin);
		
		PROC
		PROC_GLO_PartyMembers_TransferStoryItems(_,_)
		THEN
		NOT DB_StoryItemsTransfered(1);
		
		PROC
		PROC_GLO_PartyMembers_RemoveIfUserHasOtherCharacter((CHARACTERGUID)_Origin,(CHARACTERGUID)_Dismisser,(INTEGER)_HostUser,(INTEGER)_OriginUser,1,(INTEGER)_TransferItems)
		THEN
		CharacterFlushQueue(_Origin);
		
		PROC
		PROC_GLO_PartyMembers_RemoveIfUserHasOtherCharacter((CHARACTERGUID)_Origin,(CHARACTERGUID)_Dismisser,(INTEGER)_HostUser,(INTEGER)_OriginUser,(INTEGER)_ForceRemove,(INTEGER)_TransferItems)
		THEN
		NOT DB_GLO_PartyMember_OriginUserHasOtherCharacter(1);
		//END_REGION
		
		//REGION User has other characters besides the current one
		QRY
		QRY_GLO_PartyMembers_UserHasOtherCharacters((CHARACTERGUID)_Player)
		AND
		CharacterGetReservedUserID(_Player,_ID)
		AND
		DB_IsPlayer(_OtherPlayer)
		AND
		_Player != _OtherPlayer
		AND
		CharacterGetReservedUserID(_OtherPlayer,_ID)
		THEN
		DB_NOOP(1);
		//END_REGION
		
		//REGION Dismiss all companions, except if the user has no avatar(s) -> dismiss non-controlled companions
		// Remove remnants from previous call
		PROC
		PROC_GLO_PartyMembers_CollectDismissAll()
		AND
		DB_GLO_PartyMembers_CollectDismissAll_Keep(_Player)
		THEN
		NOT DB_GLO_PartyMembers_CollectDismissAll_Keep(_Player);
		
		PROC
		PROC_GLO_PartyMembers_CollectDismissAll()
		AND
		DB_GLO_PartyMembers_CollectDismissAll_RecruiteeAvatarBond(_Companion,_Player)
		THEN
		NOT DB_GLO_PartyMembers_CollectDismissAll_RecruiteeAvatarBond(_Companion,_Player);
		
		PROC
		PROC_GLO_PartyMembers_CollectDismissAll()
		AND
		DB_GLO_PartyMembers_CollectDismissAll_OriginalOwningUserChar(_OwnerChar,_Companion)
		THEN
		NOT DB_GLO_PartyMembers_CollectDismissAll_OriginalOwningUserChar(_OwnerChar,_Companion);
		
		
		// Defines DB_GLO_PartyMembers_CollectDismissAll_Keep(_Player) for all players that should not be dismissed
		PROC
		PROC_GLO_PartyMembers_CollectDismissAll()
		AND
		DB_IsPlayer(_Player)
		AND
		CharacterGetReservedUserID(_Player,_UserID)
		AND
		IsTagged(_Player,"AVATAR",_IsAvatar)
		AND
		CharacterIsControlled(_Player,_IsControlled)
		THEN
		DB_GLO_PartyMembers_CollectDismissAll_MaybeKeep(_UserID,_Player,_IsAvatar,_IsControlled);
		
		// Prefer avatars over non-avatars
		PROC
		PROC_GLO_PartyMembers_CollectDismissAll()
		AND
		DB_GLO_PartyMembers_CollectDismissAll_MaybeKeep(_UserID,_AvatarPlayer,1,_)
		AND
		DB_GLO_PartyMembers_CollectDismissAll_MaybeKeep(_UserID,_NonAvatarPlayer,0,_IsControlled)
		THEN
		NOT DB_GLO_PartyMembers_CollectDismissAll_MaybeKeep(_UserID,_NonAvatarPlayer,0,_IsControlled);
		
		// Prefer controlled companions over non-controlled companions
		PROC
		PROC_GLO_PartyMembers_CollectDismissAll()
		AND
		DB_GLO_PartyMembers_CollectDismissAll_MaybeKeep(_UserID,_ControlledCompanion,0,1)
		AND
		DB_GLO_PartyMembers_CollectDismissAll_MaybeKeep(_UserID,_UnControlledCompanion,0,0)
		THEN
		NOT DB_GLO_PartyMembers_CollectDismissAll_MaybeKeep(_UserID,_UnControlledCompanion,0,0);
		
		PROC
		PROC_GLO_PartyMembers_CollectDismissAll()
		AND
		DB_GLO_PartyMembers_CollectDismissAll_MaybeKeep(_UserID,_Player,_IsAvatar,_IsControlled)
		THEN
		NOT DB_GLO_PartyMembers_CollectDismissAll_MaybeKeep(_UserID,_Player,_IsAvatar,_IsControlled);
		DB_GLO_PartyMembers_CollectDismissAll_Keep(_Player);
		
		// Record avatar/companion bonds, so we can restore them after re-adding them to the party
		PROC
		PROC_GLO_PartyMembers_CollectDismissAll()
		AND
		DB_IsPlayer(_Companion)
		AND
		NOT DB_GLO_PartyMembers_CollectDismissAll_Keep(_Companion)
		AND
		DB_GLO_PartyMembers_RecruiteeAvatarBond(_Companion,_Avatar)
		THEN
		DB_GLO_PartyMembers_CollectDismissAll_RecruiteeAvatarBond(_Companion,_Avatar);
		
		// Record which user controlled which dismissed characters, so we can assign them back to the correct user afterwards
		// (you can switch characters between users, so recruiter/recruitee bonds are not sufficient)
		PROC
		PROC_GLO_PartyMembers_CollectDismissAll()
		AND
		DB_GLO_PartyMembers_CollectDismissAll_Keep(_KeepChar)
		AND
		CharacterGetReservedUserID(_KeepChar,_UserID)
		AND
		DB_IsPlayer(_Companion)
		AND
		NOT DB_GLO_PartyMembers_CollectDismissAll_Keep(_Companion)
		AND
		CharacterGetReservedUserID(_Companion,_UserID)
		THEN
		DB_GLO_PartyMembers_CollectDismissAll_OriginalOwningUserChar(_KeepChar,_Companion);
		
		//REGION Fix up companion/avatar bonds after rejoining
		// Restore bonds for a rejoined companion
		PROC
		PROC_GLO_PartyMembers_CollectDismissAll_RestoreCompanionBond((CHARACTERGUID)_Companion)
		AND
		DB_GLO_PartyMembers_CollectDismissAll_RecruiteeAvatarBond(_Companion,_Player)
		AND
		DB_IsPlayer(_Companion)
		THEN
		PROC_GLO_PartyMembers_ClearRecruiteeBonds(_Companion);
		PROC_GLO_PartyMembers_RecruiteeAvatarBond(_Companion,_Player);
		
		PROC
		PROC_GLO_PartyMembers_CollectDismissAll_RestoreCompanionBond((CHARACTERGUID)_Companion)
		AND
		DB_GLO_PartyMembers_CollectDismissAll_RecruiteeAvatarBond(_Companion,_Player)
		THEN
		NOT
		DB_GLO_PartyMembers_CollectDismissAll_RecruiteeAvatarBond(_Companion,_Player);
		
		PROC
		PROC_GLO_PartyMembers_CollectDismissAll_FixRejoinedRecruiteeAvatarBonds()
		AND
		DB_GLO_PartyMembers_CollectDismissAll_RecruiteeAvatarBond(_Companion,_)
		THEN
		PROC_GLO_PartyMembers_CollectDismissAll_RestoreCompanionBond(_Companion);
		
		
		//END_REGION
		
		//END_REGION
		
		//REGION Character gets kicked from their own party (end-game situation)
		// 0) Block any alignment changes by ProcFixPlayerAlignments() towards this character
		//    and make immortal (needed for party restoration at the end)
		PROC
		PROC_GLO_PartyMembers_Kick((CHARACTERGUID)_Avatar,(STRING)_FallbackFactionForAI)
		THEN
		DB_PlayerAlignments_BlockFix(_Avatar);
		CharacterSetImmortal(_Avatar,1);
		
		// 1) Record current party layout
		PROC
		PROC_GLO_PartyMembers_Kick((CHARACTERGUID)_Avatar,(STRING)_FallbackFactionForAI)
		AND
		DB_IsPlayer(_PartyMember)
		AND
		_PartyMember != _Avatar
		AND
		CharacterIsInPartyWith(_PartyMember,_Avatar,1)
		AND
		CharacterGetReservedUserID(_Avatar,_AvatarUserID)
		AND
		CharacterGetReservedUserID(_PartyMember,_PartyMemberUserID)
		THEN
		PROC_GLO_PartyMembers_Kick_DefinePartyMemberDB(_Avatar,_AvatarUserID,_PartyMember,_PartyMemberUserID);
		
		PROC
		PROC_GLO_PartyMembers_Kick_DefinePartyMemberDB((CHARACTERGUID)_Avatar,(INTEGER)_AvatarUserID,(CHARACTERGUID)_PartyMember,(INTEGER)_PartyMemberUserID)
		AND
		_AvatarUserID == _PartyMemberUserID
		THEN
		DB_GLO_PartyMembers_Kick_PartyMembers(_Avatar,_PartyMember,1);
		
		PROC
		PROC_GLO_PartyMembers_Kick_DefinePartyMemberDB((CHARACTERGUID)_Avatar,(INTEGER)_AvatarUserID,(CHARACTERGUID)_PartyMember,(INTEGER)_PartyMemberUserID)
		AND
		_AvatarUserID != _PartyMemberUserID
		THEN
		DB_GLO_PartyMembers_Kick_PartyMembers(_Avatar,_PartyMember,0);
		
		// 2) Move characters controlled by other players to a new party
		PROC
		PROC_GLO_PartyMembers_Kick((CHARACTERGUID)_Avatar,(STRING)_FallbackFactionForAI)
		AND
		DB_GLO_PartyMembers_Kick_PartyMembers(_Avatar,_PartyMember,0)
		AND
		CharacterGetReservedUserID(_PartyMember,_PartyMemberUserID)
		THEN
		PROC_GLO_PartyMembers_Kick_RemovePlayerMember(_Avatar,_PartyMember,_PartyMemberUserID);
		
		//REGION Remove a player party member and add to newlly created party
		PROC
		PROC_GLO_PartyMembers_Kick_RemovePlayerMember((CHARACTERGUID)_Avatar,(CHARACTERGUID)_Player,(INTEGER)_PartyMemberUserID)
		AND
		NOT DB_GLO_PartyMembers_Kick_PartyMembers_UserLeft(_PartyMemberUserID)
		THEN
		DB_GLO_PartyMembers_Kick_PartyMembers_UserLeft(_PartyMemberUserID);
		LeaveParty(_PartyMemberUserID);
		
		PROC
		PROC_GLO_PartyMembers_Kick_RemovePlayerMember((CHARACTERGUID)_Avatar,(CHARACTERGUID)_Player,(INTEGER)_PartyMemberUserID)
		THEN
		CharacterDetachFromGroup(_Player);
		
		PROC
		PROC_GLO_PartyMembers_Kick_RemovePlayerMember((CHARACTERGUID)_Avatar,(CHARACTERGUID)_Player,(INTEGER)_PartyMemberUserID)
		AND
		DB_GLO_PartyMembers_Kick_NewParty(_Avatar,_Party)
		THEN
		CharacterAddToParty(_Player,_Party);
		
		PROC
		PROC_GLO_PartyMembers_Kick_RemovePlayerMember((CHARACTERGUID)_Avatar,(CHARACTERGUID)_Player,(INTEGER)_PartyMemberUserID)
		AND
		NOT DB_GLO_PartyMembers_Kick_NewParty(_Avatar,_)
		THEN
		DB_GLO_PartyMembers_Kick_NewParty(_Avatar,_Player);
		
		PROC
		PROC_GLO_PartyMembers_Kick((CHARACTERGUID)_Avatar,(STRING)_FallbackFactionForAI)
		AND
		DB_GLO_PartyMembers_Kick_PartyMembers_UserLeft(_PartyMemberUserID)
		THEN
		NOT DB_GLO_PartyMembers_Kick_PartyMembers_UserLeft(_PartyMemberUserID);
		
		//END_REGION
		
		// 3) Make other party characters controlled by same player AI-controlled
		PROC
		PROC_GLO_PartyMembers_Kick((CHARACTERGUID)_Avatar,(STRING)_FallbackFactionForAI)
		AND
		DB_GLO_PartyMembers_Kick_PartyMembers(_Avatar,_PartyMember,1)
		THEN
		PROC_GLO_PartyMembers_Kick_RemoveAIMember(_Avatar,_PartyMember,_FallbackFactionForAI);
		
		// In case the player controlled multiple avatars, this may not be set
		PROC
		PROC_GLO_PartyMembers_Kick_RemoveAIMember((CHARACTERGUID)_Avatar,(CHARACTERGUID)_Player,(STRING)_FallbackFactionForAI)
		AND
		NOT DB_GLO_PartyMembers_OriginalAlignment(_Player,_)
		THEN
		DB_GLO_PartyMembers_OriginalAlignment(_Player,_FallbackFactionForAI);
		
		//REGION Non-avatar: record avatar bond to restore later (could be bonded to different avatar than this one)
		PROC
		PROC_GLO_PartyMembers_Kick_RemoveAIMember((CHARACTERGUID)_Avatar,(CHARACTERGUID)_Player,(STRING)_FallbackFactionForAI)
		AND
		DB_GLO_PartyMembers_RecruiteeAvatarBond(_Player,_AnyAvatar)
		THEN
		DB_GLO_PartyMembers_Kick_OldCompanionBond(_Avatar,_Player,_AnyAvatar);
		
		PROC
		PROC_GLO_PartyMembers_Kick_RemoveAIMember((CHARACTERGUID)_Avatar,(CHARACTERGUID)_Player,(STRING)_FallbackFactionForAI)
		AND
		NOT DB_GLO_PartyMembers_BlockReturnToRecruitmentPosition(_Player)
		THEN
		DB_GLO_PartyMembers_Kick_BlockedReturnToRecruitmentPosition(_Avatar,_Player);
		DB_GLO_PartyMembers_BlockReturnToRecruitmentPosition(_Player);
		//END_REGION
		
		PROC
		PROC_GLO_PartyMembers_Kick_RemoveAIMember((CHARACTERGUID)_Avatar,(CHARACTERGUID)_Player,(STRING)_FallbackFactionForAI)
		AND
		GetVarFixedString(_Player,"currentState",_State)
		THEN
		DB_GLO_PartyMembers_Kick_OrigState(_Avatar,_Player,_State);
		SetVarFixedString(_Player,"currentState","");
		
		PROC
		PROC_GLO_PartyMembers_Kick_RemoveAIMember((CHARACTERGUID)_Avatar,(CHARACTERGUID)_Player,(STRING)_FallbackFactionForAI)
		THEN
		PROC_GLO_PartyMembers_MakeNPC(_Player);
		
		// Make the dismissed AI-controlled characters allied with the rest of the players
		PROC
		PROC_GLO_PartyMembers_MakeNPCHook((CHARACTERGUID)_PartyMember)
		AND
		DB_GLO_PartyMembers_Kick_PartyMembers(_Avatar,_PartyMember,1)
		THEN
		DB_GLO_PartyMemebers_KickAvatar_RestoreHeroFactionRelationAfterDeath(_PartyMember);
		CharacterSetRelationIndivFactionToFaction(_PartyMember,"Hero",100);
		CharacterSetRelationFactionToIndivFaction("Hero",_PartyMember,100);
		
		// 4) Make the Hero alignment hostile against the alignment of the kicked hero and vice versa
		PROC
		PROC_GLO_PartyMembers_Kick((CHARACTERGUID)_Avatar,(STRING)_FallbackFactionForAI)
		THEN
		DB_GLO_PartyMembers_Kicked(_Avatar);
		SetTag(_Avatar,"BLOCK_RESURRECTION");
		CharacterSetRelationIndivFactionToFaction(_Avatar,"Hero",-100);
		CharacterSetRelationFactionToIndivFaction("Hero",_Avatar,-100);
		
		// Also all other players individually, because their individual relations may have been overridden earlier and then changing Hero won't do anything anymore
		PROC
		PROC_GLO_PartyMembers_Kick((CHARACTERGUID)_Avatar,(STRING)_FallbackFactionForAI)
		AND
		DB_IsPlayer(_Player)
		AND
		_Player != _Avatar
		THEN
		CharacterSetRelationIndivFactionToIndivFaction(_Player,_Avatar,-100);
		CharacterSetRelationIndivFactionToIndivFaction(_Avatar,_Player,-100);
		
		// and make the kicked hero also hostile against the removed companions and vice versa
		PROC
		PROC_GLO_PartyMembers_Kick((CHARACTERGUID)_Avatar,(STRING)_FallbackFactionForAI)
		AND
		DB_GLO_PartyMembers_Kick_PartyMembers(_Avatar,_PartyMember,1)
		THEN
		CharacterSetRelationIndivFactionToIndivFaction(_Avatar,_PartyMember,-100);
		CharacterSetRelationIndivFactionToIndivFaction(_PartyMember,_Avatar,-100);
		
		// and report that we are ready
		PROC
		PROC_GLO_PartyMembers_Kick((CHARACTERGUID)_Avatar,(STRING)_FallbackFactionForAI)
		THEN
		SetStoryEvent(_Avatar,"GLO_PartyMembers_Kicked");
		
		// 5) If that avatar dies, give its user control over the kicked AI party members (if any)
		IF
		CharacterReceivedDamage(_Avatar, _, _)
		AND
		DB_GLO_PartyMembers_Kicked(_Avatar)
		AND
		CharacterGetHitpointsPercentage(_Avatar,_Percentage)
		AND
		_Percentage <= 0.0
		AND
		NOT DB_GLO_PartyMembers_Kick_PartyMembers_Dying(_Avatar)
		THEN
		PROC_GLO_PartyMembers_Kick_PartyMembers_TryDead(_Avatar);
		
		PROC
		PROC_GLO_PartyMembers_Kick_PartyMembers_TryDead((CHARACTERGUID)_Avatar)
		AND
		NOT QRY_GLO_PartyMembers_Kicked_BlockRestoreAvatarOnDeath(_Avatar)
		THEN
		PROC_GLO_PartyMembers_Kick_PartyMembers_Dead(_Avatar);
		DB_GLO_PartyMembers_Kick_PartyMembers_Dying(_Avatar);
		
		QRY
		QRY_GLO_PartyMembers_Kicked_BlockRestoreAvatarOnDeath((CHARACTERGUID)_Avatar)
		AND
		1 == 0
		THEN
		DB_NOOP(1);
		
		// First restore the NPC alignment relations
		PROC
		PROC_GLO_PartyMembers_Kick_PartyMembers_Dead((CHARACTERGUID)_Avatar)
		THEN
		PROC_GLO_PartyMembers_Kick_PartyMembers_Restore_Internal((CHARACTERGUID)_Avatar);
		
		PROC
		PROC_GLO_PartyMembers_Kick_PartyMembers_Restore((CHARACTERGUID)_Avatar)
		THEN
		PROC_GLO_PartyMembers_Kick_PartyMembers_Restore_Internal((CHARACTERGUID)_Avatar);
		
		PROC
		PROC_GLO_PartyMembers_Kick_PartyMembers_Restore_Internal((CHARACTERGUID)_Avatar)
		AND
		DB_GLO_PartyMembers_Kick_PartyMembers(_Avatar,_,_)
		AND
		DB_GLO_PartyMemebers_KickAvatar_RestoreHeroFactionRelationAfterDeath(_PartyMember)
		THEN
		NOT DB_GLO_PartyMemebers_KickAvatar_RestoreHeroFactionRelationAfterDeath(_PartyMember);
		CharacterSetRelationIndivFactionToFaction(_PartyMember,"Hero",50);
		CharacterSetRelationFactionToIndivFaction("Hero",_PartyMember,50);
		
		//REGION Add NPC party members again
		PROC
		PROC_GLO_PartyMembers_Kick_PartyMembers_Restore_Internal((CHARACTERGUID)_Avatar)
		AND
		DB_GLO_PartyMembers_Kick_PartyMembers(_Avatar,_PartyMember,1)
		THEN
		PROC_GLO_PartyMembers_Add(_PartyMember,_Avatar);
		
		// Restore original avatar bond: clear for avatars, clear then restore for companions
		PROC
		PROC_GLO_PartyMembers_Kick_PartyMembers_Restore_Internal((CHARACTERGUID)_Avatar)
		AND
		DB_GLO_PartyMembers_Kick_PartyMembers(_Avatar,_PartyMember,1)
		THEN
		PROC_GLO_PartyMembers_ClearRecruiteeBonds(_PartyMember);
		
		PROC
		PROC_GLO_PartyMembers_Kick_PartyMembers_Restore_Internal((CHARACTERGUID)_Avatar)
		AND
		DB_GLO_PartyMembers_Kick_OldCompanionBond(_Avatar,_PartyMember,_AnyAvatar)
		THEN
		NOT DB_GLO_PartyMembers_Kick_OldCompanionBond(_Avatar,_PartyMember,_AnyAvatar);
		PROC_GLO_PartyMembers_RecruiteeAvatarBond(_PartyMember,_AnyAvatar);
		//END_REGION
		
		// And die permanently
		PROC
		PROC_GLO_PartyMembers_Kick_PartyMembers_Dead(_Avatar)
		THEN
		CharacterSetImmortal(_Avatar,0);
		CharacterDie(_Avatar,1,"DoT");
		
		// Then remove the avatar from the party (if there were any non-controlled party members;
		// otherwise doing this will kick the player from the game).
		
		// Don't make an NPC and then die, because generics can kick in (regarding doing damage
		// to a neutral NPC in combat) in case of surfaces etc.
		IF
		DB_Dead(_Avatar)
		AND
		DB_GLO_PartyMembers_Kicked(_Avatar)
		THEN
		PROC_GLO_PartyMembers_TryDropBackpackOnDeath((CHARACTERGUID)_Avatar);
		
		PROC
		PROC_GLO_PartyMembers_TryDropBackpackOnDeath((CHARACTERGUID)_Avatar)
		AND
		NOT QRY_GLO_PartyMembers_BlockBackpackOnDeath(_Avatar)
		AND
		GetPosition(_Avatar,_X,_Y,_Z)
		AND
		CreateItemTemplateAtPosition("CONT_Humans_Backpack_Merchant_A_360e3e11-c7f8-4281-848a-596e37df884b",_X,_Y,_Z,_BackPack)
		THEN 
		// Since IsLootable is disabled for the _Avatar, drop his items in a backpack instead
		MoveAllItemsTo(_Avatar,_BackPack);
		SetStoryEvent(_Avatar,"GLO_PartyMembers_KickedDied");
		
		PROC
		PROC_GLO_PartyMembers_TryDropBackpackOnDeath((CHARACTERGUID)_Avatar)
		AND
		QRY_GLO_PartyMembers_UserHasOtherCharacters(_Avatar)
		THEN
		NOT DB_IsPlayer(_Avatar);
		
		
		QRY
		QRY_GLO_PartyMembers_BlockBackpackOnDeath((CHARACTERGUID)_Avatar)
		AND
		1 == 0
		THEN
		DB_NOOP(0);
		
		// Don't make NPC if last character for this user, because then will be kicked from the game
		IF
		DB_Dead(_Avatar)
		AND
		DB_GLO_PartyMembers_Kicked(_Avatar)
		AND
		QRY_GLO_PartyMembers_UserHasOtherCharacters(_Avatar)
		THEN
		CharacterMakeNPC(_Avatar);
		
		// Clean up
		IF
		DB_Dead(_Avatar)
		AND
		DB_GLO_PartyMembers_Kick_PartyMembers_Dying(_Avatar)
		THEN
		NOT DB_GLO_PartyMembers_Kick_PartyMembers_Dying(_Avatar);
		PROC_GLO_PartyMembers_Kick_CleanUp(_Avatar);
		
		PROC
		PROC_GLO_PartyMembers_Kick_PartyMembers_Restore((CHARACTERGUID)_Avatar)
		THEN
		PROC_GLO_PartyMembers_Kick_CleanUp(_Avatar);
		
		// Remove everything so that this avatar dying will no longer result in returning
		// control to the companions
		PROC
		PROC_GLO_PartyMembers_Kick_CleanUp((CHARACTERGUID)_Avatar)
		THEN
		CharacterSetImmortal(_Avatar,0);
		
		PROC
		PROC_GLO_PartyMembers_Kick_CleanUp((CHARACTERGUID)_Avatar)
		AND
		DB_GLO_PartyMembers_Kick_NewParty(_Avatar,_Party)
		THEN
		NOT DB_GLO_PartyMembers_Kick_NewParty(_Avatar,_Party);
		
		PROC
		PROC_GLO_PartyMembers_Kick_CleanUp((CHARACTERGUID)_Avatar)
		AND
		DB_GLO_PartyMembers_Kick_OrigState(_Avatar,_Player,_State)
		THEN
		NOT DB_GLO_PartyMembers_Kick_OrigState(_Avatar,_Player,_State);
		SetVarFixedString(_Player,"currentState",_State);
		
		PROC
		PROC_GLO_PartyMembers_Kick_CleanUp((CHARACTERGUID)_Avatar)
		AND
		DB_GLO_PartyMembers_Kick_BlockedReturnToRecruitmentPosition(_Avatar,_Player)
		THEN
		NOT DB_GLO_PartyMembers_Kick_BlockedReturnToRecruitmentPosition(_Avatar,_Player);
		NOT DB_GLO_PartyMembers_BlockReturnToRecruitmentPosition(_Player);
		
		PROC
		PROC_GLO_PartyMembers_Kick_CleanUp((CHARACTERGUID)_Avatar)
		THEN
		NOT DB_PlayerAlignments_BlockFix(_Avatar);
		
		PROC
		PROC_GLO_PartyMembers_Kick_CleanUp((CHARACTERGUID)_Avatar)
		AND
		DB_GLO_PartyMembers_Kick_PartyMembers(_Avatar,_PartyMember,_AvatarUserOwned)
		THEN
		NOT DB_GLO_PartyMembers_Kick_PartyMembers(_Avatar,_PartyMember,_AvatarUserOwned);
		
		PROC
		PROC_GLO_PartyMembers_Kick_CleanUp((CHARACTERGUID)_Avatar)
		THEN
		NOT DB_GLO_PartyMembers_Kicked(_Avatar);
		//END_REGION
		
		//REGION Temporary removal of non-avatar characters controlled by this user, except if they only control companions (-> keep currently controlled companion)
		PROC
		PROC_GLO_PartyMembers_TempRemoveAll((INTEGER)_SetOffStage)
		THEN
		PROC_GLO_PartyMembers_CollectDismissAll();
		
		// DB_GLO_PartyMembers_CollectDismissAll_Keep() keeps track which characters were kept (call PROC_GLO_PartyMembers_TempRestore() on these afterwards to get their companions back)
		// DB_GLO_PartyMembers_CollectDismissAll_OriginalOwningUserChar() keeps track (via a character) of the user to which the removed characters were assigned
		// DB_GLO_PartyMembers_TempRemoved() keeps track of the origin recruitee/recruiter bond, for use by callers afterwards (mainly backward compatibility)
		PROC
		PROC_GLO_PartyMembers_TempRemoveAll((INTEGER)_SetOffStage)
		AND
		DB_GLO_PartyMembers_CollectDismissAll_Keep(_KeepCharacter)
		AND
		DB_GLO_PartyMembers_RecruiteeAvatarBond(_Companion,_KeepCharacter)
		AND
		NOT DB_GLO_PartyMembers_CollectDismissAll_Keep(_Companion)
		THEN
		DB_GLO_PartyMembers_TempRemoved(_KeepCharacter,_Companion);
		
		PROC
		PROC_GLO_PartyMembers_TempRemoveAll((INTEGER)_SetOffStage)
		AND
		DB_IsPlayer(_Companion)
		AND
		NOT DB_GLO_PartyMembers_CollectDismissAll_Keep(_Companion)
		THEN
		DB_BlockStoryItemTransfer(_Companion);
		PROC_GLO_PartyMembers_Remove(_Companion,1);
		
		PROC
		PROC_GLO_PartyMembers_TempRemoveAll(1)
		AND
		DB_GLO_PartyMembers_TempRemoved(_KeepCharacter,_Companion)
		THEN
		SetOnStage(_Companion,0);
		
		PROC
		PROC_GLO_PartyMembers_TempRestore((CHARACTERGUID)_)
		THEN
		//because I don't want to disturb the flow too much, doing a check here on a new DB instead of the temp dismissed one
		DB_BlockOwnershipChecks(1);
		
		PROC
		PROC_GLO_PartyMembers_TempRestore((CHARACTERGUID)_KeepCharacter)
		AND
		DB_GLO_PartyMembers_CollectDismissAll_OriginalOwningUserChar(_KeepCharacter,_Companion)
		AND
		DB_GLO_PartyMembers_TempRemoved(_Avatar,_Companion)
		THEN
		NOT DB_BlockStoryItemTransfer(_Companion);
		SetOnStage(_Companion,1);
		NOT DB_GLO_PartyMembers_TempRemoved(_Avatar,_Companion);
		PROC_GLO_PartyMembers_Add(_Companion,_KeepCharacter);
		TeleportTo(_Companion,_KeepCharacter);
		CharacterAttachToGroup(_Companion,_KeepCharacter);
		CharacterResurrect(_Companion);
		PROC_GLO_PartyMembers_CollectDismissAll_RestoreCompanionBond(_Companion);
		
		PROC
		PROC_GLO_PartyMembers_TempRestore((CHARACTERGUID)_)
		THEN
		//because I don't want to disturb the flow too much, doing a check here on a new DB instead of the temp dismissed one
		NOT DB_BlockOwnershipChecks(1);
		Proc_ItemEventCheck();
		
		PROC
		PROC_GLO_PartyMembers_TempRestoreAll()
		AND
		DB_GLO_PartyMembers_CollectDismissAll_Keep(_KeepCharacter)
		THEN
		PROC_GLO_PartyMembers_TempRestore(_KeepCharacter);
		
		// If a removed character dies, don't restore it again afterwards
		// (it died as an NPC)
		IF
		CharacterDied(_Companion)
		AND
		DB_GLO_PartyMembers_TempRemoved(_Avatar,_Companion)
		THEN
		NOT DB_GLO_PartyMembers_TempRemoved(_Avatar,_Companion);
		//END_REGION
		
		//REGION Party member dialogs (in-party)
		IF
		CharacterResurrected(_Origin)
		AND
		QRY_GLO_PartyMembers_GetInPartyDialogReset(_Origin)
		AND
		QRY_GLO_PartyMembers_GetInPartyDialog(_Origin)
		AND
		DB_GLO_PartyMembers_InPartyDialog(_Origin,_NewDialog)
		AND
		DB_GLO_PartyMembers_RecruiteeAvatarBond(_Origin,_)
		THEN
		PROC_GLO_PartyMembers_SetInpartyDialog(_Origin,_NewDialog);
		//END_REGION
		
		//REGION Turn a party member back into an NPC (after dismissing
		PROC
		PROC_GLO_PartyMembers_MakeNPCHook((CHARACTERGUID)_Member)
		THEN
		DB_NOOP(1);
		
		PROC
		PROC_GLO_PartyMembers_MakeNPC((CHARACTERGUID)_Member)
		AND
		GetFaction(_Member,_PlayerFaction)
		AND
		DB_GLO_PartyMembers_OriginalAlignment((CHARACTERGUID)_Member,(STRING)_NpcFaction)
		THEN
		NOT DB_IsPlayer(_Member);
		CharacterMakeNPC(_Member);
		ProcRemovePolymorphs(_Member);
		ProcCharacterEnableAllCrimes(_Member);
		ProcUnRegisterPlayerTriggers(_Member);
		ProcRemoveGenericTimer(_Member);
		DB_GLO_PartyMembers_DefaultFaction(_Member,_PlayerFaction);
		SetFaction(_Member,_NpcFaction);
		DB_NoLowAttitudeDialog(_Member);
		ProcRemoveAllDialogEntriesForSpeaker(_Member);
		SetHasDialog(_Member,0);
		Proc_CheckPartyFull();
		RemoveStatus(_Member,"FUGITIVE");
		PROC_GLO_PartyMembers_MakeNPCHook((CHARACTERGUID)_Member);
		
		PROC
		PROC_GLO_PartyMembers_MakeNPC((CHARACTERGUID)_Member)
		AND
		DB_GLO_PartyMembers_RecruiteeAvatarBond(_Member,_Avatar)
		THEN
		NOT DB_GLO_PartyMembers_RecruiteeAvatarBond(_Member,_Avatar);
		//END_REGION
		
		//REGION Transfer all items of an NPC to a player
		PROC
		PROC_GLO_PartyMembers_TransferInventoryToPlayer((CHARACTERGUID)_Companion,(CHARACTERGUID)_Player)
		AND
		GetPosition(_Player,_X,_Y,_Z)
		AND
		CreateItemTemplateAtPosition("CONT_Humans_Backpack_Merchant_A_360e3e11-c7f8-4281-848a-596e37df884b",_X,_Y,_Z,_BackPack)
		THEN
		DB_CompanionLeavingBackPack(_Companion,_Player,_BackPack);
		MoveAllItemsTo(_Companion,_BackPack);
		ItemToInventory(_BackPack,_Player);
		SetStoryNpcStatus(_Companion);
		OpenMessageBox(_Player,"GLO_CompanionLeftPermanently");
		
		//END_REGION
		
		
		//REGION companion left, origin flag
		PROC
		Proc_OriginLeft((CHARACTERGUID)_Companion,(STRING)_Reason)
		AND
		DB_Origins_OriginTag(_Companion,(STRING)_Tag)
		AND
		StringConcatenate("CompanionLeft_",_Tag,_String1)
		AND
		StringConcatenate(_String1,_Reason,_FinalString)
		THEN
		GlobalSetFlag(_FinalString);
		
		PROC
		Proc_OriginLeft((CHARACTERGUID)_Companion,(STRING)_Reason)
		AND
		DB_QuestDef_State_CompanionLeft((STRING)_Tag,(STRING)_Flag,_Reason)
		AND
		IsTagged(_Companion,_Tag,1)
		AND
		DB_Avatars(_Char)
		THEN
		ObjectSetFlag(_Char,_Flag);
		
		//END_REGION
		
		
		//REGION Detect kicked avatars that have become an NPC
		// Can't just check BLOCK_RESURRECTION, because can also be set on companions
		// Can't check DB_Avatars/AVATAR tag, because those get removed
		QRY
		QRY_GLO_PartyMembers_IsKickedAvatarNpc((CHARACTERGUID)_Char)
		AND
		NOT DB_IsPlayer(_Char)
		AND
		IsTagged(_Char, "BLOCK_RESURRECTION", 1)
		AND
		// has the origin quest
		DB_TUT_OriginQuestStarts(_Char, (STRING)_, (STRING)_OriginQuestFirstUpdate)
		AND
		DB_QuestDef_AddEvent(_OriginQuestID, _OriginQuestFirstUpdate)
		AND
		QuestAccepted(_Char, _OriginQuestID, 1)
		THEN
		DB_NOOP(1);
		//END_REGION
		
		//REGION Support
		IF
		TextEventSet("ResetIsPlayerDB")
		AND
		DB_CurrentLevel("CoS_Main_Ending")
		THEN
		DebugBreak("Do not use ResetIsPlayerDB in this level, it is unsafe. Nothing done.");
		
		QRY
		QRY_GLO_PartyMembers_AnyTempRemoved()
		AND
		DB_GLO_PartyMembers_TempRemoved(_,_)
		THEN
		DB_NOOP(1);
		
		IF
		TextEventSet("ResetIsPlayerDB")
		AND
		QRY_GLO_PartyMembers_AnyTempRemoved()
		THEN
		DebugBreak("Do not use ResetIsPlayerDB while characters have been temporarily removed from the party. Nothing done.");
		
		IF
		TextEventSet("ResetIsPlayerDB")
		AND
		NOT DB_CurrentLevel("CoS_Main_Ending")
		AND
		NOT QRY_GLO_PartyMembers_AnyTempRemoved()
		AND
		DB_IsPlayer(_Player)
		AND
		CharacterIsPlayer(_Player, 0)
		THEN
		NOT DB_IsPlayer(_Player);
		
		//END_REGION
		
	}
	EXIT
	{
		
	}
}
Goal(23).Title("_Global");
Goal(23)
{
	INIT
	{
		
	}
	KB
	{
		///////////////////////////////////////////////////////////////////////
		// Story call to forward the clock to _NewHour.
		// The clock will be advanced with max 24 hours. This happens when you call SetGameClock(_H) AND Time(_,_H,_).
		//
		// DO NOT USE THE ENGINE CALL SetTime DIRECTLY!
		//
		PROC	
		SetGameClock((INTEGER)_NewHour) 
		AND
		DB_Time(_Day,_H,_)
		AND 
		_NewHour > _H
		// day stays today
		THEN
		UpdateTime(_Day,_NewHour);
		
		PROC
		SetGameClock((INTEGER)_NewHour) 
		AND
		DB_Time(_Day,_H,_) 
		AND
		_NewHour <= _H 
		AND
		// day forwards +1
		IntegerSum(_Day,1,_DayP1)
		THEN	
		UpdateTime(_DayP1,_NewHour);
		
		PROC
		ProcDisableFollow((CHARACTERGUID)_Char)
		THEN
		CharacterDetachFromGroup(_Char);
		//CharacterLockGroup(_Char,1);
		
		IF
		CharacterUsedItemFailed(_Player,_Item)
		AND
		_Player.DB_IsPlayer()
		THEN
		ProcShowForbiddenItemText(_Player,_Item);
		
		PROC
		ProcShowForbiddenItemText((CHARACTERGUID)_Player,(ITEMGUID)_Item)
		AND
		ItemIsLocked(_Item, 0)
		AND
		NOT DB_NoForbiddenText(_Item)
		THEN
		Proc_StartDialog(1,"GLO_AD_ForbiddenItem",_Player);
		
		PROC
		ProcShowForbiddenItemText((CHARACTERGUID)_Player,(ITEMGUID)_Item)
		AND
		ItemIsLocked(_Item, 1)
		THEN
		CharacterItemSetEvent(_Player, _Item, "GLO_UsedLockedItem");
		
		PROC
		ProcShowMarker((CHARACTERGUID)_Player,(STRING)_Marker)
		AND
		NOT DB_ActivePlayerMarker(_Player,_Marker)
		THEN
		DB_ActivePlayerMarker(_Player,_Marker);
		ShowMapMarker(_Player,_Marker,1);
		
		PROC
		ProcHideMarker((CHARACTERGUID)_Player,(STRING)_Marker)
		AND
		DB_ActivePlayerMarker(_Player,_Marker)
		THEN
		ShowMapMarker(_Player,_Marker,0);
		
		PROC
		ProcFreezePlayers()
		AND
		_Player.DB_IsPlayer()
		THEN
		CharacterFreeze(_Player);
		
		PROC
		ProcUnfreezePlayers()
		AND
		_Player.DB_IsPlayer()
		THEN
		CharacterUnfreeze(_Player);
		
		//REGION moving items default functions 
		PROC
		MoveAllItemsTo((GUIDSTRING)_Source,(GUIDSTRING)_Target)
		THEN
		MoveAllItemsTo(_Source,_Target,1,1,1);
		//END_REGION
		
	}
	EXIT
	{
		
	}
}
Goal(24).Title("_Global_Autosave");
Goal(24)
{
	INIT
	{
		
	}
	KB
	{
		IF
		DB_AutoSaveTrigger((TRIGGERGUID)_Trigger)
		AND
		NOT DB_Subregion(_Trigger,_,_) //Subregions can function as autosaves the first time they are entered
		THEN
		DB_OneShotPlayerTrigger(_Trigger);
		
		//retro-active check, if a trigger is a sub-region, it should not be oneshot
		IF
		DB_Subregion(_Trigger,_,_)
		AND
		DB_OneShotPlayerTrigger(_Trigger)
		THEN
		NOT DB_OneShotPlayerTrigger(_Trigger);
		
		PROC
		ProcOneShotTriggerEntered(_,_Trigger)
		AND
		DB_AutoSaveTrigger(_Trigger)
		AND
		DB_AutosaveGroup(_Trigger,_Group)
		AND
		DB_AutosaveGroup(_AnotherTrigger,_Group)
		AND
		_AnotherTrigger != _Trigger
		THEN
		NOT DB_AutoSaveTrigger(_AnotherTrigger);
		NOT DB_OneShotPlayerTrigger(_AnotherTrigger);
		ProcTriggerUnregisterForPlayers(_AnotherTrigger);
		
		PROC
		ProcOneShotTriggerEntered(_,_Trigger)
		AND
		DB_AutoSaveTrigger(_Trigger)
		THEN
		NOT DB_AutoSaveTrigger(_Trigger);
		AutoSave();
		
		//For use of Autosave triggers that are attached to non-oneshots such as Subregions
		IF
		CharacterEnteredTrigger((CHARACTERGUID)_Player,(TRIGGERGUID)_Trigger)
		AND
		DB_AutoSaveTrigger(_Trigger)
		AND
		NOT DB_OneShotPlayerTrigger(_Trigger)
		THEN
		NOT DB_AutoSaveTrigger(_Trigger);
		AutoSave();
		
		IF
		DB_AutosaveGroup((TRIGGERGUID)_Trigger,(STRING)_ID)
		THEN
		DB_AutoSaveTrigger(_Trigger);
		
		
		
	}
	EXIT
	{
		
	}
}
Goal(25).Title("_Global_CharacterAnimations");
Goal(25)
{
	INIT
	{
		// Standard animations
		DB_GLO_CharacterAnimation("PlayAnim_attack1","attack1",0);
		DB_GLO_CharacterAnimation("PlayAnim_attack2","attack2",0);
		DB_GLO_CharacterAnimation("PlayAnim_attack3","attack3",0);
		DB_GLO_CharacterAnimation("PlayAnim_attack_ground","attack_ground",0);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_thrown_loop","thrown_loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_thrown_land","thrown_land",0);
		DB_GLO_CharacterAnimation("PlayAnim_knockdown_fall","knockdown_fall",0);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_knockdown_loop","knockdown_loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_knockdown_getup","knockdown_getup",0);
		DB_GLO_CharacterAnimation("PlayAnim_barf","barf",0);
		DB_GLO_CharacterAnimation("PlayAnim_die_melee","die_melee",0);
		DB_GLO_CharacterAnimation("PlayAnim_die_slash","die_slash",0);
		DB_GLO_CharacterAnimation("PlayAnim_die_crush","die_crush",0);
		DB_GLO_CharacterAnimation("PlayAnim_die_pierce","die_pierce",0);
		DB_GLO_CharacterAnimation("PlayAnim_die_arrow","die_arrow",0);
		DB_GLO_CharacterAnimation("PlayAnim_die_dot","die_dot",0);
		DB_GLO_CharacterAnimation("PlayAnim_die_incinerate","die_incinerate",0);
		DB_GLO_CharacterAnimation("PlayAnim_die_acid","die_acid",0);
		DB_GLO_CharacterAnimation("PlayAnim_die_electrocution","die_electrocution",0);
		DB_GLO_CharacterAnimation("PlayAnim_die_frozenshatter","die_frozenshatter",0);
		DB_GLO_CharacterAnimation("PlayAnim_die_hang","die_hang",0);
		DB_GLO_CharacterAnimation("PlayAnim_hit","hit",0);
		DB_GLO_CharacterAnimation("PlayAnim_hit_backstab","hit_backstab",0);
		DB_GLO_CharacterAnimation("PlayAnim_hit_magic","hit_magic",0);
		DB_GLO_CharacterAnimation("PlayAnim_block","block",0);
		DB_GLO_CharacterAnimation("PlayAnim_dodge","dodge",0);
		DB_GLO_CharacterAnimation("PlayAnim_dodge_backstab","dodge_backstab",0);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_idle1","idle1",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_idle2","idle2",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_idle3","idle3",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_walk","walk",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_sneak","sneak",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_run","run",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_still","still",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_stillsneaking","stillsneaking",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_stilldiseased","stilldiseased",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_stillchilled","stillchilled",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_stillcrippled","stillcrippled",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_stillblind","stillblind",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_stilldrunk","stilldrunk",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_stillelectrified","stillelectrified",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_walk_wings","walk_wings",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_run_wings","run_wings",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_still_wings","still_wings",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_stillmental","stillmental",1);
		
		DB_GLO_CharacterAnimation("PlayAnim_Loop_cower","cower",1);
		DB_GLO_CharacterAnimation("PlayAnim_spawn","spawn",0);
		DB_GLO_CharacterAnimation("PlayAnim_polymorphed","polymorphed",0);
		DB_GLO_CharacterAnimation("PlayAnim_resurrect","resurrect",0);
		DB_GLO_CharacterAnimation("PlayAnim_use_inspect","use_inspect",0);
		DB_GLO_CharacterAnimation("PlayAnim_use_activate","use_activate",0);
		DB_GLO_CharacterAnimation("PlayAnim_use_loot","use_loot",0);
		DB_GLO_CharacterAnimation("PlayAnim_use_eat","use_eat",0);
		DB_GLO_CharacterAnimation("PlayAnim_use_drink","use_drink",0);
		DB_GLO_CharacterAnimation("PlayAnim_use_craft","use_craft",0);
		DB_GLO_CharacterAnimation("PlayAnim_use_dig","use_dig",0);
		DB_GLO_CharacterAnimation("PlayAnim_skill_stance_start","skill_stance_start",0);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_skill_stance_loop","skill_stance_loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_skill_stance_cast","skill_stance_cast",0);
		DB_GLO_CharacterAnimation("PlayAnim_skill_prepare_weapon_01_start","skill_prepare_weapon_01_start",0);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_skill_prepare_weapon_01_loop","skill_prepare_weapon_01_loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_skill_attack_flurry_01_cast","skill_attack_flurry_01_cast",0);
		DB_GLO_CharacterAnimation("PlayAnim_skill_attack_precision_01_cast","skill_attack_precision_01_cast",0);
		DB_GLO_CharacterAnimation("PlayAnim_skill_attack_power_01_cast","skill_attack_power_01_cast",0);
		DB_GLO_CharacterAnimation("PlayAnim_skill_attack_round_01_cast","skill_attack_round_01_cast",0);
		DB_GLO_CharacterAnimation("PlayAnim_skill_attack_multi_01_cast","skill_attack_multi_01_cast",0);
		DB_GLO_CharacterAnimation("PlayAnim_skill_attack_multi_02_cast","skill_attack_multi_02_cast",0);
		DB_GLO_CharacterAnimation("PlayAnim_skill_attack_aoe_01_cast","skill_attack_aoe_01_cast",0);
		DB_GLO_CharacterAnimation("PlayAnim_skill_attack_offhand_01_cast","skill_attack_offhand_01_cast",0);
		DB_GLO_CharacterAnimation("PlayAnim_skill_attack_stance_01_cast","skill_attack_stance_01_cast",0);
		
		DB_GLO_CharacterAnimation("PlayAnim_skill_attack_projectile_01_cast","skill_attack_projectile_01_cast",0);
		DB_GLO_CharacterAnimation("PlayAnim_skill_attack_projectile_02_cast","skill_attack_projectile_02_cast",0);
		//////////////////////////////////////////////////////////////////////////
		//  Ranger tricks:
		//////////////////////////////////////////////////////////////////////////
		DB_GLO_CharacterAnimation("PlayAnim_skill_arrow_start","skill_arrow_start",0);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_skill_arrow_loop","skill_arrow_loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_skill_arrow_cast","skill_arrow_cast",0);
		
		DB_GLO_CharacterAnimation("PlayAnim_skill_rainofarrows_start","skill_rainofarrows_start",0);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_skill_rainofarrows_loop","skill_rainofarrows_loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_skill_rainofarrows_cast","skill_rainofarrows_cast",0);
		
		DB_GLO_CharacterAnimation("PlayAnim_skill_splittingarrows_start","skill_splittingarrows_start",0);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_skill_splittingarrows_loop","skill_splittingarrows_loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_skill_splittingarrows_cast","skill_splittingarrows_cast",0);
		
		DB_GLO_CharacterAnimation("PlayAnim_skill_multishot_lvl1_cast","skill_multishot_lvl1_cast",0);
		DB_GLO_CharacterAnimation("PlayAnim_skill_multishot_lvl2_cast","skill_multishot_lvl2_cast",0);
		DB_GLO_CharacterAnimation("PlayAnim_skill_multishot_lvl3_cast","skill_multishot_lvl3_cast",0);
		DB_GLO_CharacterAnimation("PlayAnim_skill_multishot_lvl4_cast","skill_multishot_lvl4_cast",0);
		DB_GLO_CharacterAnimation("PlayAnim_skill_multishot_lvl5_cast","skill_multishot_lvl5_cast",0);
		DB_GLO_CharacterAnimation("PlayAnim_skill_multishot_lvl6_cast","skill_multishot_lvl6_cast",0);
		DB_GLO_CharacterAnimation("PlayAnim_skill_multishot_lvl7_cast","skill_multishot_lvl7_cast",0);
		DB_GLO_CharacterAnimation("PlayAnim_skill_multishot_lvl8_cast","skill_multishot_lvl8_cast",0);
		DB_GLO_CharacterAnimation("PlayAnim_skill_multishot_lvl9_cast","skill_multishot_lvl9_cast",0);
		DB_GLO_CharacterAnimation("PlayAnim_skill_multishot_lvl10_cast","skill_multishot_lvl10_cast",0);
		//////////////////////////////////////////////////////////////////////////
		//  Warrior tricks:
		//////////////////////////////////////////////////////////////////////////
		DB_GLO_CharacterAnimation("PlayAnim_skill_flurry_start","skill_flurry_start",0);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_skill_flurry_loop","skill_flurry_loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_skill_flurry_cast","skill_flurry_cast",0);
		
		DB_GLO_CharacterAnimation("PlayAnim_skill_powerattack_start","skill_powerattack_start",0);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_skill_powerattack_loop","skill_powerattack_loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_skill_powerattack_cast","skill_powerattack_cast",0);
		
		DB_GLO_CharacterAnimation("PlayAnim_skill_whirlwind_start","skill_whirlwind_start",0);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_skill_whirlwind_loop","skill_whirlwind_loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_skill_whirlwind_cast","skill_whirlwind_cast",0);
		
		DB_GLO_CharacterAnimation("PlayAnim_skill_fatality_start","skill_fatality_start",0);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_skill_fatality_loop","skill_fatality_loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_skill_fatality_cast","skill_fatality_cast",0);
		//////////////////////////////////////////////////////////////////////////
		//  Scoundrel tricks:
		//////////////////////////////////////////////////////////////////////////
		DB_GLO_CharacterAnimation("PlayAnim_skill_shadowstrike_start","skill_shadowstrike_start",0);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_skill_shadowstrike_loop","skill_shadowstrike_loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_skill_shadowstrike_cast","skill_shadowstrike_cast",0);
		
		DB_GLO_CharacterAnimation("PlayAnim_skill_lacerate_start","skill_lacerate_start",0);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_skill_lacerate_loop","skill_lacerate_loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_skill_lacerate_cast","skill_lacerate_cast",0);
		//////////////////////////////////////////////////////////////////////////
		//  Emotions:
		//////////////////////////////////////////////////////////////////////////
		DB_GLO_CharacterAnimation("PlayAnim_emotion_normal","emotion_normal",0);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_normal_looping1","emotion_normal_looping1",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_normal_looping2","emotion_normal_looping2",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_normal_looping3","emotion_normal_looping3",1);
		DB_GLO_CharacterAnimation("PlayAnim_emotion_angry","emotion_angry",0);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_angry_looping1","emotion_angry_looping1",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_angry_looping2","emotion_angry_looping2",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_angry_looping3","emotion_angry_looping3",1);
		DB_GLO_CharacterAnimation("PlayAnim_emotion_boasting_bragging","emotion_boasting_bragging",0);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_boasting_bragging_looping1","emotion_boasting_bragging_looping1",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_boasting_bragging_looping2","emotion_boasting_bragging_looping2",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_boasting_bragging_looping3","emotion_boasting_bragging_looping3",1);
		DB_GLO_CharacterAnimation("PlayAnim_emotion_clueless","emotion_clueless",0);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_clueless_looping1","emotion_clueless_looping1",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_clueless_looping2","emotion_clueless_looping2",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_clueless_looping3","emotion_clueless_looping3",1);
		DB_GLO_CharacterAnimation("PlayAnim_emotion_cower_scared","emotion_cower_scared",0);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_cower_scared_looping1","emotion_cower_scared_looping1",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_cower_scared_looping2","emotion_cower_scared_looping2",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_cower_scared_looping3","emotion_cower_scared_looping3",1);
		DB_GLO_CharacterAnimation("PlayAnim_emotion_greeting","emotion_greeting",0);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_greeting_looping1","emotion_greeting_looping1",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_greeting_looping2","emotion_greeting_looping2",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_greeting_looping3","emotion_greeting_looping3",1);
		DB_GLO_CharacterAnimation("PlayAnim_emotion_happy_cheerful","emotion_happy_cheerful",0);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_happy_cheerful_looping1","emotion_happy_cheerful_looping1",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_happy_cheerful_looping2","emotion_happy_cheerful_looping2",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_happy_cheerful_looping3","emotion_happy_cheerful_looping3",1);
		DB_GLO_CharacterAnimation("PlayAnim_emotion_ignore_dismiss","emotion_ignore_dismiss",0);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_ignore_dismiss_looping1","emotion_ignore_dismiss_looping1",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_ignore_dismiss_looping2","emotion_ignore_dismiss_looping2",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_ignore_dismiss_looping3","emotion_ignore_dismiss_looping3",1);
		DB_GLO_CharacterAnimation("PlayAnim_emotion_panic_distress","emotion_panic_distress",0);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_panic_distress_looping1","emotion_panic_distress_looping1",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_panic_distress_looping2","emotion_panic_distress_looping2",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_panic_distress_looping3","emotion_panic_distress_looping3",1);
		DB_GLO_CharacterAnimation("PlayAnim_emotion_insulting","emotion_insulting",0);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_insulting_looping1","emotion_insulting_looping1",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_insulting_looping2","emotion_insulting_looping2",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_insulting_looping3","emotion_insulting_looping3",1);
		DB_GLO_CharacterAnimation("PlayAnim_emotion_sad","emotion_sad",0);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_sad_looping1","emotion_sad_looping1",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_sad_looping2","emotion_sad_looping2",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_sad_looping3","emotion_sad_looping3",1);
		DB_GLO_CharacterAnimation("PlayAnim_emotion_thankful","emotion_thankful",0);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_thankful_looping1","emotion_thankful_looping1",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_thankful_looping2","emotion_thankful_looping2",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_thankful_looping3","emotion_thankful_looping3",1);
		DB_GLO_CharacterAnimation("PlayAnim_emotion_sly_scheming","emotion_sly_scheming",0);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_sly_scheming_looping1","emotion_sly_scheming_looping1",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_sly_scheming_looping2","emotion_sly_scheming_looping2",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_sly_scheming_looping3","emotion_sly_scheming_looping3",1);
		DB_GLO_CharacterAnimation("PlayAnim_emotion_sarcasm_haughty","emotion_sarcasm_haughty",0);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_sarcasm_haughty_looping1","emotion_sarcasm_haughty_looping1",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_sarcasm_haughty_looping2","emotion_sarcasm_haughty_looping2",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_sarcasm_haughty_looping3","emotion_sarcasm_haughty_looping3",1);
		DB_GLO_CharacterAnimation("PlayAnim_emotion_flirt","emotion_flirt",0);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_flirt_looping1","emotion_flirt_looping1",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_flirt_looping2","emotion_flirt_looping2",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_emotion_flirt_looping3","emotion_flirt_looping3",1);
		//////////////////////////////////////////////////////////////////////////
		//  Climbing
		//////////////////////////////////////////////////////////////////////////
		DB_GLO_CharacterAnimation("PlayAnim_climb_UpAttach","climb_UpAttach",0);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_climb_Up","climb_Up",1);
		DB_GLO_CharacterAnimation("PlayAnim_climb_UpDetach","climb_UpDetach",0);
		DB_GLO_CharacterAnimation("PlayAnim_climb_DownAttach","climb_DownAttach",0);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_climb_Down","climb_Down",1);
		DB_GLO_CharacterAnimation("PlayAnim_climb_DownDetach","climb_DownDetach",0);
		DB_GLO_CharacterAnimation("PlayAnim_cast_target_start","cast_target_start",0);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_cast_target_loop","cast_target_loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_cast_target_cast","cast_target_cast",0);
		DB_GLO_CharacterAnimation("PlayAnim_cast_shout_start","cast_shout_start",0);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_cast_shout_loop","cast_shout_loop",1);
		
		// Custom animations
		DB_GLO_CharacterAnimation("PlayAnim_Activate_01","Activate_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Annoyed_01","Annoyed_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Attention_01","Attention_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Attention_02","Attention_02",0);
		DB_GLO_CharacterAnimation("PlayAnim_Attention_03","Attention_03",0);
		DB_GLO_CharacterAnimation("PlayAnim_Attentive_01","Attentive_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Beg_01","Beg_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_BehindBars_01","BehindBars_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_BehindBars_02","BehindBars_02",0);
		DB_GLO_CharacterAnimation("PlayAnim_Bellringer_01","Bellringer_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Blacksmith_01","Blacksmith_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Blacksmith_02","Blacksmith_02",0);
		DB_GLO_CharacterAnimation("PlayAnim_Bored_01","Bored_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Bored_02","Bored_02",0);
		DB_GLO_CharacterAnimation("PlayAnim_Bored_03","Bored_03",0);
		DB_GLO_CharacterAnimation("PlayAnim_Bow_01","Bow_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Bow_02","Bow_02",0);
		DB_GLO_CharacterAnimation("PlayAnim_Bow_03","Bow_03",0);
		DB_GLO_CharacterAnimation("PlayAnim_Bow_04","Bow_04",0);
		DB_GLO_CharacterAnimation("PlayAnim_Bow_05","Bow_05",0);
		DB_GLO_CharacterAnimation("PlayAnim_Cast_Ritual_01","Cast_Ritual_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Check_Neck_01","Check_Neck_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Cheer_01","Cheer_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Cheer_02","Cheer_02",0);
		DB_GLO_CharacterAnimation("PlayAnim_Cheer_03","Cheer_03",0);
		DB_GLO_CharacterAnimation("PlayAnim_Chicken_01","Chicken_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Chicken_02","Chicken_02",0);
		DB_GLO_CharacterAnimation("PlayAnim_Chicken_03","Chicken_03",0);
		DB_GLO_CharacterAnimation("PlayAnim_Chicken_Idle_01","Chicken_Idle_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Chuckle_01","Chuckle_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Chuckle_02","Chuckle_02",0);
		DB_GLO_CharacterAnimation("PlayAnim_Clap_01","Clap_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Clap_02","Clap_02",0);
		DB_GLO_CharacterAnimation("PlayAnim_Clap_03","Clap_03",0);
		DB_GLO_CharacterAnimation("PlayAnim_Clap_04","Clap_04",0);
		DB_GLO_CharacterAnimation("PlayAnim_Clean_Floor_01","Clean_Floor_01",0); // With mop & water
		DB_GLO_CharacterAnimation("PlayAnim_Clean_Floor_02","Clean_Floor_02",0); // With broom
		DB_GLO_CharacterAnimation("PlayAnim_Cooking_01","Cooking_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Cower_01","Cower_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Cower_02","Cower_02",0);
		DB_GLO_CharacterAnimation("PlayAnim_Crying_01","Crying_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Curtsey_01","Curtsey_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Dance_01","Dance_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Depressed_01","Depressed_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Dust_Off_01","Dust_Off_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Fidget_Book_01","Fidget_Book_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Fidget_Forward_01","Fidget_Forward_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Fidget_Forward_02","Fidget_Forward_02",0);
		DB_GLO_CharacterAnimation("PlayAnim_Fidget_High_01","Fidget_High_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Fidget_High_02","Fidget_High_02",0);
		DB_GLO_CharacterAnimation("PlayAnim_Fidget_Low_01","Fidget_Low_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Fidget_Low_02","Fidget_Low_02",0);
		DB_GLO_CharacterAnimation("PlayAnim_Fidget_Low_03","Fidget_Low_03",0);
		DB_GLO_CharacterAnimation("PlayAnim_Flex_01","Flex_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Flirt_01","Flirt_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Fumble_01","Fumble_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Halt_01","Halt_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Ignore_01","Ignore_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Intimidate_01","Intimidate_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Intimidate_02","Intimidate_02",0);
		DB_GLO_CharacterAnimation("PlayAnim_Kneel_01","Kneel_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Kneel_02","Kneel_02",0);
		DB_GLO_CharacterAnimation("PlayAnim_Laugh_01","Laugh_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Laugh_02","Laugh_02",0);
		DB_GLO_CharacterAnimation("PlayAnim_Listen_01","Listen_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_LoadingCart_01","LoadingCart_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Look_Down_Long_01","Look_Down_Long_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Look_Down_Short_01","Look_Down_Short_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Look_Left_Long_01","Look_Left_Long_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Look_Left_Short_01","Look_Left_Short_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Look_Right_Long_01","Look_Right_Long_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Look_Right_Short_01","Look_Right_Short_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Look_Up_Long_01","Look_Up_Long_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Look_Up_Short_01","Look_Up_Short_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Look_Up_Short_02","Look_Up_Short_02",0);
		DB_GLO_CharacterAnimation("PlayAnim_Mindcontrol_01","Mindcontrol_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Mine_01","Mine_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_No_01","No_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_No_02","No_02",0);
		DB_GLO_CharacterAnimation("PlayAnim_No_03","No_03",0);
		DB_GLO_CharacterAnimation("PlayAnim_No_04","No_04",0);
		DB_GLO_CharacterAnimation("PlayAnim_No_05","No_05",0);
		DB_GLO_CharacterAnimation("PlayAnim_No_06","No_06",0);
		DB_GLO_CharacterAnimation("PlayAnim_Perform_01","Perform_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Perform_02","Perform_02",0);
		DB_GLO_CharacterAnimation("PlayAnim_Perform_03","Perform_03",0);
		DB_GLO_CharacterAnimation("PlayAnim_Pickpocket_01","Pickpocket_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Point_01","Point_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Potion_Rub_01","Potion_Rub_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Pray_01","Pray_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Pst_01","Pst_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Pst_02","Pst_02",0);
		DB_GLO_CharacterAnimation("PlayAnim_Pst_03","Pst_03",0);
		DB_GLO_CharacterAnimation("PlayAnim_Pst_04","Pst_04",0);
		DB_GLO_CharacterAnimation("PlayAnim_Repair_01","Repair_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Revolt_01","Revolt_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Revolt_02","Revolt_02",0);
		DB_GLO_CharacterAnimation("PlayAnim_Salute_01","Salute_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Salute_02","Salute_02",0);
		DB_GLO_CharacterAnimation("PlayAnim_Salute_03","Salute_03",0);
		DB_GLO_CharacterAnimation("PlayAnim_Salute_04","Salute_04",0);
		DB_GLO_CharacterAnimation("PlayAnim_Salute_05","Salute_05",0);
		DB_GLO_CharacterAnimation("PlayAnim_Salute_06","Salute_06",0);
		DB_GLO_CharacterAnimation("PlayAnim_Salute_07","Salute_07",0);
		DB_GLO_CharacterAnimation("PlayAnim_Shout_01","Shout_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Shrug_01","Shrug_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Sigh_01","Sigh_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Sooth_01","Sooth_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Sow_02","Sow_02",0);
		DB_GLO_CharacterAnimation("PlayAnim_Stand_Read_01","Stand_Read_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Surprise_01","Surprise_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Surprise_02","Surprise_02",0);
		DB_GLO_CharacterAnimation("PlayAnim_Tapping_Beer_01","Tapping_Beer_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Tapping_Beer_02","Tapping_Beer_02",0);
		DB_GLO_CharacterAnimation("PlayAnim_Taunt_01","Taunt_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Taunt_02","Taunt_02",0);
		DB_GLO_CharacterAnimation("PlayAnim_Teleport_01","Teleport_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Think_01","Think_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Think_02","Think_02",0);
		DB_GLO_CharacterAnimation("PlayAnim_Throw_Away_01","Throw_Away_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Throw_Up_01","Throw_Up_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Throw_Water_01","Throw_Water_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Tired_01","Tired_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Trader_01","Trader_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Trader_02","Trader_02",0);
		DB_GLO_CharacterAnimation("PlayAnim_Trader_03","Trader_03",0);
		DB_GLO_CharacterAnimation("PlayAnim_Use_01","Use_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Use_02","Use_02",0);
		DB_GLO_CharacterAnimation("PlayAnim_Victory_01","Victory_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Victory_02","Victory_02",0);
		DB_GLO_CharacterAnimation("PlayAnim_Warm_Hands_01","Warm_Hands_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Wave_01","Wave_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Wave_02","Wave_02",0);
		DB_GLO_CharacterAnimation("PlayAnim_Wave_03","Wave_03",0);
		DB_GLO_CharacterAnimation("PlayAnim_WipeTable_01","WipeTable_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Worship_01","Worship_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Yawn_01","Yawn_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Yes_01","Yes_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Yes_02","Yes_02",0);
		DB_GLO_CharacterAnimation("PlayAnim_Yes_03","Yes_03",0);
		DB_GLO_CharacterAnimation("PlayAnim_Yes_04","Yes_04",0);
		DB_GLO_CharacterAnimation("PlayAnim_Yes_05","Yes_05",0);
		DB_GLO_CharacterAnimation("PlayAnim_Sit_Angry_01","Sit_Angry_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Sit_Annoyed_01","Sit_Annoyed_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Sit_Bored_01","Sit_Bored_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Sit_Bored_02","Sit_Bored_02",0);
		DB_GLO_CharacterAnimation("PlayAnim_Sit_Chuckle_01","Sit_Chuckle_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Sit_Drink_01","Sit_Drink_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Sit_Laugh_01","Sit_Laugh_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Sit_Laugh_02","Sit_Laugh_02",0);
		DB_GLO_CharacterAnimation("PlayAnim_Sit_Look_Left_01","Sit_Look_Left_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Sit_Look_Right_01","Sit_Look_Right_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Sit_No_01","Sit_No_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Sit_No_02","Sit_No_02",0);
		DB_GLO_CharacterAnimation("PlayAnim_Sit_Praise_01","Sit_Praise_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Sit_Pray_01","Sit_Pray_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Sit_Read_01","Sit_Read_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Sit_Reject_01","Sit_Reject_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Sit_Salute_01","Sit_Salute_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Sit_Sigh_01","Sit_Sigh_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Sit_Surprise_01","Sit_Surprise_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Sit_Tired_01","Sit_Tired_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Sit_Yes_01","Sit_Yes_01",0);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_BarStand_01_Loop","BarStand_01_Loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_Lie_Relax_01_Loop","Lie_Relax_01_Loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_Lie_Suffer_01_Loop","Lie_Suffer_01_Loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_Lie_Suffer_02_Loop","Lie_Suffer_02_Loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_Lie_Suffer_03_Loop","Lie_Suffer_03_Loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_Chained_01_Loop","Chained_01_Loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_Cower_03_Loop","Cower_03_Loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_Crucified_01_Loop","Crucified_01_Loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_Dig_01_Loop","Dig_01_Loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_Lie_Dead_01_Loop","Lie_Dead_01_Loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_Lie_Relax_02_Loop","Lie_Relax_02_Loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_Lie_Wounded_01_Loop","Lie_Wounded_01_Loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_Lie_Wounded_02_Loop","Lie_Wounded_02_Loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_Lie_Wounded_03_Loop","Lie_Wounded_03_Loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_Guard_01_Loop","Guard_01_Loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_Hung_01_Loop","Hung_01_Loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_Hung_02_Loop","Hung_02_Loop",1); // dead
		DB_GLO_CharacterAnimation("PlayAnim_Loop_Hung_03_Loop","Hung_03_Loop",1); // alive & kicking by the neck
		DB_GLO_CharacterAnimation("PlayAnim_Loop_Injured_01_Loop","Injured_01_Loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_Insane_01_Loop","Insane_01_Loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_Kneel_01_Loop","Kneel_01_Loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_Lie_Tied_Up_01_Loop","Lie_Tied_Up_01_Loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_Lie_Tied_Up_01_End","Lie_Tied_Up_01_End",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_Rake_01_Loop","Rake_01_Loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_Sing_01_Loop","Sing_01_Loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_Sad_01_Loop","Sad_01_Loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_Search_Book_01_Loop","Search_Book_01_Loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_Sit_Sick_01_Loop","Sit_Sick_01_Loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_Sit_Sleep_01_Loop","Sit_Sleep_01_Loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_Sit_Sleep_02_Loop","Sit_Sleep_02_Loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_Sit_Write_01_Loop","Sit_Write_01_Loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_Sow_01_Loop","Sow_01_Loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_Stand_Drink_01_Loop","Stand_Drink_01_Loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_Stand_Drink_02_Loop","Stand_Drink_02_Loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_Stand_Read_01_Loop","Stand_Read_01_Loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_Stare_01_Loop","Stare_01_Loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_Tied_Up_01_Loop","Tied_Up_01_Loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_Training_2HS_01_Loop","Training_2HS_01_Loop",1);
		DB_GLO_CharacterAnimation("PlayAnim_Loop_Training_Bow_01_Loop","Training_Bow_01_Loop",1);
		
		DB_GLO_CharacterAnimation("PlayAnim_skill_cast_throw_arc_02_cast","skill_cast_throw_arc_02_cast");
		
	}
	KB
	{
		//REGION Play animation when flag is set
		IF
		ObjectFlagSet(_Flag,(CHARACTERGUID)_Character,_Dialog)
		AND
		DB_GLO_CharacterAnimation(_Flag,_Animation,_Looping)
		THEN
		ObjectClearFlag(_Character,_Flag);
		PROC_GLO_CharacterAnimationStart(_Character,_Animation,_Dialog,_Looping);
		
		PROC
		PROC_GLO_CharacterAnimationStart((CHARACTERGUID)_Character,(STRING)_Animation,(INTEGER)_Dialog,0)
		AND
		NOT DB_GLO_CharacterAnimationForDialog(_Character,_)
		THEN
		DB_GLO_CharacterAnimationForDialog(_Character,_Dialog);
		PlayAnimation(_Character,_Animation,"GLO_CharacterAnimationFinished");
		
		IF
		StoryEvent((CHARACTERGUID)_Character,"GLO_CharacterAnimationFinished")
		AND
		DB_GLO_CharacterAnimationForDialog(_Character,_Dialog)
		THEN
		NOT DB_GLO_CharacterAnimationForDialog(_Character,_Dialog);
		
		PROC
		PROC_GLO_CharacterAnimationStart((CHARACTERGUID)_Character,(STRING)_Animation,(INTEGER)_Dialog,1)
		THEN
		CharacterSetAnimationOverride(_Character,_Animation);
		
		IF
		ObjectFlagSet("PlayAnim_StopLoop",(CHARACTERGUID)_Character,_)
		THEN
		ObjectClearFlag(_Character,"PlayAnim_StopLoop");
		CharacterSetAnimationOverride(_Character,"");
		
		IF
		ObjectFlagSet("PlayAnim_DrawWeapons",(CHARACTERGUID)_Character,_)
		AND
		HasActiveStatus(_Character,"SITTING",1)
		THEN
		RemoveStatus(_Character,"SITTING");
		
		IF
		ObjectFlagSet("PlayAnim_DrawWeapons",(CHARACTERGUID)_Character,_)
		THEN
		ObjectClearFlag(_Character,"PlayAnim_DrawWeapons");
		CharacterSetFightMode(_Character,1,0);
		
		IF
		ObjectFlagSet("PlayAnim_SheathWeapons",(CHARACTERGUID)_Character,_)
		THEN
		ObjectClearFlag(_Character,"PlayAnim_SheathWeapons");
		CharacterSetFightMode(_Character,0,0);
		//END_REGION
		
	}
	EXIT
	{
		
	}
}
Goal(26).Title("_GLOBAL_Children");
Goal(26)
{
	INIT
	{
		
	}
	KB
	{
		IF
		DB_Children((CHARACTERGUID)_Child)
		THEN
		CharacterSetImmortal(_Child,1);
		ProcCharacterDisableAllCrimes(_Child);
		SetCanFight(_Child,0);
		SetCanJoinCombat(_Child,0);
		DB_CrimeReaction_DoNotInterrogate(_Child);
		ProcCharacterEnableCrime(_Child,"PickPocketFailed");
		ProcCharacterEnableCrime(_Child,"ActiveUndead");
		ProcCharacterEnableCrime(_Child,"Steal");
		ProcCharacterEnableCrime(_Child,"TeleportPlayerDialog");
		
	}
	EXIT
	{
		
	}
}
Goal(27).Title("_Global_Counter");
Goal(27)
{
	INIT
	{
		
	}
	KB
	{
		PROC
		ProcRemoveCounter((STRING)_Name)
		AND
		DB_GlobalCounter(_Name,_Count)
		THEN
		NOT DB_GlobalCounter(_Name,_Count);
		
		PROC
		ProcDeclareCounter((STRING)_Name)
		THEN
		ProcRemoveCounter(_Name);
		DB_GlobalCounter(_Name,0);
		
		PROC
		ProcIncreaseCounter((STRING)_Name)
		THEN
		ProcIncreaseCounter(_Name,1);
		
		PROC
		ProcIncreaseCounter((STRING)_Name,(INTEGER)_Amount)
		AND
		DB_GlobalCounter(_Name,_Count)
		AND
		IntegerSum(_Count,_Amount,_NewCount)
		THEN
		NOT DB_GlobalCounter(_Name,_Count);
		DB_GlobalCounter(_Name,_NewCount);
		ProcCounterIncreased(_Name,_NewCount);
		
		PROC
		ProcCounterIncreased((STRING)_Name,(INTEGER)_NewCount)
		THEN
		DB_NOOP(1);
		
		PROC
		ProcDecreaseCounter((STRING)_Name)
		THEN
		ProcDecreaseCounter(_Name,1);
		
		PROC
		ProcDecreaseCounter((STRING)_Name,(INTEGER)_Amount)
		AND
		DB_GlobalCounter(_Name,_Count)
		AND
		IntegerSubtract(_Count,_Amount,_NewCount)
		THEN
		NOT DB_GlobalCounter(_Name,_Count);
		DB_GlobalCounter(_Name,_NewCount);
		ProcCounterDecreased((STRING)_Name,(INTEGER)_Count);
		
		PROC
		ProcCounterDecreased((STRING)_Name,(INTEGER)_NewCount)
		THEN
		DB_NOOP(1);
		
	}
	EXIT
	{
		
	}
}
Goal(28).Title("_GLOBAL_Effects");
Goal(28)
{
	INIT
	{
		PROC_CleanUpEffects();
		
	}
	KB
	{
		//REGION Savegame handle fixes 
		
		IF
		DB_CurrentLevel(_)
		THEN
		PROC_InvalidateLoopEffects();
		PROC_InvalidateLoopBeamEffects();
		
		PROC
		PROC_InvalidateLoopEffects()
		AND
		DB_LoopEffect((GUIDSTRING)_object, (INTEGER64) _fxHandle,(STRING)_ID,(STRING)_Region,(STRING)_effect,(STRING)_BoneName)
		THEN
		NOT DB_LoopEffect(_object, _fxHandle,_ID,_Region,_effect,_BoneName);
		DB_LoopEffect(_object, (INTEGER64)-1,_ID,_Region,_effect,_BoneName);
		
		PROC
		PROC_InvalidateLoopBeamEffects()
		AND
		DB_LoopBeamEffect((GUIDSTRING)_Source,(GUIDSTRING)_Target,(INTEGER64)_EffectHandle,(STRING)_ID,(STRING)_Region,(STRING)_effect,(STRING)_SrcBone,(STRING)_TargetBone)
		THEN
		NOT DB_LoopBeamEffect(_Source,_Target,_EffectHandle,_ID,_Region,_effect,_SrcBone,_TargetBone);
		DB_LoopBeamEffect(_Source,_Target,(INTEGER64)-1,_ID,_Region,_effect,_SrcBone,_TargetBone);
		//END_REGION
		
		/***************************/
		/*** EFFECT REGISTRATION ***/
		/***************************/
		QRY
		QRY_PlayLoopEffectCleanUp()
		AND
		DB_PlayLoopEffectHandleResult((INTEGER64)_ID)
		THEN
		NOT DB_PlayLoopEffectHandleResult(_ID);
		
		// Always succeed
		QRY
		QRY_PlayLoopEffectCleanUp()
		THEN
		DB_NOOP(1);
		
		QRY
		QRY_PlayLoopEffect((GUIDSTRING)_Source, (STRING)_Effect, (STRING)_BoneName)
		AND
		_BoneName != "__POSITION__"
		AND
		QRY_PlayLoopEffectCleanUp()
		AND
		PlayLoopEffect(_Source, _effect, _BoneName, _fxHandle)
		THEN
		DB_PlayLoopEffectHandleResult(_fxHandle);
		
		QRY
		QRY_PlayLoopEffect((GUIDSTRING)_Source, (STRING)_Effect, "__POSITION__")
		AND
		QRY_PlayLoopEffectCleanUp()
		AND
		GetPosition(_Source, _X, _Y, _Z)
		AND
		PlayLoopEffectAtPosition(_effect, _X, _Y, _Z, _fxHandle)
		THEN
		DB_PlayLoopEffectHandleResult(_fxHandle);
		
		PROC
		PROC_LoopEffectAtPosition((STRING)_effect, (GUIDSTRING)_Source,(STRING)_ID,(STRING)_Region)
		THEN
		PROC_LoopEffect(_effect, _Source,_ID,_Region,"__POSITION__");
		
		PROC
		PROC_LoopEffect((STRING)_effect, (GUIDSTRING)_Source,(STRING)_ID,(STRING)_Region,(STRING)_BoneName)
		AND
		DB_CurrentLevel(_Region)
		AND
		QRY_PlayLoopEffect(_Source, _effect, _BoneName)
		AND
		DB_PlayLoopEffectHandleResult(_fxHandle)
		THEN
		DB_LoopEffect(_Source, _fxHandle,_ID,_Region,_effect, _BoneName);
		
		PROC
		PROC_LoopEffect((STRING)_effect, (GUIDSTRING)_Source,(STRING)_ID,(STRING)_Region,(STRING)_BoneName)
		AND
		_Region!="__ANY__"
		AND
		NOT DB_CurrentLevel(_Region)
		THEN
		DB_LoopEffect(_Source, (INTEGER64)-1,_ID,_Region,_effect, _BoneName);
		
		PROC
		PROC_LoopEffect((STRING)_effect, (GUIDSTRING)_Source,(STRING)_ID,"__ANY__",(STRING)_BoneName)
		AND
		DB_CurrentLevel(_)
		AND
		NOT QryBlockEffectInCombat(_effect,_Source)
		AND
		QRY_PlayLoopEffect(_Source, _effect, _BoneName)
		AND
		DB_PlayLoopEffectHandleResult(_fxHandle)
		THEN
		DB_LoopEffect(_Source, _fxHandle,_ID,"__ANY__",_effect, _BoneName);
		
		PROC
		PROC_LoopEffect((STRING)_effect, (GUIDSTRING)_Source,(STRING)_ID,"__ANY__",(STRING)_BoneName)
		AND
		DB_CurrentLevel(_)
		AND
		QryBlockEffectInCombat(_effect,_Source)
		THEN
		DB_LoopEffect(_Source, (INTEGER64)-1,_ID,"__ANY__",_effect, _BoneName);
		
		PROC
		PROC_LoopEffect((STRING)_effect, (GUIDSTRING)_Source,(STRING)_ID,"__ANY__",(STRING)_BoneName)
		AND
		NOT DB_CurrentLevel(_)
		THEN
		DB_LoopEffect(_Source, (INTEGER64)-1,_ID,"__ANY__",_effect, _BoneName);
		
		PROC
		PROC_LoopBeamEffect((STRING)_effect, (GUIDSTRING)_Source,(GUIDSTRING)_Target,(STRING)_SrcBone,(STRING)_TargetBone,(STRING)_ID,(STRING)_Region)
		AND
		_Region!="__ANY__"
		AND
		NOT DB_CurrentLevel(_Region)
		THEN
		DB_LoopBeamEffect(_Source,_Target,(INTEGER64)-1,_ID,_Region,_effect,_SrcBone,_TargetBone);
		
		PROC
		PROC_LoopBeamEffect((STRING)_effect, (GUIDSTRING)_Source,(GUIDSTRING)_Target,(STRING)_SrcBone,(STRING)_TargetBone,(STRING)_ID,(STRING)_Region)
		AND
		DB_CurrentLevel(_Region)
		AND
		PlayLoopBeamEffect(_Source,_Target,_effect,_SrcBone,_TargetBone,_EffectHandle)
		THEN
		DB_LoopBeamEffect(_Source,_Target,_EffectHandle,_ID,_Region,_effect,_SrcBone,_TargetBone);
		
		PROC
		PROC_LoopBeamEffect((STRING)_effect, (GUIDSTRING)_Source,(GUIDSTRING)_Target,(STRING)_SrcBone,(STRING)_TargetBone,(STRING)_ID,"__ANY__")
		AND
		PlayLoopBeamEffect(_Source,_Target,_effect,_SrcBone,_TargetBone,_EffectHandle)
		THEN
		DB_LoopBeamEffect(_Source,_Target,_EffectHandle,_ID,"__ANY__",_effect,_SrcBone,_TargetBone);
		
		/***********************/
		/*** EFFECT DELETION ***/
		/***********************/
		
		PROC
		ProcStopLoopEffect((INTEGER64)_fxHandle)
		AND
		_fxHandle!=-1
		THEN
		StopLoopEffect(_fxHandle);
		
		PROC
		PROC_StopLoopEffect((GUIDSTRING)_Source,(STRING)_ID)
		AND
		DB_LoopEffect(_Source, _fxHandle,_ID,_Region,_effect, _BoneName)
		THEN
		ProcStopLoopEffect(_fxHandle);
		NOT DB_LoopEffect(_Source, _fxHandle,_ID,_Region,_effect, _BoneName);
		
		PROC
		PROC_StopLoopBeamEffect((GUIDSTRING)_Source,(STRING)_ID)
		AND
		DB_LoopBeamEffect(_Source,_Target,_EffectHandle,_ID,_Region,_effect,_SrcBone,_TargetBone)
		THEN
		ProcStopLoopEffect(_EffectHandle);
		NOT DB_LoopBeamEffect(_Source,_Target,_EffectHandle,_ID,_Region,_effect,_SrcBone,_TargetBone);
		
		/************************/
		/*** EFFECTS CLEAN-UP ***/
		/************************/
		
		PROC
		PROC_CleanUpEffects()
		THEN
		PROC_CleanUpLoopEffects();
		PROC_CleanUpLoopBeamEffects();
		
		PROC
		PROC_CleanUpLoopEffects()
		AND
		DB_LoopEffect(_Object, _,_ID,_,_,_)
		THEN
		PROC_StopLoopEffect(_Object,_ID);
		
		PROC
		PROC_CleanUpLoopBeamEffects()
		AND
		DB_LoopBeamEffect(_Source,_Target,_EffectHandle,_ID,_Region,_effect,_SrcBone,_TargetBone)
		THEN
		PROC_StopLoopBeamEffect(_Source,_ID);
		
		
		
		/************************/
		
		//REGION stopping effects for a region 
		
		PROC
		ProcStopEffectsForRegion((STRING)_Region)
		THEN
		ProcStopLoopEffectsForRegion(_Region);
		ProcStopLoopBeamEffectsForRegion(_Region);
		
		PROC
		ProcStopLoopEffectsForRegion((STRING)_Region)
		AND
		DB_LoopEffect(_Source, _fxHandle,_ID,_Region,_effect, _BoneName)
		THEN
		ProcStopLoopEffect(_fxHandle);
		NOT DB_LoopEffect(_Source, _fxHandle,_ID,_Region,_effect, _BoneName);
		DB_LoopEffect(_Source,(INTEGER64)-1,_ID,_Region,_effect, _BoneName);
		
		PROC
		ProcStopLoopBeamEffectsForRegion((STRING)_Region)
		AND
		DB_LoopBeamEffect(_Source,_Target,_EffectHandle,_ID,_Region,_effect,_SrcBone,_TargetBone)
		THEN
		ProcStopLoopEffect(_EffectHandle);
		NOT DB_LoopBeamEffect(_Source,_Target,_EffectHandle,_ID,_Region,_effect,_SrcBone,_TargetBone);
		DB_LoopBeamEffect(_Source,_Target,(INTEGER64)-1,_ID,_Region,_effect,_SrcBone,_TargetBone);
		
		PROC
		ProcStopLoopEffectsForRegion((STRING)_)
		AND
		DB_LoopEffect(_Source, _fxHandle,_ID,"__ANY__",_effect, _BoneName)
		THEN
		ProcStopLoopEffect(_fxHandle);
		NOT DB_LoopEffect(_Source, _fxHandle,_ID,"__ANY__",_effect, _BoneName);
		DB_LoopEffect(_Source, (INTEGER64)-1,_ID,"__ANY__",_effect, _BoneName);
		
		PROC
		ProcStopLoopBeamEffectsForRegion((STRING)_)
		AND
		DB_LoopBeamEffect(_Source,_Target,_EffectHandle,_ID,"__ANY__",_effect,_SrcBone,_TargetBone)
		THEN
		ProcStopLoopEffect(_EffectHandle);
		NOT DB_LoopBeamEffect(_Source,_Target,_EffectHandle,_ID,"__ANY__",_effect,_SrcBone,_TargetBone);
		DB_LoopBeamEffect(_Source,_Target,(INTEGER64)-1,_ID,"__ANY__",_effect,_SrcBone,_TargetBone);
		//END_REGION
		
		//REGION starting effects for a region 
		
		PROC
		ProcStartEffectsForRegion((STRING)_Region)
		THEN
		ProcStartLoopEffectsForRegion(_Region);
		ProcStartLoopBeamEffectsForRegion(_Region);
		
		PROC
		ProcStartLoopEffectsForRegion((STRING)_Region)
		AND
		DB_LoopEffect(_Source, _fxHandle,_ID,_Region,_effect, _BoneName)
		AND
		NOT QryBlockEffectInCombat(_effect,_Source)
		AND
		QRY_PlayLoopEffect(_Source, _effect, _BoneName)
		AND
		DB_PlayLoopEffectHandleResult(_NewfxHandle)
		THEN
		ProcStopLoopEffect(_fxHandle);
		NOT DB_LoopEffect(_Source, _fxHandle,_ID,_Region,_effect, _BoneName);
		DB_LoopEffect(_Source, _NewfxHandle,_ID,_Region,_effect, _BoneName);
		
		PROC
		ProcStartLoopBeamEffectsForRegion((STRING)_Region)
		AND
		DB_LoopBeamEffect(_Source,_Target,_EffectHandle,_ID,_Region,_effect,_SrcBone,_TargetBone)
		AND
		PlayLoopBeamEffect(_Source,_Target,_effect,_SrcBone,_TargetBone,_NewEffectHandle)
		THEN
		ProcStopLoopEffect(_EffectHandle);
		NOT DB_LoopBeamEffect(_Source,_Target,_EffectHandle,_ID,_Region,_effect,_SrcBone,_TargetBone);
		DB_LoopBeamEffect(_Source,_Target,_NewEffectHandle,_ID,_Region,_effect,_SrcBone,_TargetBone);
		
		///////
		
		PROC
		ProcStartLoopEffectsForRegion((STRING)_)
		AND
		DB_LoopEffect(_Source, _fxHandle,_ID,"__ANY__",_effect, _BoneName)
		AND
		NOT QryBlockEffectInCombat(_effect,_Source)
		AND
		QRY_PlayLoopEffect(_Source, _effect, _BoneName)
		AND
		DB_PlayLoopEffectHandleResult(_NewfxHandle)
		THEN
		ProcStopLoopEffect(_fxHandle);
		NOT DB_LoopEffect(_Source, _fxHandle,_ID,"__ANY__",_effect, _BoneName);
		DB_LoopEffect(_Source, _NewfxHandle,_ID,"__ANY__",_effect, _BoneName);
		
		PROC
		ProcStartLoopBeamEffectsForRegion((STRING)_Region)
		AND
		DB_LoopBeamEffect(_Source,_Target,_EffectHandle,_ID,"__ANY__",_effect,_SrcBone,_TargetBone)
		AND
		PlayLoopBeamEffect(_Source,_Target,_effect,_SrcBone,_TargetBone,_NewEffectHandle)
		THEN
		ProcStopLoopEffect(_EffectHandle);
		NOT DB_LoopBeamEffect(_Source,_Target,_EffectHandle,_ID,"__ANY__",_effect,_SrcBone,_TargetBone);
		DB_LoopBeamEffect(_Source,_Target,_NewEffectHandle,_ID,"__ANY__",_effect,_SrcBone,_TargetBone);
		
		//END_REGION
		
		IF
		RegionEnded(_Region)
		THEN
		ProcStopEffectsForRegion(_Region);
		
		// At GameStarted instead of RegionStarted, because sometimes characters are teleported to the current region
		// only during RegionStarted, and this RegionStarted handled may be exectuted before the one doing that
		// (which results in playing the effect on the character while they are still in the previous level, and that
		//  triggers an assert)
		IF
		GameStarted(_Region,_)
		THEN
		ProcStartEffectsForRegion(_Region);
		
		//REGION Special case: Some effects should stop during combat
		IF
		ObjectEnteredCombat(_Character,_)
		AND
		DB_LoopEffect(_Character, _fxHandle,_ID,_Region,_EffectName,_BoneName)
		AND
		DB_LoopEffectDisabledInCombat(_EffectName)
		THEN
		ProcStopLoopEffect(_fxHandle);
		NOT DB_LoopEffect(_Character, _fxHandle,_ID,_Region,_EffectName,_BoneName);
		DB_LoopEffect(_Character, (INTEGER64)-1, _ID,_Region,_EffectName,_BoneName);
		
		IF
		ObjectLeftCombat((CHARACTERGUID)_Character,_)
		AND
		NOT DB_Dead(_Character)
		AND
		DB_LoopEffect(_Character, (INTEGER64)-1, _ID,_Region,_EffectName,_BoneName)
		AND
		DB_LoopEffectDisabledInCombat(_EffectName)
		AND
		QRY_PlayLoopEffect(_Character, _EffectName, _BoneName)
		AND
		DB_PlayLoopEffectHandleResult(_NewfxHandle)
		THEN
		NOT DB_LoopEffect(_Character, (INTEGER64)-1, _ID,_Region,_EffectName,_BoneName);
		DB_LoopEffect(_Character,_NewfxHandle,_ID,_Region,_EffectName,_BoneName);
		
		QRY
		QryBlockEffectInCombat((STRING)_EffectName,(GUIDSTRING)_Object)
		AND
		DB_LoopEffectDisabledInCombat(_EffectName)
		AND
		DB_CombatObjects(_Object,_)
		THEN
		DB_NOOP(1);
		
		//END_REGION
		
	}
	EXIT
	{
		
	}
}
Goal(29).Title("_Global_Homestead");
Goal(29)
{
	INIT
	{
		
	}
	KB
	{
		//REGION Character creation mirror (respec)
		IF
		CharacterItemEvent(_Player,_Mirror,"GEN_Homestead_CharCreationMirror")
		AND
		CharacterAddToCharacterCreation(_Player,2,1)
		THEN
		DB_Illusionist(_Player,_Mirror);
		
		IF
		CharacterItemEvent(_Player,_Mirror,"GEN_Homestead_CharCreationMirror")
		AND
		HasActiveStatus(_Player,"PLAY_DEAD",1)
		THEN
		RemoveStatus(_Player,"PLAY_DEAD");
		
		//REGION Save while using the mirror -> re-add to character creation after loading (DOSTWO-9410)
		IF
		SavegameLoaded(_,_,_,_)
		AND
		DB_Illusionist(_Player,_Mirror)
		AND
		CharacterAddToCharacterCreation(_Player,2,0)
		THEN
		DebugBreak("Failed to re-add player to character creation after reload");
		//END_REGION
		
		//REGION Handle teleportation pyramids
		// Avoid other players teleporting into the character creation "level"
		IF
		DB_Illusionist(_Player,_)
		AND
		DB_TeleporterPyramid(_Pyramid)
		AND
		ItemIsInCharacterInventory(_Pyramid,_Player,1)
		THEN
		Proc_PyramidCustomBlockAdd(_Pyramid,"LV_Mirror");
		
		IF
		ItemAddedToCharacter(_Pyramid,_Player)
		AND
		DB_TeleporterPyramid(_Pyramid)
		AND
		DB_Illusionist(_Player,_Mirror)
		THEN
		Proc_PyramidCustomBlockAdd(_Pyramid,"LV_Mirror");
		
		IF
		ItemRemovedFromCharacter(_Pyramid,_Player)
		AND
		DB_TeleporterPyramid(_Pyramid)
		AND
		DB_Illusionist(_Player,_Mirror)
		THEN
		Proc_PyramidCustomBlockRemove(_Pyramid,"LV_Mirror");
		
		IF
		CharacterCreationFinished(_Player)
		AND
		DB_Illusionist(_Player,_Mirror)
		AND
		DB_TeleporterPyramid(_Pyramid)
		AND
		ItemIsInCharacterInventory(_Pyramid,_Player,1)
		THEN
		Proc_PyramidCustomBlockRemove(_Pyramid,"LV_Mirror");
		//END_REGION
		
		//REGION Finished respec
		PROC
		Proc_HomesteadTeleportAfterMirror((CHARACTERGUID)_Player,(ITEMGUID)_Mirror,(TRIGGERGUID)_Trigger)
		AND
		_Trigger!=NULL_00000000-0000-0000-0000-000000000000
		THEN
		TeleportTo(_Player,_Trigger,"",0);
		
		PROC
		Proc_HomesteadTeleportAfterMirror((CHARACTERGUID)_Player,(ITEMGUID)_Mirror,(TRIGGERGUID)_Trigger)
		AND
		_Trigger==NULL_00000000-0000-0000-0000-000000000000
		THEN
		TeleportTo(_Player,_Mirror,"",0);
		
		IF
		CharacterCreationFinished(_Player)
		AND
		DB_Illusionist(_Player,_Mirror)
		AND
		GetVarObject(_Mirror,"PlayerPositionAfterCreation",_Trigger)
		THEN
		NOT DB_Illusionist(_Player,_Mirror);
		Proc_HomesteadTeleportAfterMirror(_Player,_Mirror,(TRIGGERGUID)_Trigger);
		//END_REGION
		
		//END_REGION
		
	}
	EXIT
	{
		
	}
}
Goal(30).Title("_GLOBAL_ItemEvents");
Goal(30)
{
	INIT
	{
		/*
		Databases used for this events
		DB_HasStoryEvent((ITEMGUID)_Item,_HasItemEvent);
		DB_GiveItemToEvent(_Item,_GiveItemToStoryEvent);
		DB_SetStoryFlagWhenEquipped((ITEMGUID)_Item,(STRING)_EquippedItemFlag);
		*/
		///Please Add any Item tags that you want to be tracked HERE!!
		//when declaredo n the fly only players will be checked
		DB_TaggedItemInitialSetup(1);
		DB_TaggedItemTracker("HEALING_POTION");
		DB_TaggedItemTracker("BODYPART");
		DB_TaggedItemTracker("MEAT");
		DB_TaggedItemTracker("FISH");
		DB_TaggedItemTracker("BOOK");
		DB_TaggedItemTracker("QUEST_ANCESTOR_TREE_BRANCH");
		DB_TaggedItemTracker("FOOD");
		DB_TaggedItemTracker("BONE");
		DB_TaggedItemTracker("TOY");
		DB_TaggedItemTracker("ALCOHOL");
		DB_TaggedItemTracker("CHEESE");
		DB_TaggedItemTracker("VEGETABLE");
		DB_TaggedItemTracker("DRUDANAE");
		NOT DB_TaggedItemInitialSetup(1);
		
		DB_ItemEvents_TransferFlagToMoneyVarIndex("GEN_TransferNPCPayment",1);
		DB_ItemEvents_TransferFlagToMoneyVarIndex("GEN_TransferNPCPayment_2",2);
		DB_ItemEvents_TransferFlagToMoneyVarIndex("GEN_TransferNPCPayment_3",3);
		DB_ItemEvents_TransferFlagToMoneyVarIndex("GEN_TransferNPCPayment_4",4);
		DB_ItemEvents_TransferFlagToMoneyVarIndex("GEN_TransferNPCPayment_5",5);
		
	}
	KB
	{
		//REGION Event Recheck triggers
		//see also ZZZ_ItemEvents for a trigger
		IF
		CharacterMadePlayer(_Player)
		THEN
		DB_IgnoreReservedChanged(_Player);
		
		IF
		DB_CharacterCreationDummy((CHARACTERGUID)_Char)
		THEN
		DB_IgnoreReservedChanged(_Char);
		
		IF
		CharacterReservedUserIDChanged(_Char,_,_)
		AND
		DB_IsPlayer(_Char)
		AND
		NOT DB_IgnoreReservedChanged(_Char)
		THEN
		Proc_ItemEventCheck();
		
		IF
		CharacterReservedUserIDChanged(_Char,_,_)
		THEN
		NOT DB_IgnoreReservedChanged(_Char);
		
		IF
		SavegameLoaded(_,_,_,_)
		THEN
		Proc_ItemEventCheck();
		
		PROC
		PROC_GLO_PartyMembers_Add((CHARACTERGUID)_Origin,(CHARACTERGUID)_)
		AND
		NOT DB_BlockOwnershipChecks(1)
		THEN
		Proc_ItemEventCheck();
		
		//END_REGION
		
		//REGION Private
		PROC
		ProcSetMagicPocketsItemTemplatecount((CHARACTERGUID)_Player,(STRING)_Template,(INTEGER)_)
		AND
		DB_MagicPocketsItemTemplateCount(_Player,_Template,_Count)
		THEN
		NOT DB_MagicPocketsItemTemplateCount(_Player,_Template,_Count);
		
		PROC
		ProcSetMagicPocketsItemTemplatecount((CHARACTERGUID)_Player,(STRING)_Template,(INTEGER)_Count)
		THEN
		DB_MagicPocketsItemTemplateCount(_Player,_Template,_Count);
		//END_REGION
		
		//REGION Eating a bodypart
		IF
		StoryEvent(_Player,"GEN_CloseInventory")
		THEN
		CloseUI((CHARACTERGUID)_Player,"Inventory");
		
		IF
		CharacterItemEvent(_Char,_BodyPart,_Dialog)
		AND
		DB_AwaitingBodypartDialog(_Char,_BodyPart)
		THEN
		NOT DB_AwaitingBodypartDialog(_Char,_BodyPart);
		ProcCheckBodyPartDialog(_Char,_Dialog);
		
		IF
		CharacterItemEvent(_Char,_BodyPart,"GLO_AteBodyPart")
		THEN
		DB_AwaitingBodypartDialog(_Char,_BodyPart);
		
		PROC
		ProcCheckBodyPartDialog((CHARACTERGUID)_Char,(STRING)_Dialog)
		AND
		_Dialog!=""
		THEN
		ProcTriggerLimbEatingDialog(_Char,_Dialog);
		
		PROC
		ProcTriggerLimbEatingDialog((CHARACTERGUID)_Char,(STRING)_Dialog)
		AND
		CharacterIsInCombat(_Char,0)
		THEN
		Proc_StartDialog(0,_Dialog,_Char);
		
		PROC
		ProcTriggerLimbEatingDialog((CHARACTERGUID)_Char,(STRING)_Dialog)
		AND
		CharacterIsInCombat(_Char,1)
		THEN
		CloseUI(_Char,"Inventory");
		
		IF
		DialogEnded("GEN_Limb_RottenLimb", _ID)
		AND
		DB_DialogPlayers(_ID, _Player, _)
		AND
		CharacterConsume((CHARACTERGUID)_Player, "CON_BodyPart_Harm", _)
		THEN
		DB_NOOP(0);
		//END_REGION
		
		//REGION Magic Pockets procedures
		QRY
		QryItemInMagicPockets((CHARACTERGUID)_Char,(ITEMGUID)_Item)
		AND
		ItemIsInUserInventory(_Item,_Char,0,1)
		THEN
		DB_NOOP(1);
		
		QRY
		QryItemTemplateInMagicPockets((CHARACTERGUID)_Char,(STRING)_ItemTemplate)
		AND
		ItemTemplateIsInUserInventory(_Char,_ItemTemplate,0,_Count)
		AND
		_Count > 0
		THEN
		DB_NOOP(1);
		
		QRY
		QryTaggedItemInMagicPockets((CHARACTERGUID)_Character,(STRING)_Tag)
		AND
		UserFindTaggedItem(_Character,_Tag,0,_Item)
		THEN
		DB_NOOP(1);
		
		QRY
		QryItemTemplateInMagicPocketsCount((CHARACTERGUID)_Player,(STRING)_Template)
		AND
		ItemTemplateIsInUserInventory(_Player,_Template,0,_Count)
		AND
		_Count > 0
		THEN
		ProcSetMagicPocketsItemTemplatecount(_Player,_Template,_Count);
		
		QRY
		QryRemoveTaggedLocalItemsFromMagicPockets((CHARACTERGUID)_Player,(STRING)_Tag,(INTEGER)_Amount)
		AND
		UserRemoveTaggedLocalItems(_Player,_Tag,_Amount,_Count)
		AND
		_Count == _Amount
		THEN
		DB_NOOP(1);
		
		QRY
		QryTakeItemFromMagicPockets((CHARACTERGUID)_Player,(ITEMGUID)_Item,(CHARACTERGUID)_TargetCharacter)
		AND
		ItemIsInUserInventory(_Item,_Player, 1, 1)
		THEN
		ItemToInventory(_Item,_TargetCharacter);
		
		QRY
		QryTakeItemTemplateFromMagicPockets((CHARACTERGUID)_Character,(STRING)_ItemTemplate,(INTEGER)_Amount,(CHARACTERGUID)_TargetCharacter)
		AND
		ItemTemplateIsInUserInventory(_Character,_ItemTemplate,1,_Amount)
		THEN
		ItemTemplateRemoveFromUser(_ItemTemplate,_Character,_Amount);
		ItemTemplateAddTo(_ItemTemplate,_TargetCharacter,_Amount);
		
		QRY
		QryRemoveItemTemplateFromMagicPockets((CHARACTERGUID)_Character,(STRING)_ItemTemplate,(INTEGER)_Amount)
		AND
		ItemTemplateIsInUserInventory(_Character,_ItemTemplate,1,_HaveAmount)
		AND
		_HaveAmount >= _Amount
		THEN
		ItemTemplateRemoveFromUser(_ItemTemplate,_Character,_Amount);
		
		//TODO: take amount into account
		QRY
		QryRemoveTaggedItemFromMagicPockets((CHARACTERGUID)_Character,(STRING)_Tag, (INTEGER)_Amount)
		AND
		UserFindTaggedItem(_Character,_Tag,1,_Item)
		THEN
		ItemRemove(_Item);
		
		QRY
		QryEvaluateMagicPocketGold((CHARACTERGUID)_Character,"<",(INTEGER)_Amount)
		AND
		UserGetGold(_Character,_Gold)
		AND
		_Gold < _Amount
		THEN
		DB_NOOP(1);
		
		QRY
		QryEvaluateMagicPocketGold((CHARACTERGUID)_Character,"<=",(INTEGER)_Amount)
		AND
		UserGetGold(_Character,_Gold)
		AND
		_Gold <= _Amount
		THEN
		DB_NOOP(1);
		
		QRY
		QryEvaluateMagicPocketGold((CHARACTERGUID)_Character,">",(INTEGER)_Amount)
		AND
		UserGetGold(_Character,_Gold)
		AND
		_Gold > _Amount
		THEN
		DB_NOOP(1);
		
		QRY
		QryEvaluateMagicPocketGold((CHARACTERGUID)_Character,">=",(INTEGER)_Amount)
		AND
		UserGetGold(_Character,_Gold)
		AND
		_Gold >= _Amount
		THEN
		DB_NOOP(1);
		
		QRY
		QryEvaluateMagicPocketGold((CHARACTERGUID)_Character,"==",(INTEGER)_Amount)
		AND
		UserGetGold(_Character,_Gold)
		AND
		_Gold == _Amount
		THEN
		DB_NOOP(1);
		
		PROC
		ProcEvaluateMagicPocketGold((CHARACTERGUID)_Character,"<",(INTEGER)_Amount,(STRING)_ObjectFlag)
		AND
		UserGetGold(_Character,_Gold)
		AND
		_Gold < _Amount
		THEN
		ObjectSetFlag(_Character,_ObjectFlag);
		
		PROC
		ProcEvaluateMagicPocketGold((CHARACTERGUID)_Character,"<=",(INTEGER)_Amount,(STRING)_ObjectFlag)
		AND
		UserGetGold(_Character,_Gold)
		AND
		_Gold <= _Amount
		THEN
		ObjectSetFlag(_Character,_ObjectFlag);
		
		PROC
		ProcEvaluateMagicPocketGold((CHARACTERGUID)_Character,"==",(INTEGER)_Amount,(STRING)_ObjectFlag)
		AND
		UserGetGold(_Character,_Gold)
		AND
		_Gold == _Amount
		THEN
		ObjectSetFlag(_Character,_ObjectFlag);
		
		PROC
		ProcEvaluateMagicPocketGold((CHARACTERGUID)_Character,">",(INTEGER)_Amount,(STRING)_ObjectFlag)
		AND
		UserGetGold(_Character,_Gold)
		AND
		_Gold > _Amount
		THEN
		ObjectSetFlag(_Character,_ObjectFlag);
		
		PROC
		ProcEvaluateMagicPocketGold((CHARACTERGUID)_Character,">=",(INTEGER)_Amount,(STRING)_ObjectFlag)
		AND
		UserGetGold(_Character,_Gold)
		AND
		_Gold >= _Amount
		THEN
		ObjectSetFlag(_Character,_ObjectFlag);
		
		PROC
		ProcAddGoldToMagicPockets((CHARACTERGUID)_Char,(INTEGER)_Gold)
		THEN
		UserAddGold(_Char,_Gold);
		
		PROC
		ProcLaunchMagicPocketIterator((CHARACTERGUID)_Character,(STRING)_Event, (STRING)_CompletionEvent)
		AND
		CharacterGetReservedUserID(_Character,_OwnerUser)
		AND
		DB_IsPlayer(_Player)
		AND
		CharacterGetReservedUserID(_Player,_OwnerUser)
		THEN
		InventoryLaunchIterator(_Player, _Event, "");
		
		PROC
		ProcLaunchMagicPocketIterator((CHARACTERGUID)_Character,(STRING)_Event, (STRING)_CompletionEvent)
		AND
		_CompletionEvent != ""
		THEN
		GlobalSetFlag(_CompletionEvent);
		
		PROC
		ProcLaunchMagicPocketTagIterator((CHARACTERGUID)_Character,(STRING)_TagA,(STRING)_TagB,(STRING)_Event,(STRING)_CompletionEvent)
		AND
		CharacterGetReservedUserID(_Character,_OwnerUser)
		AND
		DB_IsPlayer(_Player)
		AND
		CharacterGetReservedUserID(_Player,_OwnerUser)
		THEN
		InventoryLaunchTagIterator(_Player,_TagA,_TagB,_Event,"");
		
		PROC
		ProcLaunchMagicPocketTagIterator((CHARACTERGUID)_Character,(STRING)_TagA,(STRING)_TagB,(STRING)_Event,(STRING)_CompletionEvent)
		AND
		_CompletionEvent != ""
		THEN
		GlobalSetFlag(_CompletionEvent);
		
		QRY
		QRY_HasMagicPocketsOwnershipFlag((CHARACTERGUID)_Char,(STRING)_Flag)
		AND
		DB_IsPlayer(_Char)
		AND
		UserGetFlag(_Char,_Flag,1)
		THEN
		DB_Noop(1);
		
		QRY
		QRY_HasMagicPocketsOwnershipFlag((CHARACTERGUID)_Char,(STRING)_Flag)
		AND
		NOT DB_IsPlayer(_Char)
		AND
		ObjectGetFlag(_Char,_Flag,1)
		THEN
		DB_Noop(1);
		
		PROC
		ProcSetMagicPocketsOwnershipFlag((CHARACTERGUID)_Char,(STRING)_Flag)
		AND
		DB_IsPlayer(_Char)
		THEN
		UserSetFlag(_Char,_Flag,0);
		
		PROC
		ProcSetMagicPocketsOwnershipFlag((CHARACTERGUID)_Char,(STRING)_Flag)
		AND
		NOT DB_IsPlayer(_Char)
		THEN
		ObjectSetFlag(_Char,_Flag); 
		
		PROC
		ProcClearMagicPocketsOwnershipFlag((CHARACTERGUID)_Char,(STRING)_Flag)
		AND
		DB_IsPlayer(_Char)
		THEN
		UserClearFlag(_Char,_Flag,0);
		
		PROC
		ProcClearMagicPocketsOwnershipFlag((CHARACTERGUID)_Char,(STRING)_Flag)
		AND
		NOT DB_IsPlayer(_Char)
		THEN
		ObjectClearFlag(_Char,_Flag,0); 
		
		//REGION General Give - Take Gold in dialogs
		
		// Usage:
		//   DB_DialogMoneyTransfer(_MoneyVarIndex,_Dialog,_Amount)
		//   DB_DialogMoneyTransfer(_MoneyVarIndex,_Dialog,_Amount,_CheckSpeakerIndex)
		//   DB_DialogMoneyTransfer(_MoneyVarIndex,_Dialog,_Amount,_CheckSpeakerIndex,_TargetDBIndex)
		//
		// Paramters:
		//   - _MoneyVarIndex: 1 - 5 (use different GEN_CheckMagicPocketGold variables)
		//   - _Dialog: name of the dialog
		//   - _Amount: amount of money transfer
		//   - _CheckSpeakerIndex: the speaker index on which the money should be checked by the
		//     GEN_CheckPocketGold* script flags. If not specified, defaults to 2 (player in most cases).
		//      ** NOTE: this Speaker index is a dialog speaker index, as assigned in the dialog
		//   - _TargetDBIndex: when the GEN_TransferNPCPayment/GEN_TransferNPCPayment_2/../GEN_TransferNPCPayment_5 flag
		//     is set on a player in a dialog, transfer the money from that player to DB_DialogNPCs(_ID,_NPC,_TargetDBIndex).
		//     When set on an NPC in a dialog, transfer from that NPC to DB_DialogPlayers(_ID,_Player,_TargetDBIndex).
		//     If not specified, defaults to 1 (first NPC/player in dialog)
		//      ** NOTE: this index is an index in DB_DialogNPCs resp. DB_DialogPlayers, and hence is unrelated to the
		//               the speaker indices in the dialog editor!
		//
		//  If someone does not have enough gold and a transfer is requested, all of their gold will be transferred instead.
		
		//REGION Default speaker to check and target Player/NPC for the money transfer if unspecified
		PROC
		Proc_ItemEvents_DialogMoneyTransfer_New((INTEGER)_MoneyVarIndex,(STRING)_Dialog,(INTEGER)_Amount,(INTEGER)_CheckSpeakerIndex,(INTEGER)_TargetDBIndex)
		AND
		DB_DialogMoneyTransfer(_MoneyVarIndex,_Dialog,_AnyAmount,_AnyCheckSpeakerIndex,_AnyTargetDBIndex)
		THEN
		NOT DB_DialogMoneyTransfer(_MoneyVarIndex,_Dialog,_AnyAmount,_AnyCheckSpeakerIndex,_AnyTargetDBIndex);
		
		PROC
		Proc_ItemEvents_DialogMoneyTransfer_New((INTEGER)_MoneyVarIndex,(STRING)_Dialog,(INTEGER)_Amount,(INTEGER)_CheckSpeakerIndex,(INTEGER)_TargetDBIndex)
		THEN
		DB_DialogMoneyTransfer(_MoneyVarIndex,_Dialog,_Amount,_CheckSpeakerIndex,_TargetDBIndex);
		
		// Default to most common player speaker index (2) and transfer to the first NPC or Player in the dialog (1)
		IF
		DB_DialogMoneyTransfer((INTEGER)_MoneyVarIndex,(STRING)_Dialog,(INTEGER)_Amount)
		THEN
		Proc_ItemEvents_DialogMoneyTransfer_New(_MoneyVarIndex,_Dialog,_Amount,2,1);
		
		IF
		DB_DialogMoneyTransfer((INTEGER)_MoneyVarIndex,(STRING)_Dialog,(INTEGER)_Amount,(INTEGER)_CheckSpeakerIndex)
		THEN
		Proc_ItemEvents_DialogMoneyTransfer_New(_MoneyVarIndex,_Dialog,_Amount,_CheckSpeakerIndex,1);
		//END_REGION
		
		//REGION Transfer gold between player and NPC
		// If the transfer flag is set on a player, transfer from player to NPC. Otherwise vice versa.
		IF
		ObjectFlagSet(_TransferMoneyInDialogEvent,_Source,_ID)
		AND
		DB_ItemEvents_TransferFlagToMoneyVarIndex(_TransferMoneyInDialogEvent,_MoneyVarIndex)
		AND
		DB_DialogName(_Dialog,_ID)
		AND
		DB_DialogMoneyTransfer(_MoneyVarIndex,_Dialog,_Amount,_CheckSpeakerIndex,_TargetDBIndex)
		THEN
		Proc_TransferMoneyInDialog(_ID,_Amount,(CHARACTERGUID)_Source,_TargetDBIndex);
		
		//Player -> NPC
		PROC
		Proc_TransferMoneyInDialog((INTEGER)_ID,(INTEGER)_Amount,(CHARACTERGUID)_Source,(INTEGER)_TargetIndex)
		AND
		DB_DialogPlayers(_ID,_Source,_)
		AND
		DB_DialogNPCs(_ID,_NPC,_TargetIndex)
		AND
		QryEvaluateMagicPocketGold((CHARACTERGUID)_Source,">=",_Amount)
		AND
		IntegerSubtract(0,_Amount,_RemoveGold)
		THEN
		ProcAddGoldToMagicPockets(_Source,_RemoveGold);
		CharacterAddGold((CHARACTERGUID)_NPC,_Amount);
		DB_TransferMoneyInDialog_Succeeded(1);
		
		//NPC -> Player
		PROC
		Proc_TransferMoneyInDialog(_ID,_Amount,_Source,_TargetIndex)
		AND
		DB_DialogNPCs(_ID,_Source,_)
		AND
		DB_DialogPlayers(_ID,_Player,_TargetIndex)
		AND
		CharacterGetGold(_Source,_NPCGold)
		AND
		_Amount <= _NPCGold
		AND
		IntegerSubtract(0,_Amount,_RemoveGold)
		THEN
		ProcAddGoldToMagicPockets((CHARACTERGUID)_Player,_Amount);
		CharacterAddGold(_Source,_RemoveGold);
		DB_TransferMoneyInDialog_Succeeded(1);
		
		//END_REGION
		
		//REGION Reset transfer flag
		//Throw assert if transfer failed (not enough money, database not defined,...)
		IF
		ObjectFlagSet(_TransferMoneyInDialogEvent,_Source,_ID)
		AND
		DB_ItemEvents_TransferFlagToMoneyVarIndex(_TransferMoneyInDialogEvent,_)
		AND
		NOT DB_TransferMoneyInDialog_Succeeded(1)
		AND
		DB_DialogName(_Dialog,_ID)
		AND
		StringConcatenate("GEN_TransferNPCPayment failed for: ",_Dialog,_ErrorMessage)
		THEN
		DebugBreak(_ErrorMessage);
		
		//Reset everything
		IF
		ObjectFlagSet(_TransferMoneyInDialogEvent,_Source,_ID)
		AND
		DB_ItemEvents_TransferFlagToMoneyVarIndex(_TransferMoneyInDialogEvent,_)
		THEN
		NOT DB_TransferMoneyInDialog_Succeeded(1);
		ObjectClearFlag(_Source,_TransferMoneyInDialogEvent);
		//END_REGION
		
		//END_REGION
		
		//REGION Has, lose and give items
		IF
		ItemAddedToCharacter(_Item,_Char)
		AND
		DB_HasStoryEvent((ITEMGUID)_Item,_Event)
		THEN
		SetOnStage(_Item,1);
		ProcSetMagicPocketsOwnershipFlag(_Char,_Event);
		
		IF
		ItemRemovedFromCharacter(_Item,_Char)
		AND
		DB_HasStoryEvent((ITEMGUID)_Item,_Event)
		THEN
		ProcClearMagicPocketsOwnershipFlag(_Char,_Event);
		
		IF
		DB_HasStoryEvent((ITEMGUID)_Item,(STRING)_Event)
		AND
		ItemGetOwner(_Item,_Owner)
		AND
		_Owner != NULL_00000000-0000-0000-0000-000000000000
		AND
		ItemIsInCharacterInventory(_Item,_Owner,1)
		THEN
		ProcSetMagicPocketsOwnershipFlag(_Owner,_Event);
		
		IF
		ObjectFlagSet(_Event,_Char,_)
		AND
		DB_GiveItemToEvent((ITEMGUID)_Item,_Event)
		THEN
		ItemToInventory(_Item,_Char,1);
		
		//For giving the same item multiple times
		IF
		ObjectFlagSet(_Event,_Char,_)
		AND
		DB_GiveItemToEventWithClear((ITEMGUID)_Item,_Event)
		THEN
		ItemToInventory(_Item,_Char,1);
		ObjectClearFlag(_Char,_Event,0);
		
		PROC
		Proc_ItemEventCheck()
		AND
		DB_HasStoryEvent(_,_Event)
		THEN
		PROC_ClearHasStoryEvent(_Event);
		
		PROC
		PROC_ClearHasStoryEvent((STRING)_Event)
		AND
		DB_ProcessedUser(_User)
		THEN
		NOT DB_ProcessedUser(_User);
		
		PROC
		PROC_ClearHasStoryEvent((STRING)_Event)
		AND
		DB_IsPlayer(_Char)
		AND
		CharacterGetReservedUserID(_Char,_User)
		AND
		NOT DB_ProcessedUser(_User)
		THEN
		DB_ProcessedUser(_User);
		ProcClearMagicPocketsOwnershipFlag(_Char,_Event);
		
		PROC
		Proc_ItemEventCheck()
		AND
		DB_HasStoryEvent((ITEMGUID)_Item,_Event)
		AND
		ObjectExists(_Item,1)
		AND
		ItemIsInInventory(_Item,1)
		AND
		ItemGetOwner(_Item,_Char)
		AND
		DB_IsPlayer(_Char)
		THEN
		ProcSetMagicPocketsOwnershipFlag(_Char,_Event);
		
		//END_REGION
		
		//REGION Items that have flag when equipped (per-character flag)
		
		IF
		ItemEquipped(_Item,_Char)
		AND
		DB_SetStoryFlagWhenEquipped((ITEMGUID)_Item,(STRING)_Event)
		THEN
		ObjectSetFlag(_Char,_Event);
		
		IF
		ItemUnEquipped(_Item,_Char)
		AND
		DB_SetStoryFlagWhenEquipped((ITEMGUID)_Item,(STRING)_Event)
		THEN
		ObjectClearFlag(_Char,_Event);
		
		//END_REGION
		
		//REGION Check for Tagged Items in Characters Inventory
		//If You want to Keep track of a specific Item tag going in and out of the inventory, add that tag to DB_TaggedItemTracker(_String)
		
		IF
		ItemAddedToCharacter(_Item,_Char)
		AND
		ObjectExists(_Item,1)		//prevent stacked items from asserting all over the place
		AND
		DB_TaggedItemTracker((STRING)_Tag)
		AND
		IsTagged(_Item,_Tag,1)
		AND
		StringConcatenate("Has_TaggedItem_",_Tag,_Flag)
		THEN
		ProcSetMagicPocketsOwnershipFlag(_Char,_Flag);
		DB_HasTaggedItem(_Char,_Item,_Tag,_Flag);
		
		IF
		DB_TaggedItemInitialSetup(1)
		THEN
		DB_TaggedItemRecheck(1);
		
		IF
		DB_TaggedItemRecheck(1)
		AND
		NOT DB_TaggedItemInitialSetup(1)
		THEN
		NOT DB_TaggedItemRecheck(1);
		ProcCheckItemTags();
		
		PROC
		ProcCheckItemTags()
		AND
		DB_IsPlayer(_Player)
		AND
		DB_TaggedItemTracker(_Tag)
		THEN
		DB_ItemTagCheckingPlayer((CHARACTERGUID)_Player,_Tag);
		InventoryLaunchTagIterator(_Player,_Tag,"","_Check_Item_Tags_","");
		FireOsirisEvents();
		NOT DB_ItemTagCheckingPlayer(_Player,_Tag);
		
		IF
		StoryEvent((ITEMGUID)_Item,"_Check_Item_Tags_")
		AND
		DB_ItemTagCheckingPlayer(_Player,_Tag)
		AND
		StringConcatenate("Has_TaggedItem_",_Tag,_Flag)
		THEN
		ProcSetMagicPocketsOwnershipFlag(_Player,_Flag);
		DB_HasTaggedItem(_Player,_Item,_Tag,_Flag);
		
		IF
		DB_TaggedItemTracker(_Tag)
		AND
		NOT DB_TaggedItemInitialSetup(1)
		THEN
		ProcCheckInventoriesForTag(_Tag);
		
		PROC
		ProcCheckInventoriesForTag((STRING)_Tag)
		AND
		DB_IsPlayer(_Player)
		THEN
		DB_ItemTagCheckingPlayer(_Player,_Tag);
		InventoryLaunchTagIterator(_Player,_Tag,"","_Check_Item_Tag_","");
		FireOsirisEvents();
		NOT DB_ItemTagCheckingPlayer(_Player,_Tag);
		
		IF
		StoryEvent((ITEMGUID)_Item, "_Check_Item_Tag_")
		AND
		DB_ItemTagCheckingPlayer(_Char,_Tag)
		AND
		StringConcatenate("Has_TaggedItem_",_Tag,_Flag)
		THEN
		ProcSetMagicPocketsOwnershipFlag(_Char,_Flag);
		DB_HasTaggedItem(_Char,_Item,_Tag,_Flag);
		
		
		IF
		ItemStackedWith(_Item,_)
		AND
		DB_HasTaggedItem(_Char,_Item,_String,_Flag)
		THEN
		NOT DB_HasTaggedItem(_Char,_Item,_String,_Flag);
		
		IF
		ItemRemovedFromCharacter(_Item,_Char)
		AND
		DB_HasTaggedItem((CHARACTERGUID)_Char,_Item,_String,_Flag)
		THEN
		NOT DB_HasTaggedItem(_Char,_Item,_String,_Flag);
		Proc_CheckForItemTagInMagicPockets(_Char,_String);
		
		PROC
		Proc_CheckForItemTagInMagicPockets((CHARACTERGUID)_Char,(STRING)_Tag)
		AND
		NOT QryTaggedItemInMagicPockets(_Char,_Tag)
		AND
		StringConcatenate("Has_TaggedItem_",_Tag,_Flag)
		THEN
		ProcClearMagicPocketsOwnershipFlag(_Char,_Flag);
		
		PROC
		Proc_ItemEventCheck()
		AND
		DB_TaggedItemTracker((STRING)_Tag)
		AND
		StringConcatenate("Has_TaggedItem_",_Tag,_Flag)
		AND
		DB_IsPlayer(_Char)
		THEN
		ProcClearMagicPocketsOwnershipFlag(_Char,_Flag);
		
		IF
		RegionStarted(_)
		AND
		DB_HasTaggedItem(_Char,_Item,_Tag,_Flag)
		AND
		ObjectExists(_Char,0)
		THEN
		NOT DB_HasTaggedItem(_Char,_Item,_Tag,_Flag);
		
		PROC
		Proc_ItemEventCheck()
		AND
		DB_HasTaggedItem(_Char,_Item,_Tag,_Flag)
		THEN
		ProcSetMagicPocketsOwnershipFlag(_Char,_Flag);
		
		//END_REGION
		
		//REGION On item template on gain and lose
		//DB_HasTemplateItem((STRING)_template,(STRING)_HasItemFlag)
		//If item is added to inventory
		IF
		ItemTemplateAddedToCharacter(_templateGUID,_item,_char)
		AND
		String(_templateGUID,_template)
		AND
		DB_HasTemplateItem((STRING)_template,(STRING)_flag)
		THEN
		Proc_OnAddItemTemplateToChar(_char,_template,_flag);
		
		//If item is removed from inventory
		IF
		ItemTemplateRemovedFromCharacter(_template,_item,_char)
		AND
		DB_HasTemplateItem((STRING)_template,(STRING)_flag)
		THEN
		Proc_OnRemoveItemTemplateFromChar(_char,_template,_flag);
		
		IF
		DB_HasTemplateItem((STRING)_template,(STRING)_flag)
		AND
		DB_IsPlayer(_Player)
		THEN
		Proc_OnAddItemTemplateToChar(_Player,_template,_flag);
		
		PROC
		Proc_ItemEventCheck()
		AND
		DB_HasTemplateItem((STRING)_template,(STRING)_flag)
		THEN
		PROC_SetTemplateOwnerShipFlag(_template,_flag);
		
		PROC
		PROC_SetTemplateOwnerShipFlag((STRING)_,(STRING)_)
		AND
		DB_CheckedUser(_User)
		THEN
		NOT DB_CheckedUser(_User);
		
		PROC
		PROC_SetTemplateOwnerShipFlag((STRING)_template,(STRING)_flag)
		AND
		DB_IsPlayer(_Player)
		AND
		CharacterGetReservedUserID(_Player,_User)
		AND
		NOT DB_CheckedUser(_User)
		THEN
		DB_CheckedUser(_User);
		ProcClearMagicPocketsOwnershipFlag(_Player,_flag);
		Proc_OnAddItemTemplateToChar(_Player,_template,_flag);
		
		//Proc on template add
		PROC
		Proc_OnAddItemTemplateToChar((CHARACTERGUID)_char,(STRING)_template,(STRING)_flag)
		AND
		ItemTemplateIsInUserInventory(_char,_template,0,_amount)
		AND
		_amount > 0
		THEN
		ProcSetMagicPocketsOwnershipFlag(_char,_flag);
		
		//Proc on template remove
		PROC
		Proc_OnRemoveItemTemplateFromChar((CHARACTERGUID)_char,(STRING)_template,(STRING)_flag)
		AND
		ItemTemplateIsInUserInventory(_char,_template,0,_amount)
		AND
		_amount < 1
		THEN
		ProcClearMagicPocketsOwnershipFlag(_char,_flag);
		
		//END_REGION
		
		//REGION Have item template check via scriptflag
		PROC
		Proc_ItemEvents_ItemTemplateScriptFlag_New((INTEGER)_TemplateVarIndex,(STRING)_Dialog,(STRING)_ItemTemplate, (INTEGER)_SpeakerIndex, (INTEGER)_Amount)
		AND
		DB_HasItemTemplateScriptFlag(_TemplateVarIndex, _Dialog, _AnyItemTemplate, _AnySpeakerIndex, _AnyAmount)
		AND
		_AnyItemTemplate != _ItemTemplate
		THEN
		NOT DB_HasItemTemplateScriptFlag(_TemplateVarIndex, _Dialog, _AnyItemTemplate, _AnySpeakerIndex, _AnyAmount);
		
		PROC
		Proc_ItemEvents_ItemTemplateScriptFlag_New((INTEGER)_TemplateVarIndex,(STRING)_Dialog,(STRING)_ItemTemplate, (INTEGER)_SpeakerIndex, (INTEGER)_Amount)
		AND
		DB_HasItemTemplateScriptFlag(_TemplateVarIndex, _Dialog, _AnyItemTemplate, _AnySpeakerIndex, _AnyAmount)
		AND
		_AnySpeakerIndex != _SpeakerIndex
		THEN
		NOT DB_HasItemTemplateScriptFlag(_TemplateVarIndex, _Dialog, _AnyItemTemplate, _AnySpeakerIndex, _AnyAmount);
		
		PROC
		Proc_ItemEvents_ItemTemplateScriptFlag_New((INTEGER)_TemplateVarIndex,(STRING)_Dialog,(STRING)_ItemTemplate, (INTEGER)_SpeakerIndex, (INTEGER)_Amount)
		AND
		DB_HasItemTemplateScriptFlag(_TemplateVarIndex, _Dialog, _AnyItemTemplate, _AnySpeakerIndex, _AnyAmount)
		AND
		_AnyAmount != _Amount
		THEN
		NOT DB_HasItemTemplateScriptFlag(_TemplateVarIndex, _Dialog, _AnyItemTemplate, _AnySpeakerIndex, _AnyAmount);
		
		PROC
		Proc_ItemEvents_ItemTemplateScriptFlag_New((INTEGER)_TemplateVarIndex,(STRING)_Dialog,(STRING)_ItemTemplate, (INTEGER)_SpeakerIndex, (INTEGER)_Amount)
		THEN
		DB_HasItemTemplateScriptFlag(_TemplateVarIndex, _Dialog, _ItemTemplate, _SpeakerIndex, _Amount);
		
		// Default to one item
		IF
		DB_HasItemTemplateScriptFlag((INTEGER)_TemplateVarIndex, (STRING)_Dialog, (STRING)_ItemTemplate, (INTEGER)_SpeakerIndex)
		THEN
		Proc_ItemEvents_ItemTemplateScriptFlag_New(_TemplateVarIndex, _Dialog, _ItemTemplate, _SpeakerIndex, 1);
		
		IF
		DB_HasItemTemplateScriptFlag((INTEGER)_TemplateVarIndex, (STRING)_Dialog, (STRING)_ItemTemplate, (INTEGER)_SpeakerIndex, (INTEGER)_Amount)
		THEN
		Proc_ItemEvents_ItemTemplateScriptFlag_New(_TemplateVarIndex, _Dialog, _ItemTemplate, _SpeakerIndex, _Amount);
		
		//END_REGION
		
		//REGION Give/remove Item template
		//Gives item when flag is set
		IF
		ObjectFlagSet(_event,(CHARACTERGUID)_target,_inst)
		AND
		DB_GiveTemplateFromPlayerDialogEvent((STRING)_template,(STRING)_event,(STRING)_success)
		AND
		DialogGetInvolvedPlayer(_inst, 1, (CHARACTERGUID)_player)
		THEN
		ObjectClearFlag(_target,_event,0); //Flag is cleared again
		Proc_PlayerGivesItemFromTemplate(_player,_target,_template,_success);
		
		
		//Gives item when flag is set
		IF
		ObjectFlagSet(_event,(CHARACTERGUID)_target,_inst)
		AND
		DB_GiveTemplateFromNpcToPlayerDialogEvent((STRING)_template,(STRING)_event,(STRING)_success)
		AND
		DialogGetInvolvedPlayer(_inst, 1, (CHARACTERGUID)_player)
		THEN
		ObjectClearFlag(_target,_event,0); //Flag is cleared again
		Proc_NPCGivesItemFromTemplate(_target,_player,_template,_success);
		
		
		//Gives item when flag is set
		IF
		ObjectFlagSet(_event,_char,_)
		AND
		DB_GiveNewItemFromTemplateEvent((STRING)_template,(STRING)_event)
		THEN
		ObjectClearFlag((CHARACTERGUID)_char,(STRING)_event,0); //Flag is cleared again
		ItemTemplateAddTo(_template,_char,1);
		
		
		//Remove item when flag set
		IF
		ObjectFlagSet(_event,(CHARACTERGUID)_char,_)
		AND
		DB_RemoveItemFromTemplateEvent((STRING)_template,(STRING)_event,(STRING)_success)
		AND
		NOT DB_RemoveItemFromTemplate_InProgress(_event)
		THEN
		DB_RemoveItemFromTemplate_InProgress(_event);
		ObjectClearFlag(_char,_event,0); //Flag is cleared again
		Proc_RemoveItemFromTemplate(_char,_template,_success);
		
		IF
		ObjectFlagSet(_event,(CHARACTERGUID)_char,_)
		AND
		DB_RemoveItemFromTemplateEvent((STRING)_template,(STRING)_event,(STRING)_success)
		AND
		DB_RemoveItemFromTemplate_InProgress(_event)
		THEN
		NOT DB_RemoveItemFromTemplate_InProgress(_event);
		
		//END_REGION
		
		//REGION Give/Remove Template Proc
		//Giving Item
		PROC
		Proc_PlayerGivesItemFromTemplate((CHARACTERGUID)_Player,(CHARACTERGUID)_target,(STRING)_template,(STRING)_success)
		AND
		QryRemoveItemTemplateFromMagicPockets(_Player,_Template,1)
		THEN
		ItemTemplateAddTo(_template,_target,1);
		ObjectSetFlag(_target,_success);
		
		//Mirrored Give to set _success on NPC instead of player
		PROC
		Proc_NPCGivesItemFromTemplate((CHARACTERGUID)_giver,(CHARACTERGUID)_target,(STRING)_template,(STRING)_success)
		AND
		ItemTemplateIsInCharacterInventory(_giver,_template,_amount)
		AND
		_amount > 0
		THEN
		ItemTemplateRemoveFrom(_template,_giver,1);
		ItemTemplateAddTo(_template,_target,1);
		ObjectSetFlag(_giver,_success);
		
		//Remove Item
		PROC
		Proc_RemoveItemFromTemplate((CHARACTERGUID)_char,(STRING)_template,(STRING)_success)
		AND
		DB_IsPlayer(_Char)
		AND
		QryRemoveItemTemplateFromMagicPockets(_char,_template,1)
		THEN
		ObjectSetFlag(_char,_success);
		
		PROC
		Proc_RemoveItemFromTemplate((CHARACTERGUID)_char,(STRING)_template,(STRING)_success)
		AND
		NOT DB_IsPlayer(_Char)
		AND
		ItemTemplateIsInCharacterInventory(_char,_template,_amount)
		AND
		_amount > 0
		THEN
		ItemTemplateRemoveFrom(_template,_char,1);
		ObjectSetFlag(_char,_success);
		//END_REGION
		
		IF
		DialogEnded(_,_ID)
		AND
		DialogGetInvolvedNPC(_ID,1,(ITEMGUID)_Item)
		AND
		ObjectIsItem(_Item,1)
		AND
		ObjectGetFlag(_Item,"ItemPickup",1)
		AND
		DialogGetInvolvedPlayer(_ID,1,(CHARACTERGUID)_Player)
		THEN
		CharacterPickupItem(_Player,_Item,"");
		ObjectClearFlag(_Item,"ItemPickup",0);
		
		//REGION Play Activate animation from Script
		
		IF
		StoryEvent((CHARACTERGUID)_Player,"GEN_Animation_Activate")
		THEN
		PlayAnimation(_Player,"use_activate");
		
		//END_REGION
		
		
		
	}
	EXIT
	{
		
	}
}
Goal(31).Title("_Global_JournalHelper");
Goal(31)
{
	INIT
	{
		
	}
	KB
	{
		//REGION Init
		
		PROC
		ProcCheckDefaultQuestAdd((STRING)_QuestName)
		AND
		NOT DB_QuestDef_AddEvent(_QuestName,_)
		AND
		StringConcatenate("QuestAdd_",_QuestName,_AddEvent)
		THEN
		DB_QuestDef_AddEvent(_QuestName,_AddEvent);
		
		PROC
		ProcCheckDefaultQuestClose((STRING)_QuestName)
		AND
		NOT DB_QuestDef_CloseEvent(_QuestName,_)
		AND
		StringConcatenate("QuestClose_",_QuestName,_CloseEvent)
		THEN
		DB_QuestDef_CloseEvent(_QuestName,_CloseEvent);
		
		IF
		DB_QuestDef_State((STRING)_QuestName,(STRING)_QuestState, 1) //Indices allow you to define multiple start and end events for every quest.
		AND
		StringConcatenate("QuestUpdate_",_QuestName,_String1)
		AND
		StringConcatenate(_String1,"_",_String2)
		AND
		StringConcatenate(_String2,_QuestState,_AddEvent)
		THEN
		DB_QuestDef_AddEvent(_QuestName,_AddEvent);
		DB_QuestDef_State((STRING)_QuestName,(STRING)_QuestState);
		
		IF
		DB_QuestDef_State((STRING)_QuestName,(STRING)_QuestState, -1)
		AND
		StringConcatenate("QuestUpdate_",_QuestName,_String1)
		AND
		StringConcatenate(_String1,"_",_String2)
		AND
		StringConcatenate(_String2,_QuestState,_CloseEvent)
		THEN
		DB_QuestDef_CloseEvent(_QuestName,_CloseEvent);
		DB_QuestDef_State((STRING)_QuestName,(STRING)_QuestState);
		
		IF
		DB_QuestDef_State((STRING)_QuestName,(STRING)_QuestState)
		AND
		NOT DB_QuestDef_UpdateEvent(_QuestName,_QuestState, _)
		AND
		StringConcatenate("QuestUpdate_",_QuestName,_String1)
		AND
		StringConcatenate(_String1,"_",_String2)
		AND
		StringConcatenate(_String2,_QuestState,_UpdateEvent)
		THEN
		ProcCheckDefaultQuestAdd(_QuestName);
		ProcCheckDefaultQuestClose(_QuestName);
		DB_QuestDef_UpdateEvent(_QuestName,_QuestState,_UpdateEvent);
		//END_REGION
		
		//REGION Unlocking quests
		IF
		ObjectFlagSet(_QuestAddEvent,(CHARACTERGUID)_Player, _)
		AND
		DB_QuestDef_AddEvent(_QuestName,_QuestAddEvent)
		AND
		DB_IsPlayer(_Player)
		THEN
		QuestAdd(_Player,_QuestName);
		DB_ActivatedQuests(_QuestName);
		ProcSetQuestNPCFlag(_QuestName,_QuestAddEvent);
		ProcCheckMigrateQuestAddFlag(_Player,_QuestName,_QuestAddEvent);
		
		//don't migrate quest add flags that also trigger an update, since we'll be trying ot share the update already before the original player
		//had a chance to get the update
		PROC
		ProcCheckMigrateQuestAddFlag((CHARACTERGUID)_Player,(STRING)_QuestName,(STRING)_QuestAddEvent)
		AND
		NOT DB_QuestDef_UpdateEvent(_QuestName,_,_QuestAddEvent)
		THEN
		ProcMigrateQuestFlag(_Player,_QuestName,_QuestAddEvent);
		
		IF
		ObjectFlagSet(_QuestUpdateEvent,(CHARACTERGUID)_Player, _)
		AND
		DB_QuestDef_UpdateEvent(_QuestName,_QuestState,_QuestUpdateEvent)
		AND
		DB_IsPlayer(_Player)
		AND
		QuestIsClosed(_Player,_QuestName,0)
		THEN
		QuestUpdate(_Player,_QuestName,_QuestState);
		ProcActivateMystery(_QuestName,_QuestState);
		ProcMigrateQuestFlag(_Player,_QuestName,_QuestUpdateEvent);
		ProcSetQuestNPCFlag(_QuestName,_QuestUpdateEvent);
		
		PROC
		ProcActivateMystery((STRING)_QuestName,(STRING)_QuestState)
		AND
		DB_Mystery(_QuestName)
		THEN
		DB_ActivatedQuests(_QuestName);
		
		IF
		ObjectFlagSet(_QuestCloseEvent,(CHARACTERGUID)_Player, _)
		AND
		DB_QuestDef_CloseEvent(_QuestName,_QuestCloseEvent)
		AND
		DB_IsPlayer(_Player)
		THEN
		QuestClose(_Player,_QuestName);
		ProcMigrateQuestFlag(_Player,_QuestName,_QuestCloseEvent);
		ProcSetQuestNPCFlag(_QuestName,_QuestCloseEvent);
		
		PROC
		ProcSetQuestNPCFlag((STRING)_QuestName,(STRING)_QuestEvent)
		AND
		DB_QuestNPC(_QuestName,(CHARACTERGUID)_NPC)
		THEN
		ObjectSetFlag(_NPC,_QuestEvent,0);
		
		
		//END_REGION
		
		//REGION Merging quests
		
		IF
		CharacterMadePlayer(_Player)
		THEN
		DB_JournalIgnoreReservedChanged(_Player);
		
		IF
		CharacterReservedUserIDChanged(_Char,_,_NewUser)
		AND
		DB_IsPlayer(_Char)
		AND
		NOT DB_JournalIgnoreReservedChanged(_Char)
		THEN
		ProcMigrateQuestsForUser(_NewUser,_Char);
		
		IF
		CharacterReservedUserIDChanged(_Char,_,_)
		THEN
		NOT DB_JournalIgnoreReservedChanged(_Char);
		
		IF
		CharacterJoinedParty(_Joiner)
		AND
		DB_IsPlayer(_Joiner)
		AND
		DB_ActivatedQuests(_Quest)
		THEN
		ProcMigrateQuest(_Joiner,_Quest);
		
		IF
		CharacterJoinedParty(_Joiner)
		AND
		DB_IsPlayer(_Joiner)
		THEN
		ProcShareQuestsWithParty(_Joiner);
		
		PROC
		ProcShareQuestsWithParty((CHARACTERGUID)_Joiner)
		AND
		DB_IsPlayer(_Player)
		AND
		NOT DB_MigratedNewPartyFlags(1)
		AND
		_Player != _Joiner
		AND
		CharacterIsInPartyWith(_Player,_Joiner,1)
		AND
		DB_ActivatedQuests(_Quest)
		AND
		DB_SharedQuestFlag(_Player,_Quest,_QuestFlag)
		THEN
		DB_MigratedNewPartyFlags(1);
		ProcShareQuestflagWith(_Player,_Quest,_QuestFlag,_Joiner);
		
		PROC
		ProcShareQuestsWithParty(_Joiner)
		AND
		DB_SharedQuestlessFlag((STRING)_Flag)
		AND
		PartyGetFlag(_Joiner, _Flag, 1)
		THEN
		PartySetFlag(_Joiner, _Flag);
		
		PROC
		ProcShareQuestsWithParty(_Joiner)
		AND
		DB_SharedQuestlessUserFlag((STRING)_Flag)
		AND
		UserGetFlag(_Joiner, _Flag, 1)
		THEN
		UserSetFlag(_Joiner, _Flag);
		
		PROC
		ProcShareQuestsWithParty((CHARACTERGUID)_Joiner)
		THEN
		NOT DB_MigratedNewPartyFlags(1);
		
		//always share quests with the owning user
		IF
		CharacterJoinedParty(_Joiner)
		AND
		DB_IsPlayer(_Joiner)
		AND
		CharacterGetReservedUserID(_Joiner,_User)
		THEN
		ProcMigrateQuestsForUser(_User,_Joiner);
		
		//handle the case where an MP savegame is loaded in SP
		IF
		SavegameLoaded(_,_,_,_)
		AND
		DB_IsPlayer(_Joiner)
		AND
		CharacterGetReservedUserID(_Joiner,_User)
		THEN
		ProcMigrateQuestsForUser(_User,_Joiner);
		ProcShareQuestsWithParty(_Joiner);
		
		PROC
		ProcMigrateQuestsForUser((INTEGER)_User,(CHARACTERGUID)_Joiner)
		AND
		DB_IsPlayer(_Other)
		AND
		CharacterGetReservedUserID(_Other,_User)
		AND
		DB_ActivatedQuests(_Quest)
		AND
		QuestGetBroadcastLevel(_Quest,_Level)
		AND
		_Level != "Character"
		AND
		DB_PrivateQuestFlag(_Other,_Quest,_QuestFlag)
		THEN
		ProcShareQuestflagWith(_Other,_Quest,_QuestFlag,_Joiner);
		
		IF
		QuestShared(_SrcCharacter,"",1)
		AND
		DB_IsPlayer(_SrcCharacter)
		AND
		DB_ActivatedQuests(_Quest)
		THEN
		ProcMigrateQuest(_SrcCharacter,_Quest);
		
		IF
		QuestShared(_SrcCharacter,_Quest,1)
		AND
		_Quest != ""
		THEN
		ProcMigrateQuestFlagsFor(_SrcCharacter,_Quest);
		
		PROC
		ProcMigrateQuest((CHARACTERGUID)_SrcPlayer,(STRING)_Quest)
		AND
		QuestAccepted(_SrcPlayer,_Quest,1)
		AND
		QuestIsShared(_SrcPlayer,_Quest,1)
		THEN
		ProcMigrateQuestFlagsFor(_SrcPlayer,_Quest);
		
		PROC
		ProcMigrateQuestFlagsFor((CHARACTERGUID)_SrcPlayer,(STRING)_Quest)
		AND
		DB_PrivateQuestFlag(_SrcPlayer,_Quest,_QuestFlag)
		THEN
		DB_SharedQuestFlag(_SrcPlayer,_Quest,_QuestFlag);
		NOT DB_PrivateQuestFlag(_SrcPlayer,_Quest,_QuestFlag);
		
		PROC
		ProcMigrateQuestFlagsFor((CHARACTERGUID)_SrcChar,(STRING)_Quest)
		AND
		DB_SharedQuestFlag(_SrcChar,_Quest,_QuestFlag)
		THEN
		ProcShareQuestFlag(_SrcChar,_Quest,_QuestFlag);
		
		PROC
		ProcShareQuestFlag((CHARACTERGUID)_SrcPlayer,(STRING)_Quest,(STRING)_QuestFlag)
		AND
		DB_IsPlayer(_Player)
		AND
		_Player!=_SrcPlayer
		AND
		CharacterIsInPartyWith(_Player,_SrcPlayer,1)
		AND			
		ObjectGetFlag(_Player,_QuestFlag,0)	//checked for when story gives the flag to several players in a row. Otherwise you won't have a chance to give the update in case someone shares the quest
		THEN
		ProcShareQuestflagWith(_SrcPlayer,_Quest,_QuestFlag,_Player);
		
		PROC
		ProcShareQuestflagWith((CHARACTERGUID)_SrcPlayer,(STRING)_Quest,(STRING)_QuestFlag,(CHARACTERGUID)_Player)
		THEN
		ProcStoreFlagState(_Player,_QuestFlag);
		ProcShareQuestUpdate(_SrcPlayer,_Quest,_QuestFlag,_Player);
		ObjectShareFlag(_Player,_QuestFlag);
		ProcStoreSharedQuestFlag(_SrcPlayer,_Quest,_QuestFlag,_Player);
		ProcVerifyFlagState(_SrcPlayer,_Player,_QuestFlag);
		
		PROC
		ProcStoreSharedQuestFlag((CHARACTERGUID)_SrcPlayer,(STRING)_Quest,(STRING)_QuestFlag,(CHARACTERGUID)_Player)
		AND
		DB_SharedQuestFlag(_SrcPlayer,_Quest,_QuestFlag)
		THEN
		DB_SharedQuestFlag(_Player,_Quest,_QuestFlag);
		
		PROC
		ProcStoreSharedQuestFlag((CHARACTERGUID)_SrcPlayer,(STRING)_Quest,(STRING)_QuestFlag,(CHARACTERGUID)_Player)
		AND
		DB_PrivateQuestFlag(_SrcPlayer,_Quest,_QuestFlag)
		THEN
		DB_PrivateQuestFlag(_Player,_Quest,_QuestFlag);
		
		PROC
		ProcShareQuestUpdate((CHARACTERGUID)_SrcPlayer,(STRING)_Quest,(STRING)_QuestFlag,(CHARACTERGUID)_Player)
		AND
		QRY_ShouldShareQuest(_SrcPlayer,_Player,_Quest)
		THEN
		ProcActivateSharedQuest(_Player,_Quest);
		ProcMigrateQuestFlagsFor(_Player,_Quest);
		
		IF
		MysteryUnlocked(_SrcPlayer,_Mystery)
		AND
		DB_MysterPrefixed(_Entry,_Mystery)
		THEN
		DB_MyseryUnlocked(_SrcPlayer,_Entry);
		
		//thank you code for prefixing these
		IF
		DB_Mystery((STRING)_Entry)
		AND
		StringConcatenate("MST_",_Entry,_PrefixedMyst)
		THEN
		DB_MysterPrefixed(_Entry,_PrefixedMyst);
		
		//always share mystery related updates
		QRY
		QRY_ShouldShareQuest((CHARACTERGUID)_SrcPlayer,(CHARACTERGUID)_Player,(STRING)_Quest)
		AND
		DB_Mystery(_Quest)
		AND
		NOT DB_MyseryUnlocked(_Player,_Quest)
		THEN
		DB_MyseryUnlocked(_Player,_Quest);	//for existing saves
		DB_Noop(1);
		
		QRY
		QRY_ShouldShareQuest((CHARACTERGUID)_SrcPlayer,(CHARACTERGUID)_Player,(STRING)_Quest)
		AND
		NOT DB_Mystery(_Quest)
		AND
		QuestAccepted(_SrcPlayer,_Quest,1)
		AND
		QuestAccepted(_Player,_Quest,0)
		THEN
		DB_Noop(1);
		
		PROC
		ProcActivateSharedQuest((CHARACTERGUID)_Player,(STRING)_Quest)
		AND
		NOT DB_Mystery(_Quest)
		THEN
		QuestAdd(_Player,_Quest);
		
		PROC
		ProcShareQuestUpdate((CHARACTERGUID)_SrcPlayer,(STRING)_Quest,(STRING)_QuestFlag,(CHARACTERGUID)_Player)
		AND
		DB_QuestDef_UpdateEvent(_Quest,_QuestState,_QuestFlag)
		AND
		QRY_CanShareUpdate(_SrcPlayer,_Quest,_QuestState)
		THEN
		QuestReceiveSharedUpdate(_SrcPlayer,_Player,_Quest,_QuestState);
		
		QRY
		QRY_CanShareUpdate((CHARACTERGUID)_SrcPlayer,(STRING)_Quest,(STRING)_QuestState)
		AND
		DB_Mystery(_Quest)
		THEN
		DB_Noop(1);
		
		QRY
		QRY_CanShareUpdate((CHARACTERGUID)_SrcPlayer,(STRING)_Quest,(STRING)_QuestState)
		AND
		NOT DB_Mystery(_Quest)
		AND
		QuestHasUpdate(_SrcPlayer,_Quest,_QuestState,1)
		THEN
		DB_Noop(1);
		
		PROC
		ProcShareQuestUpdate((CHARACTERGUID)_SrcPlayer,(STRING)_Quest,(STRING)_QuestFlag,(CHARACTERGUID)_Player)
		AND
		DB_QuestDef_CloseEvent(_Quest,_QuestFlag)
		THEN
		QuestClose(_Player,_Quest);
		
		PROC
		ProcMigrateQuestFlag((CHARACTERGUID)_SrcPlayer,(STRING)_Quest,(STRING)_QuestFlag)
		AND
		QuestIsShared(_SrcPlayer,_Quest,0)
		THEN
		DB_PrivateQuestFlag(_SrcPlayer,_Quest,_QuestFlag);
		ProcSharePrivateFlags(_SrcPlayer,_Quest,_QuestFlag);
		
		PROC
		ProcMigrateQuestFlag((CHARACTERGUID)_SrcPlayer,(STRING)_Quest,(STRING)_QuestFlag)
		AND
		QuestIsShared(_SrcPlayer,_Quest,1)
		THEN
		DB_SharedQuestFlag(_SrcPlayer,_Quest,_QuestFlag);
		ProcShareQuestFlag(_SrcPlayer,_Quest,_QuestFlag);
		
		PROC
		ProcSharePrivateFlags((CHARACTERGUID)_SrcPlayer,(STRING)_Quest,(STRING)_QuestFlag)
		AND
		QuestGetBroadcastLevel(_Quest,"User")
		AND
		CharacterGetReservedUserID(_SrcPlayer,_User)
		AND
		DB_IsPlayer(_Char)
		AND
		_Char != _SrcPlayer
		AND
		CharacterGetReservedUserID(_Char,_User)
		THEN
		DB_PrivateQuestFlag(_Char,_Quest,_QuestFlag);
		ProcShareQuestFlagWith(_SrcPlayer,_Quest,_QuestFlag,_Char);
		
		PROC
		ProcStoreFlagState((CHARACTERGUID)_Player,(STRING)_QuestFlag)
		AND
		ObjectGetFlag(_Player,_Questflag,_State)
		THEN
		DB_TargetQuestFlagState(_Player,_QuestFlag,_State);
		
		//if a quest flag was cleared and we didn't have it set before sharing clear it as well
		//this will make flags couple to inventory events work correctly
		PROC
		ProcVerifyFlagState((CHARACTERGUID)_SrcPlayer,(CHARACTERGUID)_Player,(STRING)_QuestFlag)
		AND
		ObjectGetFlag(_SrcPlayer,_Questflag,0)
		AND
		DB_TargetQuestFlagState(_Player,_QuestFlag,0)
		THEN
		ObjectClearFlag(_Player,_QuestFlag,0);
		
		PROC
		ProcVerifyFlagState((CHARACTERGUID)_SrcPlayer,(CHARACTERGUID)_Player,(STRING)_QuestFlag)
		AND
		ObjectGetFlag(_SrcPlayer,_Questflag,1)
		AND
		DB_HasStoryEvent((ITEMGUID)_Item,_Questflag)
		AND
		NOT QryItemInMagicPockets(_Player,_Item)
		THEN
		ObjectClearFlag(_Player,_QuestFlag,0);
		
		PROC
		ProcVerifyFlagState((CHARACTERGUID)_SrcPlayer,(CHARACTERGUID)_Player,(STRING)_QuestFlag)
		AND
		ObjectGetFlag(_SrcPlayer,_Questflag,1)
		AND
		DB_HasTemplateItem(_Template,_Questflag)
		AND
		NOT QryItemTemplateInMagicPockets(_Player,_Template)
		THEN
		ObjectClearFlag(_Player,_QuestFlag,0);
		
		//TODO: this does not handle events outside of the DB_HasStoryEvent or the TaggedItemTracker
		
		PROC
		ProcVerifyFlagState(_,_Player,_QuestFlag)
		AND
		DB_TargetQuestFlagState(_Player,_QuestFlag,_State)
		THEN
		NOT DB_TargetQuestFlagState(_Player,_QuestFlag,_State);
		//END_REGION
		
		PROC
		ProcSetFlagOnAll((STRING)_Flag)
		AND
		DB_IsPlayer(_Player)
		THEN
		ObjectSetFlag(_Player,_Flag);
		
		//REGION end of region
		
		PROC
		ProcRegionEnded(_Region)
		AND
		DB_QuestDef_CloseAtRegionEnded((STRING)_Quest,(STRING)_Flag,(STRING)_Region)
		AND
		DB_IsPlayer(_Char)
		AND
		QuestAccepted(_Char,_Quest,1)
		THEN
		ObjectSetFlag(_Char,_Flag);
		QuestArchive(_Char,_Quest,1);
		
		PROC
		ProcRegionEnded(_Region)
		AND
		DB_QuestDef_CloseAtRegionEnded_Conditions_FalseGlobalFlag_TrueObjFlag((STRING)_Quest,(STRING)_SetFlag,_Region,(STRING)_GloFlag,(STRING)_ObjFlag)
		AND
		GlobalGetFlag(_GloFlag,0)
		AND
		DB_IsPlayer(_Char)
		AND
		QuestAccepted(_Char,_Quest,1)
		AND
		UserGetFlag(_Char,_ObjFlag,1)
		AND
		ObjectGetFlag(_Char,_SetFlag,0)
		THEN
		ObjectSetFlag(_Char,_SetFlag);
		QuestArchive(_Char,_Quest,1);
		
		PROC
		ProcRegionEnded(_Region)
		AND
		DB_QuestDef_CloseAtRegionEnded_Conditions_FalseGlobalFlag_FalseObjFlag((STRING)_Quest,(STRING)_SetFlag,_Region,(STRING)_GloFlag,(STRING)_ObjFlag)
		AND
		GlobalGetFlag(_GloFlag,0)
		AND
		DB_IsPlayer(_Char)
		AND
		QuestAccepted(_Char,_Quest,1)
		AND
		UserGetFlag(_Char,_ObjFlag,0)
		AND
		ObjectGetFlag(_Char,_SetFlag,0)
		THEN
		ObjectSetFlag(_Char,_SetFlag);
		QuestArchive(_Char,_Quest,1);
		
		
		PROC
		ProcRegionEnded(_Region)
		AND
		DB_QuestDef_CloseAtRegionEnded_Conditions_TrueGlobalFlag_FalseUserFlag((STRING)_Quest,(STRING)_SetFlag,_Region,(STRING)_GloFlag,(STRING)_ObjFlag)
		AND
		GlobalGetFlag(_GloFlag,1)
		AND
		DB_IsPlayer(_Char)
		AND
		QuestAccepted(_Char,_Quest,1)
		AND
		UserGetFlag(_Char,_ObjFlag,0)
		AND
		ObjectGetFlag(_Char,_SetFlag,0)
		THEN
		ObjectSetFlag(_Char,_SetFlag);
		QuestArchive(_Char,_Quest,1);
		
		
		PROC
		ProcRegionEnded(_Region)
		AND
		DB_QuestDef_CloseAtRegionEnded_Condition_FalseGlobalFlag_OrClose((STRING)_Quest,(STRING)_SetFlag,_Region,(STRING)_GlobalFlag)
		AND
		DB_IsPlayer(_Char)
		AND
		QuestAccepted(_Char,_Quest,1)
		AND
		GlobalGetFlag(_GlobalFlag,0)
		THEN
		ObjectSetFlag(_Char,_SetFlag);
		QuestArchive(_Char,_Quest,1);
		
		PROC
		ProcRegionEnded(_Region)
		AND
		DB_QuestDef_CloseAtRegionEnded_Condition_FalseGlobalFlag_OrClose((STRING)_Quest,(STRING)_SetFlag,_Region,(STRING)_GlobalFlag)
		AND
		DB_IsPlayer(_Char)
		AND
		QuestAccepted(_Char,_Quest,1)
		AND
		GlobalGetFlag(_GlobalFlag,1)
		THEN
		QuestClose(_Char,_Quest);
		QuestArchive(_Char,_Quest,1);
		
		PROC
		ProcRegionEnded(_Region)
		AND
		DB_QuestDef_CloseAtRegionEnded_Condition_FalseGlobalFlag((STRING)_Quest,(STRING)_SetFlag,_Region,(STRING)_GlobalFlag)
		AND
		DB_IsPlayer(_Char)
		AND
		QuestAccepted(_Char,_Quest,1)
		AND
		GlobalGetFlag(_GlobalFlag,0)
		THEN
		ObjectSetFlag(_Char,_SetFlag);
		QuestArchive(_Char,_Quest,1);
		
		PROC
		ProcRegionEnded(_Region)
		AND
		DB_QuestDef_CloseAtRegionEnded_Condition_TrueGlobalFlag((STRING)_Quest,(STRING)_SetFlag,_Region,(STRING)_GlobalFlag)
		AND
		DB_IsPlayer(_Char)
		AND
		QuestAccepted(_Char,_Quest,1)
		AND
		GlobalGetFlag(_GlobalFlag,1)
		THEN
		ObjectSetFlag(_Char,_SetFlag);
		QuestArchive(_Char,_Quest,1);
		
		
		PROC
		ProcRegionEnded(_Region)
		AND
		DB_QuestDef_CloseAtRegionEnded_Conditions_FalseObjFlag((STRING)_Quest,(STRING)_SetFlag,_Region,(STRING)_ObjFlag)
		AND
		DB_IsPlayer(_Char)
		AND
		QuestAccepted(_Char,_Quest,1)
		AND
		UserGetFlag(_Char,_ObjFlag,0)
		AND
		ObjectGetFlag(_Char,_SetFlag,0)
		THEN
		ObjectSetFlag(_Char,_SetFlag);
		QuestArchive(_Char,_Quest,1);
		
		PROC
		ProcRegionEnded(_Region)
		AND
		DB_QuestDef_CloseAtRegionEnded_Conditions_FalseObjFlag_OrClose((STRING)_Quest,(STRING)_SetFlag,_Region,(STRING)_ObjFlag)
		AND
		DB_IsPlayer(_Char)
		AND
		QuestAccepted(_Char,_Quest,1)
		AND
		UserGetFlag(_Char,_ObjFlag,0)
		AND
		ObjectGetFlag(_Char,_SetFlag,0)
		THEN
		ObjectSetFlag(_Char,_SetFlag);
		QuestArchive(_Char,_Quest,1);
		
		PROC
		ProcRegionEnded(_Region)
		AND
		DB_QuestDef_CloseAtRegionEnded_Conditions_FalseObjFlag_OrClose((STRING)_Quest,(STRING)_SetFlag,_Region,(STRING)_ObjFlag)
		AND
		DB_IsPlayer(_Char)
		AND
		QuestAccepted(_Char,_Quest,1)
		AND
		UserGetFlag(_Char,_ObjFlag,1)
		THEN
		QuestClose(_Char,_Quest);
		QuestArchive(_Char,_Quest,1);
		
		PROC
		ProcRegionEnded(_Region)
		AND
		DB_QuestDef_CloseAtRegionEnded_Conditions_TrueObjFlag((STRING)_Quest,(STRING)_SetFlag,_Region,(STRING)_ObjFlag)
		AND
		DB_IsPlayer(_Char)
		AND
		QuestAccepted(_Char,_Quest,1)
		AND
		UserGetFlag(_Char,_ObjFlag,1)
		AND
		ObjectGetFlag(_Char,_SetFlag,0)
		THEN
		ObjectSetFlag(_Char,_SetFlag);
		QuestArchive(_Char,_Quest,1);
		
		PROC
		ProcRegionEnded(_Region)
		AND
		DB_QuestDef_CloseAtRegionEnded_Conditions_FalseObjFlag_TrueObjFlag((STRING)_Quest,(STRING)_SetFlag,_Region,(STRING)_FalseObjFlag,(STRING)_TrueObjFlag)
		AND
		DB_IsPlayer(_Char)
		AND
		QuestAccepted(_Char,_Quest,1)
		AND
		UserGetFlag(_Char,_FalseObjFlag,0)
		AND
		UserGetFlag(_Char,_TrueObjFlag,1)
		AND
		ObjectGetFlag(_Char,_SetFlag,0)
		THEN
		ObjectSetFlag(_Char,_SetFlag);
		QuestArchive(_Char,_Quest,1);
		
		
		PROC
		ProcRegionEnded(_Region)
		AND
		DB_QuestDef_CloseAtRegionEnded_Conditions_FalseObjFlag_FalseObjFlag((STRING)_Quest,(STRING)_SetFlag,_Region,(STRING)_FalseObjFlag1,(STRING)_FalseObjFlag2)
		AND
		DB_IsPlayer(_Char)
		AND
		QuestAccepted(_Char,_Quest,1)
		AND
		UserGetFlag(_Char,_FalseObjFlag1,0)
		AND
		UserGetFlag(_Char,_FalseObjFlag2,0)
		AND
		ObjectGetFlag(_Char,_SetFlag,0)
		THEN
		ObjectSetFlag(_Char,_SetFlag);
		QuestArchive(_Char,_Quest,1);
		
		//END_REGION
		
		//REGION set category on region started
		
		PROC
		ProcRegionStarted((STRING)_Region)
		AND
		DB_RegionQuestCategory(_Region,(STRING)_Category)
		AND
		DB_RegionQuestCategory_Swapped((STRING)_Quest)
		THEN
		ProcQuestSetCategory(_Quest,_Category);
		
		
		PROC
		ProcQuestSetCategory((STRING)_Quest,(STRING)_Category)
		AND
		DB_IsPlayer(_Char)
		AND
		QuestIsClosed(_Char,_Quest,0)
		THEN
		QuestSetCategory(_Quest,_Category);
		ProcQuestCategorySet(_Quest,_Category,_Char);
		
		
		PROC
		ProcQuestCategorySet((STRING)_Quest,(STRING)_Category,(CHARACTERGUID)_Char)
		THEN
		DB_NOOP(1);
		
		//END_REGION
		
		//REGION QuestReward
		
		IF
		ObjectFlagSet(_Flag,(CHARACTERGUID)_Player,_Inst)
		AND
		DB_IsPlayer(_Player)
		AND
		DB_QuestDef_QuestReward((STRING)_Quest,(STRING)_RewardState,_Flag)
		AND
		QuestAccepted(_Player,_Quest,1)
		AND
		_Inst != 0
		THEN
		DB_GiveQuestRewardAfterDialog(_Player,_Quest,_RewardState,_Inst);
		
		IF
		DialogEnded(_,_Inst)
		AND
		DB_GiveQuestRewardAfterDialog(_Player,_Quest,_RewardState,_Inst)
		THEN
		ProcGiveQuestReward(_Player,_Quest,_RewardState);
		NOT DB_GiveQuestRewardAfterDialog(_Player,_Quest,_RewardState,_Inst);
		
		PROC
		ProcGiveQuestReward((CHARACTERGUID)_Player,(STRING)_Quest,(STRING)_RewardState)
		AND
		NOT DB_QuestRewardGiven(_Player,_Quest,_RewardState)
		THEN
		CharacterGiveQuestReward(_Player,_Quest,_RewardState);
		ProcMarkPartyAsGivenReward(_Player,_Quest,_RewardState);
		
		PROC
		ProcMarkPartyAsGivenReward((CHARACTERGUID)_Player,(STRING)_Quest,(STRING)_RewardState)
		AND
		DB_IsPlayer(_OtherPlayer)
		AND
		CharacterIsInPartyWith(_Player,_OtherPlayer,1)
		THEN
		DB_QuestRewardGiven(_OtherPlayer,_Quest,_RewardState);
		
		//END_REGION
		
		//REGION Journal Dependencies
		// DB_JDF_QuestLinkedFlag((STRING)_JDFLinkedFlag,(STRING)_QuestUpdateFlag);
		// DB_JDF_Dependencies((STRING)_LinkedFlagPremise,(STRING)_LinkFlagConclusion);
		// DB_JDF_CyclicCheck((STRING)_JDFFlag);
		
		//REGION This proc is everything you need to use
		
		// Requirements:
		//   _Quest: name of the quest (e.g. "TUT_ShipMurder")
		//   _QuestFlagCondition: name of a quest state of _Quest (e.g. "Weapons_Found"); never an update flag!
		//   _QuestFlagConclusion: name of a quest state of _Quest (e.g. "MiddleDeckCarnage"); never an update flag!
		// Usage:
		//   If you want to make sure that the "MiddleDeckCarnage" update can only be shown after
		//   the "Weapons_Found" update has been unlocked, then
		//  1) call
		//       Proc_JDF_CreateDependency("TUT_ShipMurder", "Weapons_Found", "MiddleDeckCarnage")
		//     This will define the following flags:
		//       JDF_TUT_ShipMurder_Weapons_Found
		//       JDF_TUT_ShipMurder_MiddleDeckCarnage
		//  3) When you want to unlock either the "Weapons_Found" or the "MiddleDeckCarnage" quest update,
		//     use the JDF_* flags above instead. The JDF logic will set the corresponding QuestUpdate_*
		//     flag when all dependencies are fulfilled 
		//  4) You can chain dependencies by calling Proc_JDF_CreateDependency with a quest 
		//
		// Example:
		//  1) If you only have the above Proc_JDF_CreateDependency call, then
		//    * set JDF_TUT_ShipMurder_Weapons_Found -> set QuestUpdate_TUT_ShipMurder_Weapons_Found
		//    * set JDF_TUT_ShipMurder_MiddleDeckCarnage and JDF_TUT_ShipMurder_Weapons_Found (in either order) ->
		//        set QuestUpdate_TUT_ShipMurder_MiddleDeckCarnage
		//  2) If, in addition to the Proc_JDF_CreateDependency call above, there's also a 
		//       Proc_JDF_CreateDependency("TUT_ShipMurder", "AfterWindego", "Weapons_Found"), then
		//    * set JDF_TUT_ShipMurder_AfterWindego -> Set QuestUpdate_TUT_ShipMurder_AfterWindego
		//    * set JDF_TUT_ShipMurder_Weapons_Found and JDF_TUT_ShipMurder_AfterWindego (in either order) ->
		//        set QuestUpdate_TUT_ShipMurder_Weapons_Found
		//    * set JDF_TUT_ShipMurder_MiddleDeckCarnage, JDF_TUT_ShipMurder_AfterWindego and JDF_TUT_ShipMurder_Weapons_Found
		//        (in any order) -> set QuestUpdate_TUT_ShipMurder_MiddleDeckCarnage
		PROC
		Proc_JDF_CreateDependency((STRING)_Quest,(STRING)_QuestFlagCondition,(STRING)_QuestFlagConclusion)
		AND
		StringConcatenate(_Quest,"_",_QuestUnderline)
		AND
		StringConcatenate("QuestUpdate_",_QuestUnderline,_QuestStr)
		AND
		StringConcatenate("JDF_",_QuestUnderline,_JDFStr)
		AND
		StringConcatenate(_JDFStr,_QuestFlagCondition,_PremiseJDFLink)
		AND
		StringConcatenate(_QuestStr,_QuestFlagCondition,_PremiseQuestLink)
		AND
		StringConcatenate(_JDFStr,_QuestFlagConclusion,_ConclusionJDFLink)
		AND
		StringConcatenate(_QuestStr,_QuestFlagConclusion,_ConclusionQuestLink)
		THEN
		DB_JDF_QuestLinkedFlag(_PremiseJDFLink,_PremiseQuestLink);
		DB_JDF_QuestLinkedFlag(_ConclusionJDFLink,_ConclusionQuestLink);
		DB_JDF_Dependencies(_PremiseJDFLink,_ConclusionJDFLink);
		
		// Proc to define dependencies for quest updates that are unlocked via custom flags.
		//   Proc_JDF_CreateDependency("TUT_ShipMurder","AfterWindego","Weapons_Found")
		// corresponds to
		//   Proc_JDF_CreateCustomFlagsDependency(
		//     "JDF_TUT_ShipMurder_AfterWindego", "QuestUpdate_TUT_ShipMurder_AfterWindego",
		//     "JDF_TUT_ShipMurder_Weapons_Found", "QuestUpdate_TUT_ShipMurder_Weapons_Found");
		// Hence, if a quest update gets unlocked by a custom flag that is not of the form
		// QuestUpdate_QuestName_QuestState, you can replace the second and/or fourth parameter
		// with this flag. You will still have to make sure that your JDF/Link flags get set
		// instead of the original quest update flag.
		PROC
		Proc_JDF_CreateCustomFlagsDependency((STRING)_RequiredLinkFlag,(STRING)_RequiredQuestFlag,(STRING)_UpdateLinkFlag,(STRING)_UpdateQuestFlag)
		THEN
		DB_JDF_QuestLinkedFlag(_RequiredLinkFlag,_RequiredQuestFlag);
		DB_JDF_QuestLinkedFlag(_UpdateLinkFlag,_UpdateQuestFlag);
		DB_JDF_Dependencies(_RequiredLinkFlag,_UpdateLinkFlag);
		
		
		// Proc/hack to define dependencies for quest updates that are unlocked via custom flags without using
		// intermediate JDF flags.
		// If the _UpdateAttemptFlag is set and the character has the _RequiredFlag (or vice versa), the _UpdateFlag is set.
		//
		//   Proc_JDF_CreateCustomFlagsDependency(_RequiredFlag,_UpdateAttemptFlag,_UpdateFlag)
		//  corresponds to
		//   Proc_JDF_CreateCustomFlagsDependency(_RequiredFlag, _RequiredFlag, _UpdateAttemptFlag, _UpdateFlag);
		// I.e., the quest update flag of the condition (_RequiredFlag) doubles as the dependency chain flag. This means
		// you don't have to define an additional flag.
		//
		// Warning: since this creates a dependency chain if RequiredFlag is used as UpdateAttemptFlag for another quest update,
		//   since RequiredFlag is now also dependency checking flag
		PROC
		Proc_JDF_CreateCustomFlagsDependency((STRING)_RequiredFlag,(STRING)_UpdateAttemptFlag,(STRING)_UpdateFlag)
		THEN
		Proc_JDF_CreateCustomFlagsDependency(_RequiredFlag, _RequiredFlag, _UpdateAttemptFlag, _UpdateFlag);
		
		//END_REGION
		
		//REGION Share all of the JDF flags
		IF
		DB_JDF_QuestLinkedFlag(_LinkFlag, _)
		AND
		NOT DB_QuestDef_UpdateEvent(_, _, _LinkFlag)
		THEN
		DB_SharedQuestLessFlag(_LinkFlag);
		//END_REGION
		
		//REGION Check if preconditions are met
		QRY
		QRY_JDF_PremiseMet((GUIDSTRING)_Target,(STRING)_LinkedFlag)
		AND
		DB_JDF_Dependencies((STRING)_LinkedFlagPremise,(STRING)_LinkedFlag)
		AND
		ObjectGetFlag(_Target,_LinkedFlagPremise,1)
		THEN
		DB_NOOP(1);
		
		QRY
		QRY_JDF_PremiseMet((GUIDSTRING)_Target,(STRING)_LinkedFlag)
		AND
		NOT DB_JDF_Dependencies(_,(STRING)_LinkedFlag)
		THEN
		DB_NOOP(1);
		
		
		// Check if this flag should cause a quest flag setting
		PROC
		Proc_JDF_CheckDependencies((GUIDSTRING)_Target,(STRING)_LinkedFlag)
		AND
		ObjectGetFlag(_Target,_LinkedFlag,1)
		AND
		QRY_JDF_PremiseMet(_Target,_LinkedFlag)
		THEN
		Proc_JDF_DependenciesMet(_Target,_LinkedFlag);
		
		// Dependencies met, set the quest  flag
		PROC
		Proc_JDF_DependenciesMet((GUIDSTRING)_Target,(STRING)_LinkedFlag)
		AND
		DB_JDF_QuestLinkedFlag(_LinkedFlag,(STRING)_QuestFlag)
		THEN
		ObjectSetFlag(_Target,_QuestFlag);
		
		// Run cascade reaction to check everything along the implication sequence
		PROC
		Proc_JDF_DependenciesMet((GUIDSTRING)_Target,(STRING)_LinkedFlag)
		AND
		DB_JDF_Dependencies(_LinkedFlag,(STRING)_LinkedFlagConclusion)
		THEN
		Proc_JDF_CheckDependencies(_Target,_LinkedFlagConclusion);
		
		IF
		ObjectFlagSet(_Flag,_Target,_)
		AND
		DB_JDF_QuestLinkedFlag(_Flag,_)
		THEN
		Proc_JDF_CheckDependencies(_Target,_Flag);
		
		IF
		ObjectFlagShared(_Flag, _Target, _)
		AND
		DB_JDF_QuestLinkedFlag(_Flag,_)
		THEN
		Proc_JDF_CheckDependencies(_Target,_Flag);
		//END_REGION
		
		//REGION Protection from cyclic dependencies
		IF
		DB_JDF_Dependencies(_FlagPremise,_FlagConclusion)
		THEN
		SysClear("DB_JDF_CyclicCheck",1);
		Proc_JDF_CycleProtection(_FlagPremise);
		
		PROC
		Proc_JDF_CycleProtection((STRING)_FlagPremise)
		AND
		DB_JDF_Dependencies(_FlagPremise,_FlagConclusion)
		AND
		DB_JDF_CyclicCheck(_FlagPremise)
		AND
		StringConcatenate("CRITICAL: Cyclic dependency in JDF found including flag: ",_FlagPremise,_Text)
		THEN
		DebugBreak(_Text);
		
		PROC
		Proc_JDF_CycleProtection((STRING)_FlagPremise)
		AND
		DB_JDF_Dependencies(_FlagPremise,_FlagConclusion)
		AND
		NOT DB_JDF_CyclicCheck(_FlagPremise)
		THEN
		DB_JDF_CyclicCheck(_FlagPremise);
		Proc_JDF_CycleProtection(_FlagConclusion);
		//END_REGION
		
		//END_REGION
		
		//REGION Helpers to clear existing journal entries
		PROC
		PROC_JournalEntries_ClearQuestState((STRING)_Quest, (STRING)_State)
		THEN
		PROC_JournalEntries_ClearQuestUpdateEvent(_Quest, _State, "");
		
		PROC
		PROC_JournalEntries_ClearQuestUpdateEvent((STRING)_Quest, (STRING)_State, (STRING)_UpdateEvent)
		AND
		DB_QuestDef_State(_Quest, _State, _Action)
		THEN
		NOT DB_QuestDef_State(_Quest, _State, _Action);
		
		PROC
		PROC_JournalEntries_ClearQuestUpdateEvent((STRING)_Quest, (STRING)_State, (STRING)_UpdateEvent)
		AND
		DB_QuestDef_State(_Quest, _State)
		THEN
		NOT DB_QuestDef_State(_Quest, _State);
		
		PROC
		PROC_JournalEntries_ClearQuestUpdateEvent((STRING)_Quest, (STRING)_State, (STRING)_UpdateEvent)
		AND
		_UpdateEvent != ""
		THEN
		NOT DB_QuestDef_CloseEvent(_Quest, _UpdateEvent);
		NOT DB_QuestDef_AddEvent(_Quest, _UpdateEvent);
		NOT DB_QuestDef_UpdateEvent(_Quest, _State, _UpdateEvent);
		
		// Even with a custom event, the standard event may have been defined
		// (e.g. if you first define an add event and then a custom update event with the same state)
		PROC
		PROC_JournalEntries_ClearQuestUpdateEvent((STRING)_Quest, (STRING)_State, (STRING)_UpdateEvent)
		AND
		StringConcatenate("QuestUpdate_", _Quest, _Intermediate1)
		AND
		StringConcatenate(_Intermediate1, "_", _Intermediate2)
		AND
		StringConcatenate(_Intermediate2, _State, _StandardUpdateEvent)
		THEN
		NOT DB_QuestDef_CloseEvent(_Quest, _StandardUpdateEvent);
		NOT DB_QuestDef_AddEvent(_Quest, _StandardUpdateEvent);
		NOT DB_QuestDef_UpdateEvent(_Quest, _State, _StandardUpdateEvent);
		//END_REGION
		
	}
	EXIT
	{
		
	}
}
Goal(32).Title("_Global_Procedure");
Goal(32)
{
	INIT
	{
		
	}
	KB
	{
		//REGION Character DB_KillCounter
		PROC
		ProcCheckCounter((INTEGER)_Count,(STRING)_CounterDB)
		AND
		DB_KillCounterCounts(_CounterDB,_OldCount)
		THEN
		NOT DB_KillCounterCounts(_CounterDB,_OldCount);
		DB_KillCounterCounts(_CounterDB,_Count);
		
		PROC
		ProcClearCounterDB((STRING)_CounterDB)
		AND
		DB_KillCounter_Internal(_Character,_CounterDB)
		THEN
		NOT DB_KillCounter_Internal(_Character,_CounterDB);
		
		PROC
		ProcClearCounterDB((STRING)_CounterDB)
		AND
		DB_KillCounterDied(_Char,_CounterDB)
		THEN
		NOT DB_KillCounterDied(_Char,_CounterDB);
		
		PROC
		ProcCheckCounter(_Count,_CounterDB)
		AND
		DB_KillCounter((STRING)_CounterDB,(INTEGER)_TargetCount)
		AND
		_Count == _TargetCount 
		THEN
		//NOT DB_KillCounter(_CounterDB,_TargetCount);
		ProcClearCounterDB(_CounterDB);
		ProcKillCounterReached(_CounterDB);
		NOT DB_KillCounterCounterDefined(_CounterDB);
		//NOT DB_KillCounterCounts(_CounterDB,_TargetCount);
		
		PROC
		ProcCheckCounter(_Count, _CounterDB)
		AND
		DB_KillCounter((STRING)_CounterDB,(INTEGER)_TargetCount)
		AND
		IntegerSubtract(_TargetCount, 1, _New)
		AND
		_Count == _New
		AND
		DB_KillCounter_Internal(_LastCharacter, _CounterDB)
		THEN
		DB_LastManStanding((CHARACTERGUID)_LastCharacter, (STRING)_CounterDB);
		
		IF
		CharacterDying(_Character)
		AND
		DB_KillCounter_Internal(_Character,_CounterDB)
		AND
		DB_CombatCharacters(_Character,_ID)
		THEN
		ProcSetCounterCombatID(_CounterDB,_ID);
		
		PROC
		ProcClearCounterCombatID((STRING)_Counter)
		AND
		DB_CounterCombatID(_Counter,_OldID)
		THEN
		NOT DB_CounterCombatID(_Counter,_OldID);
		
		PROC
		ProcSetCounterCombatID((STRING)_Counter,(INTEGER)_ID)
		THEN
		ProcClearCounterCombatID(_Counter);
		DB_CounterCombatID(_Counter,_ID);
		
		IF
		ObjectEnteredCombat((CHARACTERGUID)_Char, _ID)
		AND
		DB_KillCounter_Internal(_Char, _Counter)
		THEN
		ProcClearCounterCombatID(_Counter);
		
		IF
		ObjectEnteredCombat((CHARACTERGUID)_LastMan, _ID)
		AND
		DB_KillCounter_Internal(_LastMan, _Counter)
		AND
		DB_KillCounter(_Counter,1)
		THEN
		DB_LastManStanding((CHARACTERGUID)_LastMan, (STRING)_Counter);
		
		IF
		CharacterKilledBy(_Defender, _AttackerOwner, _Attacker)
		AND
		DB_LastManStanding(_Defender, _CounterDB)
		THEN
		NOT DB_LastManStanding(_Defender, _CounterDB);
		DB_LastManInCombatKilledBy(_AttackerOwner, (STRING)_CounterDB);
		
		IF
		CharacterDied(_Character)
		AND
		DB_KillCounter_Internal(_Character,_CounterDB)
		AND
		DB_KillCounterCounts(_CounterDB,_Count)
		AND
		IntegerSum(_Count,1,_NewCount)
		THEN
		NOT DB_KillCounter_Internal(_Character,_CounterDB);
		DB_KillCounterDied(_Character,_CounterDB);
		ProcCheckCounter(_NewCount,_CounterDB);
		
		IF
		CharacterResurrected(_Character)
		AND
		DB_KillCounterDied(_Character,_CounterDB)
		AND
		DB_KillCounterCounts(_CounterDB,_Count)
		AND
		IntegerSubtract(_Count,1,_NewCount)
		THEN
		DB_KillCounter_Internal(_Character,_CounterDB);
		NOT DB_KillCounterDied(_Character,_CounterDB);
		ProcCheckCounter(_NewCount,_CounterDB);
		
		IF
		DB_KillCounter_Internal(_Character,_CounterDB)
		AND
		NOT DB_KillCounterCounterDefined(_CounterDB)
		THEN
		DB_KillCounterCounts(_CounterDB,0);
		DB_KillCounterCounterDefined(_CounterDB);
		
		IF
		CombatEnded(_CombatID)
		AND
		DB_CounterCombatID(_CounterDB,_CombatID)
		AND
		DB_KillCounterCounts(_CounterDB,_Count)
		THEN
		ProcCheckCounterCombatOver(_CounterDB,_CombatID);
		ProcCheckCounter(_Count,_CounterDB);
		
		IF
		DB_CombatCharacters(_Char, _CombatID)
		AND
		DB_KillCounter_Internal(_Char,_CounterDB)
		THEN
		ProcClearCombatOverDB(_CounterDB);
		
		PROC
		ProcClearCombatOverDB((STRING)_CounterDB)
		AND
		DB_KillCounterCombatOver(_OldCombatID, _CounterDB)
		THEN
		NOT DB_KillCounterCombatOver(_OldCombatID, _CounterDB);
		
		//killed people outside of combat
		PROC
		ProcKillCounterReached((STRING)_CounterDB)
		AND
		NOT DB_CounterCombatID(_CounterDB,_)
		THEN
		ReactOnKillCounter(_CounterDB);
		
		PROC
		ProcKillCounterReached((STRING)_CounterDB)
		AND
		DB_KillCounterCombatOver(_CombatID, _CounterDB)
		THEN
		ReactOnKillCounter(_CounterDB);
		NOT DB_KillCounterCombatOver(_CombatID, _CounterDB);
		
		//Wasn't involved in combat
		PROC
		ProcCheckCounterCombatOver((STRING)_CounterDB,(INTEGER)_CombatID)
		THEN
		NOT DB_KillCounterCombatOver(_CombatID, _CounterDB);
		
		PROC
		ProcCheckCounterCombatOver((STRING)_CounterDB,(INTEGER)_CombatID)
		AND
		CombatGetNumberOfInvolvedPartyMembers(_CombatID, 0)
		THEN
		DB_KillCounterCombatOver(_CombatID, _CounterDB);
		
		
		PROC
		ReactOnKillCounter((STRING)_CounterDB)
		AND
		DB_KillCounterCounts(_CounterDB,_Count)
		AND
		DB_KillCounter(_CounterDB,_TargetCount)
		THEN
		NOT DB_KillCounterCounts(_CounterDB,_Count);
		NOT DB_KillCounter(_CounterDB,_TargetCount);
		
		//END_REGION
		
		//REGION Item Destroy Counter
		PROC
		CheckItemCounter((INTEGER)_Count,(STRING)_CounterDB)
		AND
		DB_ItemDestroyCounterCounts(_CounterDB,_OldCount)
		THEN
		NOT DB_ItemDestroyCounterCounts(_CounterDB,_OldCount);
		DB_ItemDestroyCounterCounts(_CounterDB,_Count);
		
		PROC
		ClearDB_ItemDestroyCounter_Internal((STRING)_CounterDB)
		AND
		DB_ItemDestroyCounter_Internal(_Item,_CounterDB)
		THEN
		NOT DB_ItemDestroyCounter_Internal(_Item,_CounterDB);
		
		PROC
		CheckItemCounter(_Count,_CounterDB)
		AND
		DB_ItemDestroyCounter((STRING)_CounterDB,(INTEGER)_TargetCount)
		AND
		_Count == _TargetCount 
		THEN
		NOT DB_ItemDestroyCounter(_CounterDB,_TargetCount);
		ClearDB_ItemDestroyCounter_Internal(_CounterDB);
		NOT DB_ItemDestroyCounterCounterDefined(_CounterDB);
		NOT DB_ItemDestroyCounter(_CounterDB,_TargetCount);
		
		IF
		ItemDestroyed(_Item)
		AND
		DB_ItemDestroyCounter_Internal(_Item,_CounterDB)
		AND
		DB_ItemDestroyCounterCounts(_CounterDB,_Count)
		AND
		IntegerSum(_Count,1,_NewCount)
		THEN
		NOT DB_ItemDestroyCounter_Internal(_Item,_CounterDB);
		CheckItemCounter(_NewCount,_CounterDB);
		
		IF
		DB_ItemDestroyCounter_Internal(_Item,_CounterDB)
		AND
		NOT DB_ItemDestroyCounterCounterDefined(_CounterDB)
		THEN
		DB_ItemDestroyCounterCounts(_CounterDB,0);
		DB_ItemDestroyCounterCounterDefined(_CounterDB);
		//END_REGION
		
		//REGION Comment for hidden effect
		PROC
		PROC_CommentHiddenEffect((CHARACTERGUID)_Player)
		THEN
		Proc_StartDialog(1,"GLO_AD_ActivatedSwitch", _Player);
		//END_REGION
		
		//REGION SneakTrigger
		IF
		DB_SneakTriggerSpotter((TRIGGERGUID)_Trigger, (CHARACTERGUID)_Char)
		THEN
		SetVarObject(_Char, "SpottedTrigger", _Trigger);
		ProcTriggerRegisterForPlayers(_Trigger);
		
		PROC
		ProcHandleSneakSpotted((CHARACTERGUID)_Char)
		THEN
		DB_NOOP(1);
		
		IF
		StoryEvent((CHARACTERGUID)_Char, "GLO_SpotterSneaker")
		AND
		DB_SneakTriggerSpotter(_Trigger, _Char)
		AND
		GetVarObject(_Char, "SpottedDude", _Player)
		THEN
		ProcCharInTriggerSpotted((CHARACTERGUID)_Player,_Trigger);
		ProcCharInTriggerSpottedByChar((CHARACTERGUID)_Player,_Trigger,_Char);
		ProcHandleSneakSpotted(_Char);
		ProcCleanUpSneakTrigger(_Trigger);
		
		PROC
		ProcCharInTriggerSpottedByChar((CHARACTERGUID)_Player,(TRIGGERGUID)_Trigger,(CHARACTERGUID)_Spotter)
		THEN
		DB_NOOP(1);
		
		PROC
		ProcCleanUpSneakTrigger((TRIGGERGUID)_Trigger)
		AND
		DB_SneakTriggerSpotter((TRIGGERGUID)_Trigger, (CHARACTERGUID)_Char)
		THEN
		SetVarInteger(_Char, "SpottedCounter", 1);
		NOT DB_SneakTriggerSpotter(_Trigger, _Char);
		
		PROC
		ProcTriggerUnregisterForPlayers((TRIGGERGUID)_Trigger)
		AND
		DB_SneakTriggerSpotter(_Trigger, _Char)
		THEN
		NOT DB_SneakTriggerSpotter(_Trigger, _Char);
		//END_REGION
		
		//REGION DB_AmbushTrigger
		IF
		DB_AmbushTrigger((TRIGGERGUID)_Trigger, (ITEMGUID)_Helper)
		THEN
		ProcTriggerRegisterForPlayers(_Trigger);
		SetOnStage(_Helper, 1);
		
		IF
		CharacterEnteredTrigger(_Player,_Trigger)
		AND
		DB_AmbushTrigger(_Trigger, _)
		AND
		HasActiveStatus(_Player, "INVISIBLE", 0)
		AND
		HasActiveStatus(_Player, "SNEAKING", 0)
		THEN
		ProcLaunchAmbush(_Trigger, _Player);
		
		IF
		CharacterStatusRemoved(_Player, "INVISIBLE",_)
		AND
		DB_InRegion(_Player, _Trigger)
		AND
		DB_AmbushTrigger(_Trigger, _)
		THEN
		ProcLaunchAmbush(_Trigger, _Player);
		
		IF
		CharacterStatusRemoved(_Player, "SNEAKING",_)
		AND
		DB_InRegion(_Player, _Trigger)
		AND
		DB_AmbushTrigger(_Trigger, _Helper)
		THEN
		ProcLaunchAmbush(_Trigger, _Player);
		
		PROC
		ProcLaunchAmbush((TRIGGERGUID)_Trigger, (CHARACTERGUID)_Player)
		AND
		DB_AmbushTrigger(_Trigger, _Helper)
		THEN
		ProcTriggerUnregisterForPlayers(_Trigger);
		NOT DB_AmbushTrigger(_Trigger, _Helper);
		SetOnStage(_Helper, 0);
		//END_REGION
		
		//REGION Queuing Dialog
		//1 Speaker
		PROC
		PROC_MandatoryOneSpeakerDialog((STRING)_Dialog,(CHARACTERGUID)_Player)
		AND
		NOT QRY_SpeakerIsAvailable(_Player)
		THEN
		DB_QueuedOneSpeakerDialog(_Player,_Dialog);
		
		PROC
		PROC_MandatoryOneSpeakerDialog((STRING)_Dialog,(CHARACTERGUID)_Player)
		AND
		QRY_SpeakerIsAvailable(_Player)
		THEN
		MakePlayerActive(_Player);
		Proc_StartDialog(0,_Dialog,_Player);
		
		IF
		DialogEnded(_,_)
		AND
		DB_QueuedOneSpeakerDialog(_Player,_Dialog)
		AND
		DB_IsPlayer(_Player)
		AND
		QRY_SpeakerIsAvailable(_Player)
		THEN
		NOT DB_QueuedOneSpeakerDialog(_Player,_Dialog);
		MakePlayerActive(_Player);
		Proc_StartDialog(0,_Dialog,_Player);
		
		IF
		ObjectLeftCombat((CHARACTERGUID)_Player,_)
		AND
		DB_QueuedOneSpeakerDialog(_Player,_Dialog)
		AND
		DB_IsPlayer(_Player)
		AND
		QRY_SpeakerIsAvailable(_Player)
		THEN
		NOT DB_QueuedOneSpeakerDialog(_Player,_Dialog);
		MakePlayerActive(_Player);
		Proc_StartDialog(0,_Dialog,_Player);
		
		//END_REGION
		
		//REGION Quest Reward
		PROC
		ProcRewardQuestMedium((TRIGGERGUID)_Trigger)
		THEN
		ItemCreateAtTrigger(_Trigger, "Quest_Reward_Small_94e12298-5e59-405a-9e93-95833e648ce2");
		PlayEffect(_Trigger,"RS3_FX_GP_ScriptedEvent_Teleport_GenericSmoke_01");
		
		PROC
		ProcRewardQuestBig((TRIGGERGUID)_Trigger)
		THEN
		ItemCreateAtTrigger(_Trigger, "Quest_Reward_Big_b67596ec-18ca-4790-9273-8af23d8a7a43");
		PlayEffect(_Trigger,"RS3_FX_GP_ScriptedEvent_Teleport_GenericSmoke_01");
		//END_REGION
		
		
		//REGION secret regions
		IF
		DB_SecretRegions_OnOpenedDoor(_Trig,_)
		THEN
		LockSecretRegion(_Trig);
		
		IF
		DB_SecretRegions_OnEnteredTrig(_Trig,_OtherTrig)
		THEN
		ProcTriggerRegisterForPlayers(_OtherTrig);
		LockSecretRegion(_Trig);
		
		IF
		CharacterUsedItem(_,_Door)
		AND
		DB_SecretRegions_OnOpenedDoor(_Trig,_Door)
		AND
		DoorIsOpening(_Door,1)
		THEN
		UnlockSecretRegion(_Trig);
		NOT DB_SecretRegions_OnOpenedDoor(_Trig,_Door);
		
		IF
		ItemOpened(_Door)
		AND
		DB_SecretRegions_OnOpenedDoor(_Trig,_Door)
		THEN
		UnlockSecretRegion(_Trig);
		NOT DB_SecretRegions_OnOpenedDoor(_Trig,_Door);
		
		IF
		ItemDestroying(_Door)
		AND
		DB_SecretRegions_OnOpenedDoor(_Trig,_Door)
		THEN
		UnlockSecretRegion(_Trig);
		NOT DB_SecretRegions_OnOpenedDoor(_Trig,_Door);
		
		IF
		ItemDestroyed(_Door)
		AND
		DB_SecretRegions_OnOpenedDoor(_Trig,_Door)
		THEN
		UnlockSecretRegion(_Trig);
		NOT DB_SecretRegions_OnOpenedDoor(_Trig,_Door);
		
		
		IF
		CharacterEnteredTrigger(_Char,_EnteredTrig)
		AND
		DB_SecretRegions_OnEnteredTrig(_Trig,(TRIGGERGUID)_EnteredTrig)
		AND
		DB_IsPlayer(_Char)
		THEN
		UnlockSecretRegion(_Trig);
		NOT DB_SecretRegions_OnEnteredTrig(_Trig,_EnteredTrig);
		
		IF
		StoryEvent(_,_Event)
		AND
		DB_SecretRegions_OnStoryEvent(_Trig,_Event)
		THEN
		UnlockSecretRegion(_Trig);
		NOT DB_SecretRegions_OnStoryEvent(_Trig,_Event);
		
		
		//END_REGION
		
	}
	EXIT
	{
		
	}
}
Goal(33).Title("_Global_RunUpAndChat");
Goal(33)
{
	INIT
	{
		
	}
	KB
	{
		//REGION MoveToAndTalk
		
		//Start Walking
		PROC
		ProcCharacterMoveToAndTalk((CHARACTERGUID)_Character,(GUIDSTRING)_Target,(STRING)_Dialog,(INTEGER)_IsAutomated,(STRING)_MoveEvent,(INTEGER)_Running,(REAL)_TimeOut)
		THEN
		ProcCharacterMoveToAndTalk((CHARACTERGUID)_Character,(GUIDSTRING)_Target,(STRING)_Dialog,(INTEGER)_IsAutomated,(STRING)_MoveEvent,(INTEGER)_Running,(REAL)_TimeOut,0,0);
		
		PROC
		ProcCharacterMoveToAndTalk((CHARACTERGUID)_Character,(GUIDSTRING)_Target,(STRING)_Dialog,(INTEGER)_IsAutomated,(STRING)_MoveEvent,(INTEGER)_Running,(REAL)_TimeOut,(INTEGER)_CheckForFallBackPlayers,(INTEGER)_ForcePartyCheck)
		AND
		DB_CharacterMoveToAndTalk_CharacerIsMoving(_Character,_Target,_Dialog,_MoveEvent)
		THEN
		NOT DB_CharacterMoveToAndTalk_CharacerIsMoving(_Character,_Target,_Dialog,_MoveEvent);
		
		PROC
		ProcCharacterMoveToAndTalk((CHARACTERGUID)_Character,(GUIDSTRING)_Target,(STRING)_Dialog,(INTEGER)_IsAutomated,(STRING)_MoveEvent,(INTEGER)_Running,(REAL)_TimeOut,(INTEGER)_CheckForFallBackPlayers,(INTEGER)_ForcePartyCheck)
		AND
		DB_CharacterMoveToAndTalk_CheckForFallBackCharacters(_Character,_Target,_Dialog,_CheckForFallBackPlayers,_ForcePartCheck)
		THEN
		NOT DB_CharacterMoveToAndTalk_CheckForFallBackCharacters(_Character,_Target,_Dialog,_CheckForFallBackPlayers,_ForcePartCheck);
		
		PROC
		ProcCharacterMoveToAndTalk((CHARACTERGUID)_Character,(GUIDSTRING)_Target,(STRING)_Dialog,(INTEGER)_IsAutomated,(STRING)_MoveEvent,(INTEGER)_Running,(REAL)_TimeOut,(INTEGER)_CheckForFallBackPlayers,(INTEGER)_ForcePartyCheck)
		THEN
		CharacterMoveToAndTalk(_Character,_Target,_Dialog,_IsAutomated,_MoveEvent,_Running,_TimeOut);
		DB_CharacterMoveToAndTalk_CharacerIsMoving(_Character,_Target,_Dialog,_MoveEvent);
		DB_CharacterMoveToAndTalk_CheckForFallBackCharacters(_Character,_Target,_Dialog,_CheckForFallBackPlayers,_ForcePartyCheck);
		
		//Movement Failed
		IF
		CharacterMoveToAndTalkFailed((CHARACTERGUID)_Character,(GUIDSTRING)_Target,(STRING)_MoveEvent)
		AND
		DB_CharacterMoveToAndTalk_CharacerIsMoving(_Character,_Target,_Dialog,_MoveEvent)
		THEN
		NOT DB_CharacterMoveToAndTalk_CharacerIsMoving(_Character,_Target,_Dialog,_MoveEvent);
		
		IF
		AttackedByObject(_Character,_Source,_Summon,_DamageType,_)
		AND
		DB_CharacterMoveToAndTalk_CharacerIsMoving((CHARACTERGUID)_Character,_Target,_Dialog,_MoveEvent)
		THEN
		CharacterMoveToAndTalkRequestDialogFailed(_Character,_Target,_MoveEvent);
		
		IF
		RegionEnded(_)
		AND
		DB_CharacterMoveToAndTalk_CharacerIsMoving((CHARACTERGUID)_Character,_Target,_Dialog,_MoveEvent)
		THEN
		CharacterMoveToAndTalkRequestDialogFailed(_Character,_Target,_MoveEvent);
		
		IF
		CharacterLeftRegion(_Characrer,_Region)
		AND
		DB_CurrentLevel(_Region)
		AND
		DB_CharacterMoveToAndTalk_CharacerIsMoving((CHARACTERGUID)_Character,_Target,_Dialog,_MoveEvent)
		THEN
		CharacterMoveToAndTalkRequestDialogFailed(_Character,_Target,_MoveEvent);
		
		IF
		CharacterLeftRegion(_Target,_Region)
		AND
		DB_CurrentLevel(_Region)
		AND
		DB_CharacterMoveToAndTalk_CharacerIsMoving((CHARACTERGUID)_Character,_Target,_Dialog,_MoveEvent)
		THEN
		CharacterMoveToAndTalkRequestDialogFailed(_Character,_Target,_MoveEvent);
		
		IF
		CharacterDied(_Target)
		AND
		DB_CharacterMoveToAndTalk_CharacerIsMoving((CHARACTERGUID)_Character,_Target,_Dialog,_MoveEvent)
		THEN
		CharacterMoveToAndTalkRequestDialogFailed(_Character,_Target,_MoveEvent);
		
		IF
		CharacterDied(_Character)
		AND
		DB_CharacterMoveToAndTalk_CharacerIsMoving((CHARACTERGUID)_Character,_Target,_Dialog,_MoveEvent)
		THEN
		CharacterMoveToAndTalkRequestDialogFailed(_Character,_Target,_MoveEvent);
		
		IF
		DialogStarted(_,_ID)
		AND
		DB_DialogNPCS(_ID,_Character,_)
		AND
		DB_CharacterMoveToAndTalk_CharacerIsMoving((CHARACTERGUID)_Character,_Target,_Dialog,_MoveEvent)
		THEN
		CharacterMoveToAndTalkRequestDialogFailed(_Character,_Target,_MoveEvent);
		
		IF
		CombatStarted(_ID)
		AND
		DB_CombatCharacters(_Character, _ID)
		AND
		DB_CharacterMoveToAndTalk_CharacerIsMoving((CHARACTERGUID)_Character,_Target,_Dialog,_MoveEvent)
		THEN
		CharacterMoveToAndTalkRequestDialogFailed(_Character,_Target,_MoveEvent);
		
		
		// Movement Finished
		IF
		CharacterMoveToAndTalkRequestDialog((CHARACTERGUID)_Character,(GUIDSTRING)_Target,(STRING)_Dialog,(INTEGER)_IsAutomated,(STRING)_MoveEvent)
		AND
		DB_CharacterMoveToAndTalk_CharacerIsMoving(_Character,_Target,_Dialog,_MoveEvent)
		THEN
		NOT DB_CharacterMoveToAndTalk_CharacerIsMoving(_Character,_Target,_Dialog,_MoveEvent);
		
		IF
		CharacterMoveToAndTalkRequestDialog((CHARACTERGUID)_Character,(GUIDSTRING)_Target,(STRING)_Dialog,(INTEGER)_IsAutomated,(STRING)_MoveEvent)
		THEN
		SetStoryEvent(_Character,_MoveEvent);
		
		// Dialog Failed
		IF
		CharacterMoveToAndTalkRequestDialog((CHARACTERGUID)_Character,(GUIDSTRING)_Target,(STRING)_Dialog,(INTEGER)_IsAutomated,(STRING)_MoveEvent)
		AND
		NOT QRY_SpeakerIsAvailable(_Target)
		AND 
		DB_CharacterMoveToAndTalk_CheckForFallBackCharacters(_Character,_Target,_Dialog,0,_ForcePartyCheck)
		THEN
		CharacterMoveToAndTalkRequestDialogFailed(_Character,_Target,_MoveEvent);
		
		
		IF
		CharacterMoveToAndTalkRequestDialog((CHARACTERGUID)_Character,(GUIDSTRING)_Target,(STRING)_Dialog,(INTEGER)_IsAutomated,(STRING)_MoveEvent)
		AND
		NOT QRY_SpeakerIsAvailable(_Target)
		AND 
		DB_CharacterMoveToAndTalk_CheckForFallBackCharacters(_Character,(CHARACTERGUID)_Target,_Dialog,1,0)
		AND
		DB_IsPlayer(_Target)
		AND
		QRY_GetClosestAvailableCharacterTo(_Target,1)
		AND
		NOT DB_MoveToAndTalk_FoundNewAvailablePlayer(1)
		THEN
		DB_MoveToAndTalk_FoundNewAvailablePlayer(1);
		PROC_CharacterMoveToAndTalkRequestDialog_Closest(_Character,_Target,_Dialog,_IsAutomated,_MoveEvent);
		
		IF
		CharacterMoveToAndTalkRequestDialog((CHARACTERGUID)_Character,(GUIDSTRING)_Target,(STRING)_Dialog,(INTEGER)_IsAutomated,(STRING)_MoveEvent)
		AND
		NOT QRY_SpeakerIsAvailable(_Target)
		AND 
		DB_CharacterMoveToAndTalk_CheckForFallBackCharacters(_Character,(CHARACTERGUID)_Target,_Dialog,1,1)
		AND
		DB_IsPlayer(_Target)
		AND
		QRY_GetClosestAvailableCharacterTo(_Target,1,1,_Target)
		AND
		NOT DB_MoveToAndTalk_FoundNewAvailablePlayer(1)
		THEN
		DB_MoveToAndTalk_FoundNewAvailablePlayer(1);
		PROC_CharacterMoveToAndTalkRequestDialog_Closest(_Character,_Target,_Dialog,_IsAutomated,_MoveEvent);
		
		IF
		CharacterMoveToAndTalkRequestDialog((CHARACTERGUID)_Character,(GUIDSTRING)_Target,(STRING)_Dialog,(INTEGER)_IsAutomated,(STRING)_MoveEvent)
		AND
		NOT QRY_SpeakerIsAvailable(_Target)
		AND 
		DB_CharacterMoveToAndTalk_CheckForFallBackCharacters(_Character,(CHARACTERGUID)_Target,_Dialog,1,_)
		AND
		DB_IsPlayer(_Target)
		AND
		NOT QRY_GetClosestAvailableCharacterTo(_Target,1)
		AND
		NOT DB_MoveToAndTalk_FoundNewAvailablePlayer(1)
		THEN
		CharacterMoveToAndTalkRequestDialogFailed(_Character,_Target,_MoveEvent);
		
		IF
		CharacterMoveToAndTalkRequestDialog((CHARACTERGUID)_Character,(GUIDSTRING)_Target,(STRING)_Dialog,(INTEGER)_IsAutomated,(STRING)_MoveEvent)
		AND
		DB_MoveToAndTalk_FoundNewAvailablePlayer(1)
		THEN
		NOT DB_MoveToAndTalk_FoundNewAvailablePlayer(1);
		
		// Dialog Success
		
		IF
		CharacterMoveToAndTalkRequestDialog((CHARACTERGUID)_Character,(GUIDSTRING)_Target,(STRING)_Dialog,(INTEGER)_IsAutomated,(STRING)_MoveEvent)
		AND
		_Dialog!=""
		AND
		QRY_SpeakerIsAvailable(_Target)
		THEN
		Proc_StartDialog(_IsAutomated,_Dialog,_Character,_Target);
		
		PROC
		PROC_CharacterMoveToAndTalkRequestDialog_Closest((CHARACTERGUID)_Character,(GUIDSTRING)_Target,(STRING)_Dialog,(INTEGER)_IsAutomated,(STRING)_MoveEvent)
		AND
		NOT QRY_SpeakerIsAvailable(_Target)
		AND
		DB_ClosestAvailableCharacterTo(_Player,(CHARACTERGUID)_Target,_)
		THEN
		Proc_StartDialog(_IsAutomated,_Dialog,_Character,_Player);
		
		PROC
		PROC_CharacterMoveToAndTalkRequestDialog_Closest((CHARACTERGUID)_Character,(GUIDSTRING)_Target,(STRING)_Dialog,(INTEGER)_IsAutomated,(STRING)_MoveEvent)
		AND
		NOT QRY_SpeakerIsAvailable(_Target)
		AND
		NOT DB_ClosestAvailableCharacterTo(_,(CHARACTERGUID)_Target,_)
		THEN
		CharacterMoveToAndTalkRequestDialogFailed(_Character,_Target,_MoveEvent);
		
		//END_REGION
		
		
	}
	EXIT
	{
		
	}
}
Goal(34).Title("_Global_SavegamePatching");
Goal(34)
{
	INIT
	{
		
	}
	KB
	{
		
	}
	EXIT
	{
		
	}
}
Goal(35).Title("_GLOBAL_Shared_PartyDecisionDialogs");
Goal(35)
{
	INIT
	{
		DB_PartyDecisionDialog_UltimatumEvent("Ultimatum1","Optional1Chosen");
		DB_PartyDecisionDialog_UltimatumEvent("Ultimatum2","Optional2Chosen");
		DB_PartyDecisionDialog_UltimatumEvent("Ultimatum3","Optional3Chosen");
		DB_PartyDecisionDialog_UltimatumEvent("Ultimatum4","Optional4Chosen");
		DB_PartyDecisionDialog_UltimatumEvent("Ultimatum5","Optional5Chosen");
		
		DB_PartyDecisionDialog_PlayerIdentifier(2,"PDD_Player2");
		DB_PartyDecisionDialog_PlayerIdentifier(3,"PDD_Player3");
		DB_PartyDecisionDialog_PlayerIdentifier(4,"PDD_Player4");
		
		DB_LoopEffectDisabledInCombat("RS3_FX_UI_Exclamation_Mark_01");
		
	}
	KB
	{
		//Phases of a Party Decision dialog:
		//1) Player 2-4 choose one of max five fixed option (A-E) or suggest a new extra conditional option (1-5). These conditional options can be ultimatums
		//2) Player 1 makes a final decision
		//3) OutcomeEvent gets set. If ultimatum that was ignored, combat starts.
		
		//Public functions:
		IF
		DualDialogRequested(_PartyDecisionDialog,_ParentInstance,_TargetInstance)
		AND
		DB_DialogPlayers(_ParentInstance,_Player,1)
		THEN
		DB_PartyDecisionDialog_DualDialogInstance(_PartyDecisionDialog,_ParentInstance,_TargetInstance);
		ProcStartPartyDecisionDialog((CHARACTERGUID)_Player,_PartyDecisionDialog);
		
		//Private functions:
		//REGION Init
		PROC
		ProcStartPartyDecisionDialog((CHARACTERGUID)_Player1,(STRING)_PartyDecisionDialogName)
		AND
		NOT DB_PartyDecisionDialog_Outcome(_PartyDecisionDialogName,_)
		THEN
		Proc_PartyDecisionDialog_CollectPlayers(_Player1,_PartyDecisionDialogName);
		Proc_PartyDecisionDialog_Phase1(_Player1,_PartyDecisionDialogName);
		
		//Collect all available (nearby) players and add them to an indexed list, with the dialog started in pos 1.
		PROC
		Proc_PartyDecisionDialog_CollectPlayers((CHARACTERGUID)_Player1,(STRING)_PartyDecisionDialogName)
		AND
		NOT DB_PartyDecisionDialog_PlayerCount(_PartyDecisionDialogName,_)
		THEN
		DB_PartyDecisionDialog_Players(_PartyDecisionDialogName,_Player1,1);
		DB_PartyDecisionDialog_PlayerCount(_PartyDecisionDialogName,1);
		
		//First add all companions
		PROC
		Proc_PartyDecisionDialog_CollectPlayers((CHARACTERGUID)_Player1,(STRING)_PartyDecisionDialogName)
		AND
		DB_IsPlayer(_Player)
		AND
		_Player != _Player1
		AND
		CharacterIsInPartyWith(_Player,_Player1,1)
		AND
		CharacterIsPolymorphInteractionDisabled(_Player,0)
		AND
		IsTagged(_Player,"HENCHMAN",0)
		AND
		IsTagged(_Player,"AVATAR",0)
		AND
		QRY_SpeakerIsAvailableAndInDialogRange(_Player,_Player1)
		AND
		DB_PartyDecisionDialog_PlayerCount(_PartyDecisionDialogName,_Count)
		AND
		IntegerSum(_Count,1,_NewCount)
		AND
		NOT DB_ExcludePlayerForPDD(_PartyDecisionDialogName,_Player)
		THEN
		DB_PartyDecisionDialog_Players(_PartyDecisionDialogName,_Player,_NewCount);
		NOT DB_PartyDecisionDialog_PlayerCount(_PartyDecisionDialogName,_Count);
		DB_PartyDecisionDialog_PlayerCount(_PartyDecisionDialogName,_NewCount);
		
		//Then Add all avatars
		PROC
		Proc_PartyDecisionDialog_CollectPlayers((CHARACTERGUID)_Player1,(STRING)_PartyDecisionDialogName)
		AND
		DB_IsPlayer(_Player)
		AND
		_Player != _Player1
		AND
		CharacterIsInPartyWith(_Player,_Player1,1)
		AND
		IsTagged(_Player,"AVATAR",1)
		AND
		QRY_SpeakerIsAvailableAndInDialogRange(_Player,_Player1)
		AND
		DB_PartyDecisionDialog_PlayerCount(_PartyDecisionDialogName,_Count)
		AND
		IntegerSum(_Count,1,_NewCount)
		AND
		NOT DB_ExcludePlayerForPDD(_PartyDecisionDialogName,_Player)
		THEN
		DB_PartyDecisionDialog_Players(_PartyDecisionDialogName,_Player,_NewCount);
		NOT DB_PartyDecisionDialog_PlayerCount(_PartyDecisionDialogName,_Count);
		DB_PartyDecisionDialog_PlayerCount(_PartyDecisionDialogName,_NewCount);
		
		PROC
		Proc_PartyDecisionDialog_CollectPlayers((CHARACTERGUID)_Player1,(STRING)_PartyDecisionDialogName)
		AND
		DB_PartyDecisionDialog_PlayerCount(_PartyDecisionDialogName,_Count)
		THEN
		NOT DB_PartyDecisionDialog_PlayerCount(_PartyDecisionDialogName,_Count);
		//END_REGION
		
		//REGION Data managment
		PROC
		Proc_RegisterPartyDecisionDialogOutcomes_Fixed((STRING)_DialogName,(STRING)_Fixed1,(STRING)_Fixed2,(STRING)_Fixed3,(STRING)_Fixed4,(STRING)_Fixed5)
		THEN
		DB_PartyDecisionDialog_OutcomeEvent(_DialogName,"FixedAChosen",_Fixed1);
		DB_PartyDecisionDialog_OutcomeEvent(_DialogName,"FixedBChosen",_Fixed2);
		DB_PartyDecisionDialog_OutcomeEvent(_DialogName,"FixedCChosen",_Fixed3);
		DB_PartyDecisionDialog_OutcomeEvent(_DialogName,"FixedDChosen",_Fixed4);
		DB_PartyDecisionDialog_OutcomeEvent(_DialogName,"FixedEChosen",_Fixed5);
		
		PROC
		Proc_RegisterPartyDecisionDialogOutcomes_Optional((STRING)_DialogName,(STRING)_Option1,(STRING)_Option2,(STRING)_Option3,(STRING)_Option4,(STRING)_Option5)
		THEN
		DB_PartyDecisionDialog_OutcomeEvent(_DialogName,"Optional1Chosen",_Option1);
		DB_PartyDecisionDialog_OutcomeEvent(_DialogName,"Optional2Chosen",_Option2);
		DB_PartyDecisionDialog_OutcomeEvent(_DialogName,"Optional3Chosen",_Option3);
		DB_PartyDecisionDialog_OutcomeEvent(_DialogName,"Optional4Chosen",_Option4);
		DB_PartyDecisionDialog_OutcomeEvent(_DialogName,"Optional5Chosen",_Option5);
		//END_REGION
		
		//REGION Phase 2
		PROC
		Proc_PartyDecisionDialog_Phase2((STRING)_PartyDecisionDialogName)
		AND
		DB_PartyDecisionDialog_State(_PartyDecisionDialogName,_Player1,"Phase1")
		AND
		DB_PartyDecisionDialog_DualDialogInstance(_PartyDecisionDialogName,_ParentInstance,_TargetInstance)
		THEN
		NOT DB_PartyDecisionDialog_State(_PartyDecisionDialogName,_Player1,"Phase1");
		DB_PartyDecisionDialog_State(_PartyDecisionDialogName,_Player1,"Phase2");
		SetTag(_Player1,"PDD_Player1");
		Proc_PartyDecisionDialog_DoDialogWithObservers(_Player1,_PartyDecisionDialogName,_ParentInstance,_TargetInstance);
		
		//Player 2-4 made his choice: ignore and reset
		IF
		ObjectFlagSet(_Event,_Player,_Inst)
		AND
		DB_PartyDecisionDialog_OutcomeEvent(_PartyDecisionDialogName,_Event,_Outcome)
		AND
		DB_PartyDecisionDialog_State(_PartyDecisionDialogName,_Player2,"Phase1")
		AND
		_Player != _Player2
		THEN
		ObjectClearDialogFlag(_Player,_Event,_Inst);
		
		//Player 1 made his choice: set the final event
		IF
		ObjectFlagSet(_Event,(CHARACTERGUID)_Player,_Inst)
		AND
		DB_PartyDecisionDialog_State(_PartyDecisionDialogName,_Player,"Phase2")
		AND
		DB_PartyDecisionDialog_OutcomeEvent(_PartyDecisionDialogName,_Event,_Outcome)
		THEN
		DB_PartyDecisionDialog_Outcome(_PartyDecisionDialogName,_Event);
		ObjectClearDialogFlag(_Player,_Event,_Inst);
		ClearTag(_Player,"PDD_Player1");
		ObjectSetDialogFlag(_Player,_Outcome,_Inst);
		
		IF
		DialogEnded(_PartyDecisionDialogName,_)
		AND
		DB_PartyDecisionDialog_State(_PartyDecisionDialogName,_Player1,"Phase2")
		THEN
		Proc_PartyDecisionDialog_Cleanup(_PartyDecisionDialogName);
		NOT DB_PartyDecisionDialog_State(_PartyDecisionDialogName,_Player1,"Phase2");
		//END_REGION
		
		//REGION Phase1
		//Start looping over all available players starting from the second. (First player goes last and decides. cfr, Phase 2)
		PROC
		Proc_PartyDecisionDialog_Phase1((CHARACTERGUID)_Player1,(STRING)_PartyDecisionDialogName)
		THEN
		DB_PartyDecisionDialog_State(_PartyDecisionDialogName,_Player1,"Phase1");
		DB_PartyDecisionDialog_Phase1_Index(2);
		Proc_PartyDecisionDialog_Phase1_NextPlayer(_PartyDecisionDialogName,2);
		
		//If a character exist at that index, start a dialog with that character as first speaker
		PROC
		Proc_PartyDecisionDialog_Phase1_NextPlayer((STRING)_PartyDecisionDialogName,(INTEGER)_Index)
		THEN
		NOT DB_RanPartyDecisionDialog_Players(_PartyDecisionDialogName);
		
		PROC
		Proc_PartyDecisionDialog_Phase1_NextPlayer((STRING)_PartyDecisionDialogName,(INTEGER)_Index)
		AND
		DB_PartyDecisionDialog_Players(_PartyDecisionDialogName,_Player,_Index)
		AND
		DB_PartyDecisionDialog_PlayerIdentifier(_Index,_PlayerIdentifier)
		AND
		DB_PartyDecisionDialog_DualDialogInstance(_PartyDecisionDialogName,_ParentInstance,_TargetInstance)
		AND
		DB_PartyDecisionDialog_Players(_PartyDecisionDialogName,_Initiator,1)
		THEN
		SetTag(_Player,_PlayerIdentifier);
		Proc_PartyDecisionDialog_DoDialogWithObservers(_Player,_PartyDecisionDialogName,_ParentInstance,0);
		DB_RanPartyDecisionDialog_Players(_PartyDecisionDialogName);
		
		//If a character does NOT exist at that index, all characters were exhausted, go to phase 2.
		PROC
		Proc_PartyDecisionDialog_Phase1_NextPlayer((STRING)_PartyDecisionDialogName,(INTEGER)_Index)
		AND
		NOT DB_RanPartyDecisionDialog_Players(_PartyDecisionDialogName)
		THEN
		NOT DB_PartyDecisionDialog_Phase1_Index(_Index);
		Proc_PartyDecisionDialog_Phase2(_PartyDecisionDialogName);
		
		PROC
		Proc_PartyDecisionDialog_Phase1_NextPlayer((STRING)_PartyDecisionDialogName,(INTEGER)_)
		THEN
		NOT DB_RanPartyDecisionDialog_Players(_PartyDecisionDialogName);
		
		//A dialog in phase 1 is done, try again with index + 1
		IF
		DialogEnded(_PartyDecisionDialogName,_Inst)
		AND
		DB_PartyDecisionDialog_State(_PartyDecisionDialogName,_Player1,"Phase1")
		AND
		DB_PartyDecisionDialog_Phase1_Index(_Index)
		AND
		IntegerSum(_Index,1,_NewIndex)
		AND
		DB_DialogPlayers(_Inst,_Player,1)
		AND
		DB_PartyDecisionDialog_PlayerIdentifier(_Index,_PlayerIdentifier)
		THEN
		ClearTag(_Player,_PlayerIdentifier);
		NOT DB_PartyDecisionDialog_Phase1_Index(_Index);
		DB_PartyDecisionDialog_Phase1_Index(_NewIndex);
		Proc_PartyDecisionDialog_Phase1_NextPlayer(_PartyDecisionDialogName,_NewIndex);
		
		//Record Ultimatum
		IF
		ObjectFlagSet(_Event,(CHARACTERGUID)_Player,_)
		AND
		DB_PartyDecisionDialog_UltimatumEvent(_Event,_Option)
		AND
		DB_PartyDecisionDialog_Players(_PartyDecisionDialogName,_Player,_Index)
		THEN
		DB_PartyDecisionDialog_UltimatumSet(_PartyDecisionDialogName,_Player,_Option);
		ObjectClearFlag(_Player,_Event,0);
		//END_REGION
		
		//REGION Clean up
		PROC
		Proc_PartyDecisionDialog_Cleanup((STRING)_PartyDecisionDialogName)
		AND
		DB_PartyDecisionDialog_OutcomeEvent(_PartyDecisionDialogName,_Outcome,_StoryEvent)
		THEN
		NOT DB_PartyDecisionDialog_OutcomeEvent(_PartyDecisionDialogName,_Outcome,_StoryEvent);
		
		PROC
		Proc_PartyDecisionDialog_Cleanup((STRING)_PartyDecisionDialogName)
		AND
		DB_PartyDecisionDialog_DualDialogInstance(_PartyDecisionDialogName,_ParentInstance,_TargetInstance)
		THEN
		NOT DB_PartyDecisionDialog_DualDialogInstance(_PartyDecisionDialogName,_ParentInstance,_TargetInstance);
		
		PROC
		Proc_PartyDecisionDialog_Cleanup((STRING)_PartyDecisionDialogName)
		AND
		DB_PartyDecisionDialog_Players(_PartyDecisionDialogName,_Player,_Index)
		THEN
		NOT DB_PartyDecisionDialog_Players(_PartyDecisionDialogName,_Player,_Index);
		//END_REGION
		
		//REGION HelperFunctions (Is used by Party Decision Dialogs and Reflection Dialogs)
		PROC
		Proc_PartyDecisionDialog_DoDialogWithObservers((CHARACTERGUID)_DecisionMaker,(STRING)_PartyDecisionDialogName,(INTEGER)_ParentInstance,(INTEGER)_TargetInstance)
		THEN
		DB_PartyDecisionDialog_Observer(_PartyDecisionDialogName,_DecisionMaker,1);
		DB_PartyDecisionDialog_ObserverCount(_PartyDecisionDialogName,1);
		
		//PDD variant
		PROC
		Proc_PartyDecisionDialog_DoDialogWithObservers((CHARACTERGUID)_DecisionMaker,(STRING)_PartyDecisionDialogName,(INTEGER)_ParentInstance,(INTEGER)_TargetInstance)
		AND
		DB_PartyDecisionDialog_Players(_PartyDecisionDialogName,_Player,_)
		AND
		_Player != _DecisionMaker
		AND
		DB_PartyDecisionDialog_ObserverCount(_PartyDecisionDialogName,_Count)
		AND
		IntegerSum(_Count,1,_NewCount)
		THEN
		DB_PartyDecisionDialog_Observer(_PartyDecisionDialogName,_Player,_NewCount);
		NOT DB_PartyDecisionDialog_ObserverCount(_PartyDecisionDialogName,_Count);
		DB_PartyDecisionDialog_ObserverCount(_PartyDecisionDialogName,_NewCount);
		
		//RD Variant
		PROC
		Proc_PartyDecisionDialog_DoDialogWithObservers((CHARACTERGUID)_DecisionMaker,(STRING)_PartyDecisionDialogName,(INTEGER)_ParentInstance,(INTEGER)_TargetInstance)
		AND
		DB_ReflectionDialog_Players(_PartyDecisionDialogName,_Player,_)
		AND
		_Player != _DecisionMaker
		AND
		DB_PartyDecisionDialog_ObserverCount(_PartyDecisionDialogName,_Count)
		AND
		IntegerSum(_Count,1,_NewCount)
		THEN
		DB_PartyDecisionDialog_Observer(_PartyDecisionDialogName,_Player,_NewCount);
		NOT DB_PartyDecisionDialog_ObserverCount(_PartyDecisionDialogName,_Count);
		DB_PartyDecisionDialog_ObserverCount(_PartyDecisionDialogName,_NewCount);
		
		PROC
		Proc_PartyDecisionDialog_DoDialogWithObservers((CHARACTERGUID)_DecisionMaker,(STRING)_PartyDecisionDialogName,(INTEGER)_ParentInstance,(INTEGER)_TargetInstance)
		AND
		DB_PartyDecisionDialog_ObserverCount(_PartyDecisionDialogName,1)
		THEN
		Proc_DoPartyDecisionDialog(_PartyDecisionDialogName,_DecisionMaker,NULL_00000000-0000-0000-0000-000000000000,NULL_00000000-0000-0000-0000-000000000000,NULL_00000000-0000-0000-0000-000000000000,_ParentInstance,_TargetInstance);
		
		PROC
		Proc_PartyDecisionDialog_DoDialogWithObservers((CHARACTERGUID)_DecisionMaker,(STRING)_PartyDecisionDialogName,(INTEGER)_ParentInstance,(INTEGER)_TargetInstance)
		AND
		DB_PartyDecisionDialog_ObserverCount(_PartyDecisionDialogName,2)
		AND
		DB_PartyDecisionDialog_Observer(_PartyDecisionDialogName,_Player2,2)
		THEN
		Proc_DoPartyDecisionDialog(_PartyDecisionDialogName,_DecisionMaker,_Player2,NULL_00000000-0000-0000-0000-000000000000,NULL_00000000-0000-0000-0000-000000000000,_ParentInstance,_TargetInstance);
		
		PROC
		Proc_PartyDecisionDialog_DoDialogWithObservers((CHARACTERGUID)_DecisionMaker,(STRING)_PartyDecisionDialogName,(INTEGER)_ParentInstance,(INTEGER)_TargetInstance)
		AND
		DB_PartyDecisionDialog_ObserverCount(_PartyDecisionDialogName,3)
		AND
		DB_PartyDecisionDialog_Observer(_PartyDecisionDialogName,_Player2,2)
		AND
		DB_PartyDecisionDialog_Observer(_PartyDecisionDialogName,_Player3,3)
		THEN
		Proc_DoPartyDecisionDialog(_PartyDecisionDialogName,_DecisionMaker,_Player2,_Player3,NULL_00000000-0000-0000-0000-000000000000,_ParentInstance,_TargetInstance);
		
		PROC
		Proc_PartyDecisionDialog_DoDialogWithObservers((CHARACTERGUID)_DecisionMaker,(STRING)_PartyDecisionDialogName,(INTEGER)_ParentInstance,(INTEGER)_TargetInstance)
		AND
		DB_PartyDecisionDialog_ObserverCount(_PartyDecisionDialogName,_Nr)
		AND
		_Nr>=4
		AND
		DB_PartyDecisionDialog_Observer(_PartyDecisionDialogName,_Player2,2)
		AND
		DB_PartyDecisionDialog_Observer(_PartyDecisionDialogName,_Player3,3)
		AND
		DB_PartyDecisionDialog_Observer(_PartyDecisionDialogName,_Player4,4)
		THEN
		Proc_DoPartyDecisionDialog(_PartyDecisionDialogName,_DecisionMaker,_Player2,_Player3,_Player4,_ParentInstance,_TargetInstance);
		
		PROC
		Proc_DoPartyDecisionDialog((STRING)_PartyDecisionDialogName,(CHARACTERGUID)_DecisionMaker,(CHARACTERGUID)_Player2,(CHARACTERGUID)_Player3,(CHARACTERGUID)_Player4,(INTEGER)_ParentInstance,(INTEGER)_TargetInstance)
		AND
		DialogStartPartyDialog(_PartyDecisionDialogName,_ParentInstance,_TargetInstance,_DecisionMaker,_Player2,_Player3,_Player4,1)
		THEN
		CharacterMakeStoryNpc(_DecisionMaker,1);
		CharacterMakeStoryNpc(_Player2,1);
		CharacterMakeStoryNpc(_Player3,1);
		CharacterMakeStoryNpc(_Player4,1);
		
		PROC
		Proc_PartyDecisionDialog_DoDialogWithObservers((CHARACTERGUID)_DecisionMaker,(STRING)_PartyDecisionDialogName,(INTEGER)_ParentInstance,(INTEGER)_TargetInstance)
		AND
		DB_PartyDecisionDialog_ObserverCount(_PartyDecisionDialogName,_Count)
		AND
		DB_PartyDecisionDialog_Observer(_PartyDecisionDialogName,_Player,_Index)
		THEN
		NOT DB_PartyDecisionDialog_ObserverCount(_PartyDecisionDialogName,_Count);
		NOT DB_PartyDecisionDialog_Observer(_PartyDecisionDialogName,_Player,_Index);
		//END_REGION
		
	}
	EXIT
	{
		
	}
}
Goal(36).Title("_GLOBAL_Shared_ReflectionDialog");
Goal(36)
{
	INIT
	{
		DB_ReflectionDialog_PlayerIdentifier(1,"PDD_Player1");
		DB_ReflectionDialog_PlayerIdentifier(2,"PDD_Player2");
		DB_ReflectionDialog_PlayerIdentifier(3,"PDD_Player3");
		DB_ReflectionDialog_PlayerIdentifier(4,"PDD_Player4");
		
		//DB_GlobalReflectionDialog(_ReflectionDialogName) Will make the PDD ignore in party checks
		
	}
	KB
	{
		//Phases of a Reflection dialog:
		//1) Exclamation marks above all players head
		//2) Talking to each other starts reflection dialog with anyone near.
		//3) Player 1-4 choose one of max eight options (A-H).
		//4) If all nearby players have chosen, it ends.
		
		IF
		GlobalFlagSet("GLO_DisableReflectionsPermanently")
		THEN
		GoalCompleted;
		
		//REGION Public functions
		PROC
		ProcDefineReflectionDialog((STRING)_Dialog,(CHARACTERGUID)_SourcePlayer)
		AND
		NOT DB_ReflectionDialog_InProgress(_Dialog,_)
		AND
		NOT DB_ReflectionDialog_Finished(_Dialog)
		AND
		DB_ReflectionDialogs_Queued(_Player,_CurrentDialog)
		THEN
		ProcCancelReflectionDialog(_CurrentDialog);
		
		PROC
		ProcDefineReflectionDialog((STRING)_Dialog,(CHARACTERGUID)_SourcePlayer)
		AND
		NOT DB_ReflectionDialog_InProgress(_Dialog,_)
		AND
		NOT DB_ReflectionDialog_Finished(_Dialog)
		THEN
		ProcDefineReflectionDialogIfPlayersAvailable(_Dialog,_SourcePlayer);
		//END_REGION
		
		//REGION Exclamation marks & Dialog Managment
		PROC
		ProcDefineReflectionDialogIfPlayersAvailable((STRING)_Dialog,(CHARACTERGUID)_SourcePlayer)
		THEN
		DB_AvailableReflectionDialogPlayerCount(0);
		
		PROC
		ProcDefineReflectionDialogIfPlayersAvailable((STRING)_Dialog,(CHARACTERGUID)_SourcePlayer)
		AND
		DB_AvailableReflectionDialogPlayer(_Player)
		THEN
		NOT DB_AvailableReflectionDialogPlayer(_Player);
		
		PROC
		ProcDefineReflectionDialogIfPlayersAvailable((STRING)_Dialog,(CHARACTERGUID)_SourcePlayer)
		AND
		DB_Avatars(_Player)
		AND
		NOT DB_Dead(_Player)
		AND
		CharacterIsInPartyWith(_SourcePlayer,_Player,1)
		AND
		GetDistanceTo(_Player,_SourcePlayer,_Dist)
		AND
		_Dist < 30.0
		AND
		DB_AvailableReflectionDialogPlayerCount(_Count)
		AND
		IntegerSum(_Count,1,_New)
		THEN
		NOT DB_AvailableReflectionDialogPlayerCount(_Count);
		DB_AvailableReflectionDialogPlayerCount(_New);
		DB_AvailableReflectionDialogPlayer(_Player);
		
		PROC
		ProcDefineReflectionDialogIfPlayersAvailable((STRING)_Dialog,(CHARACTERGUID)_SourcePlayer)
		AND
		DB_AvailableReflectionDialogPlayer(_Avatar)
		AND
		DB_CompanionAvatarBond(_Player,_Avatar)
		AND
		NOT DB_Dead(_Player)
		AND
		CharacterIsInPartyWith(_Avatar,_Player,1)
		AND
		CharacterIsPolymorphInteractionDisabled(_Player,0)
		AND
		IsTagged(_Player,"HENCHMAN",0)
		AND
		GetDistanceTo(_Player,_SourcePlayer,_Dist)
		AND
		_Dist < 30.0
		AND
		DB_AvailableReflectionDialogPlayerCount(_Count)
		AND
		IntegerSum(_Count,1,_New)
		THEN
		NOT DB_AvailableReflectionDialogPlayerCount(_Count);
		DB_AvailableReflectionDialogPlayerCount(_New);
		DB_AvailableReflectionDialogPlayer(_Player);
		
		PROC
		ProcDefineReflectionDialogIfPlayersAvailable((STRING)_Dialog,(CHARACTERGUID)_SourcePlayer)
		AND
		DB_AvailableReflectionDialogPlayerCount(_Count)
		AND
		_Count>=2
		THEN
		PROC_PeaceTimerLaunch(_Dialog,60000);
		
		PROC
		ProcDefineReflectionDialogIfPlayersAvailable((STRING)_Dialog,(CHARACTERGUID)_SourcePlayer)
		AND
		DB_AvailableReflectionDialogPlayerCount(_Count)
		AND
		_Count>=2
		AND
		DB_AvailableReflectionDialogPlayer(_Player)
		THEN
		PROC_CheckPlayTut(_Player,"TUT_ReflectionDialog");
		ApplyStatus(_Player,"REFLECTION",-1.0);
		SetHasDialog(_Player,1);
		DB_ReflectionDialogs_Queued(_Player,_Dialog);
		ProcReflectionSaveDialogState(_Player);
		
		PROC
		ProcDefineReflectionDialogIfPlayersAvailable((STRING)_,_)
		AND
		DB_AvailableReflectionDialogPlayerCount(_Count)
		THEN
		NOT DB_AvailableReflectionDialogPlayerCount(_Count);
		
		IF
		CharacterDied(_Char)
		AND
		_Char.DB_IsPlayer()
		AND
		DB_ReflectionDialogs_Queued(_Char,_Dialog)
		THEN
		ProcCancelReflectionDialog(_Dialog);
		
		PROC
		ProcCancelReflectionDialog((STRING)_ReflectionDialog)
		THEN
		TimerCancel(_ReflectionDialog);
		
		PROC
		ProcCancelReflectionDialog((STRING)_ReflectionDialog)
		AND
		DB_ReflectionDialogs_Queued(_Player,_ReflectionDialog)
		THEN
		ProcRestorePlayerToBeforeReflectionDialog(_Player,_ReflectionDialog);
		
		PROC
		ProcRestorePlayerToBeforeReflectionDialog((CHARACTERGUID)_Player,(STRING)_ReflectionDialog)
		THEN
		RemoveStatus(_Player,"REFLECTION");
		NOT DB_ReflectionDialogs_Queued(_Player,_ReflectionDialog);
		ProcRestoreSavedDialog(_Player);
		
		IF
		DialogStarted(_ReflectionDialog,_)
		AND
		DB_ReflectionDialogs_Queued(_,_ReflectionDialog)
		THEN
		// This will also restore the previous dialog
		ProcCancelReflectionDialog((STRING)_ReflectionDialog);
		
		IF
		TimerFinished(_ReflectionDialog)
		AND
		DB_ReflectionDialogs_Queued(_,_ReflectionDialog)
		THEN
		ProcCancelReflectionDialog((STRING)_ReflectionDialog);
		
		PROC
		PROC_GLOBAL_DialogStartRequested(_Player1,_Player2)
		AND
		DB_ReflectionDialogs_Queued((CHARACTERGUID)_Player1,_Dialog)
		AND
		DB_ReflectionDialogs_Queued((CHARACTERGUID)_Player2,_Dialog)
		AND
		IsTagged(_Player2,"AVATAR",1)
		THEN
		ProcStartReflectionDialog(_Player2,_Dialog);
		
		PROC
		ProcReflectionSaveDialogState((CHARACTERGUID)_Player)
		AND
		DB_Dialogs(_Player,_Dialog)
		THEN
		ProcRemoveAllDialogEntriesForSpeaker(_Player);
		DB_ReflectionSavedDialog(_Player,_Dialog);
		
		// Players that did not have any dialog before the reflection dialog (in practice: avatars)
		PROC
		ProcRestoreSavedDialog((CHARACTERGUID)_Player)
		AND
		NOT DB_ReflectionSavedDialog(_Player,_)
		THEN
		SetHasDialog(_Player,0);
		
		PROC
		ProcRestoreSavedDialog((CHARACTERGUID)_Player)
		AND
		DB_ReflectionSavedDialog(_Player,_Dialog)
		THEN
		DB_Dialogs(_Player,_Dialog);
		NOT DB_ReflectionSavedDialog(_Player,_Dialog);
		
		//END_REGION
		
		//REGION Starting the Reflection Dialog
		PROC
		ProcStartReflectionDialog((CHARACTERGUID)_Player1,(STRING)_ReflectionDialogName)
		AND
		NOT DB_ReflectionDialog_InProgress(_ReflectionDialogName,_)
		AND
		NOT DB_ReflectionDialog_Finished(_ReflectionDialogName)
		THEN
		Proc_ReflectionDialog_CollectPlayers(_Player1,_ReflectionDialogName);
		Proc_ReflectionDialog_Phase1(_Player1,_ReflectionDialogName);
		
		//Collect all available (nearby) players and add them to an indexed list, with the dialog started in pos 1.
		PROC
		Proc_ReflectionDialog_CollectPlayers((CHARACTERGUID)_Player1,(STRING)_ReflectionDialogName)
		THEN
		DB_ReflectionDialog_PlayerCount(_ReflectionDialogName,0);
		
		//Collect all avatars
		PROC
		Proc_ReflectionDialog_CollectPlayers((CHARACTERGUID)_Player1,(STRING)_ReflectionDialogName)
		AND
		DB_IsPlayer((CHARACTERGUID)_Player)
		AND
		IsTagged(_Player,"AVATAR",1)
		AND
		QRY_ReflectionDialog_ShouldCollect(_Player,_ReflectionDialogName,_Player1)
		AND
		QRY_SpeakerIsAvailableAndInDialogRange(_Player,_Player1)
		AND
		DB_ReflectionDialog_PlayerCount(_ReflectionDialogName,_Count)
		AND
		IntegerSum(_Count,1,_NewCount)
		THEN
		DB_ReflectionDialog_Players(_ReflectionDialogName,_Player,_NewCount);
		NOT DB_ReflectionDialog_PlayerCount(_ReflectionDialogName,_Count);
		DB_ReflectionDialog_PlayerCount(_ReflectionDialogName,_NewCount);
		
		//Collect all party companions
		PROC
		Proc_ReflectionDialog_CollectPlayers((CHARACTERGUID)_Player1,(STRING)_ReflectionDialogName)
		AND
		DB_IsPlayer((CHARACTERGUID)_Player)
		AND
		IsTagged(_Player,"AVATAR",0)
		AND
		CharacterIsPolymorphInteractionDisabled(_Player,0)
		AND
		IsTagged(_Player,"HENCHMAN",0)
		AND
		QRY_ReflectionDialog_ShouldCollect(_Player,_ReflectionDialogName,_Player1)
		AND
		QRY_SpeakerIsAvailableAndInDialogRange(_Player,_Player1)
		AND
		DB_ReflectionDialog_PlayerCount(_ReflectionDialogName,_Count)
		AND
		IntegerSum(_Count,1,_NewCount)
		AND
		_NewCount <= 4
		THEN
		DB_ReflectionDialog_Players(_ReflectionDialogName,_Player,_NewCount);
		NOT DB_ReflectionDialog_PlayerCount(_ReflectionDialogName,_Count);
		DB_ReflectionDialog_PlayerCount(_ReflectionDialogName,_NewCount);
		
		//REGION Collect Queries
		//Global RDs ignore party checks
		QRY
		QRY_ReflectionDialog_ShouldCollect((CHARACTERGUID)_Player,(STRING)_ReflectionDialogName,(CHARACTERGUID)_Player1)
		AND
		DB_GlobalReflectionDialog(_ReflectionDialogName)
		THEN
		DB_NOOP(1);
		
		//Check in Party
		QRY
		QRY_ReflectionDialog_ShouldCollect((CHARACTERGUID)_Player,(STRING)_ReflectionDialogName,(CHARACTERGUID)_Player1)
		AND
		NOT DB_GlobalReflectionDialog(_ReflectionDialogName)
		AND
		CharacterIsInPartyWith(_Player,_Player1,1)
		THEN
		DB_NOOP(1);
		
		//END_REGION
		
		PROC
		Proc_ReflectionDialog_CollectPlayers((CHARACTERGUID)_Player1,(STRING)_ReflectionDialogName)
		AND
		DB_ReflectionDialog_PlayerCount(_ReflectionDialogName,_Count)
		THEN
		NOT DB_ReflectionDialog_PlayerCount(_ReflectionDialogName,_Count);
		//END_REGION
		
		
		//REGION Phase 1
		PROC
		Proc_ReflectionDialog_Phase1((CHARACTERGUID)_Player1,(STRING)_ReflectionDialogName)
		THEN
		Proc_StartDialog(0,"ReflectionDialogWrapper",_Player1);
		DB_ReflectionWrapperStarted(_ReflectionDialogName,(GUIDSTRING)_Player1);
		
		IF
		DialogStarted("ReflectionDialogWrapper",_ID)
		AND
		DB_DialogPlayers(_ID,_Player1,1)
		AND
		DB_ReflectionWrapperStarted(_ReflectionDialogName,_Player1)
		THEN
		DB_ReflectionDialog_InProgress(_ReflectionDialogName,_ID);
		//Start looping over all available players starting from the first.
		DB_ReflectionDialog_Phase1_Index(1);
		Proc_ReflectionDialog_Phase1_NextPlayer(_ReflectionDialogName,1);
		
		IF
		DialogEnded("ReflectionDialogWrapper",_ID)
		AND
		DB_DialogPlayers(_ID,_Player1,1)
		AND
		DB_ReflectionWrapperStarted(_ReflectionDialogName,_Player1)
		AND
		DB_ReflectionDialog_Players(_ReflectionDialogName,_Player,_Index)
		THEN
		NOT DB_ReflectionDialog_Players(_ReflectionDialogName,_Player,_Index);
		Proc_ReflectionDialogDone(_ReflectionDialogName,(CHARACTERGUID)_Player1);
		
		PROC
		Proc_ReflectionDialogDone((STRING)_ReflectionDialogName,(CHARACTERGUID)_Player)
		THEN
		DB_NOOP(1);
		
		IF
		DialogEnded("ReflectionDialogWrapper",_ID)
		AND
		DB_DialogPlayers(_ID,_Player1,1)
		AND
		DB_ReflectionWrapperStarted(_ReflectionDialogName,_Player1)
		THEN
		NOT DB_ReflectionWrapperStarted(_ReflectionDialogName,_Player1);
		
		//If a character does NOT exist at that index, all characters were exhausted, finish.
		PROC
		Proc_ReflectionDialog_Phase1_NextPlayer((STRING)_ReflectionDialogName,(INTEGER)_Index)
		AND
		NOT DB_ReflectionDialog_Players(_ReflectionDialogName,_,_Index)
		AND
		DB_ReflectionDialog_InProgress(_ReflectionDialogName,_InstanceID)
		THEN
		NOT DB_ReflectionDialog_Phase1_Index(_Index);
		NOT DB_ReflectionDialog_InProgress(_ReflectionDialogName,_InstanceID);
		DB_ReflectionDialog_Finished(_ReflectionDialogName);
		DialogResume(_InstanceID);
		
		
		PROC
		ProcCheckLastReflectionPlayer((CHARACTERGUID)_Player,(STRING)_ReflectionDialogName,(INTEGER)_Index)
		AND
		IntegerSum(1,_Index,_NextIndex)
		AND
		NOT DB_ReflectionDialog_Players(_ReflectionDialogName,_,_NextIndex)
		THEN
		ObjectSetFlag(_Player,"GLO_IsLastPlayerInReflectionDialog");
		
		PROC
		ProcCheckLastReflectionPlayer((CHARACTERGUID)_Player,(STRING)_ReflectionDialogName,(INTEGER)_Index)
		AND
		IntegerSum(1,_Index,_NextIndex)
		AND
		DB_ReflectionDialog_Players(_ReflectionDialogName,_,_NextIndex)
		THEN
		ObjectClearFlag(_Player,"GLO_IsLastPlayerInReflectionDialog",0);
		
		//If a character exist at that index, start a dialog with that character as first speaker
		PROC
		Proc_ReflectionDialog_Phase1_NextPlayer((STRING)_ReflectionDialogName,(INTEGER)_Index)
		AND
		DB_ReflectionDialog_Players(_ReflectionDialogName,_Player,_Index)
		AND
		DB_ReflectionDialog_PlayerIdentifier(_Index,_PlayerIdentifier)
		AND
		DB_ReflectionDialog_InProgress(_ReflectionDialogName,_InstanceID)
		AND
		DB_ReflectionWrapperStarted(_ReflectionDialogName,_Player1)
		THEN
		ProcCheckLastReflectionPlayer(_Player,_ReflectionDialogName,_Index);
		SetTag(_Player,_PlayerIdentifier);
		Proc_PartyDecisionDialog_DoDialogWithObservers(_Player,_ReflectionDialogName,_InstanceID,0);
		ProcObjectTimer(_Player1,"ReflectionDialogFallbackTimer",2000);
		
		IF
		DialogStarted(_ReflectionDialogName,_Inst)
		AND
		DB_ReflectionWrapperStarted(_ReflectionDialogName,_Player1)
		THEN
		ProcObjectTimerCancel(_Player1,"ReflectionDialogFallbackTimer");
		
		//Fallback if a Partydialog refused to start up.
		PROC
		ProcObjectTimerFinished(_Player1,"ReflectionDialogFallbackTimer")
		AND
		DB_ReflectionWrapperStarted(_ReflectionDialogName,_Player1)
		AND
		DB_ReflectionDialog_Phase1_Index(_Index)
		AND
		IntegerSum(_Index,1,_NewIndex)
		AND
		DB_DialogPlayers(_Inst,_Player,1)
		AND
		DB_ReflectionDialog_PlayerIdentifier(_Index,_PlayerIdentifier)
		THEN
		ClearTag(_Player,_PlayerIdentifier);
		NOT DB_ReflectionDialog_Phase1_Index(_Index);
		DB_ReflectionDialog_Phase1_Index(_NewIndex);
		ObjectClearFlag(_Player,"GLO_IsLastPlayerInReflectionDialog",0);
		Proc_ReflectionDialog_Phase1_NextPlayer(_ReflectionDialogName,_NewIndex);
		
		
		//A dialog in phase 1 is done, try again with index + 1
		IF
		DialogEnded(_ReflectionDialogName,_Inst)
		AND
		DB_ReflectionDialog_InProgress(_ReflectionDialogName,_)
		AND
		DB_ReflectionDialog_Phase1_Index(_Index)
		AND
		IntegerSum(_Index,1,_NewIndex)
		AND
		DB_DialogPlayers(_Inst,_Player,1)
		AND
		DB_ReflectionDialog_PlayerIdentifier(_Index,_PlayerIdentifier)
		THEN
		ClearTag(_Player,_PlayerIdentifier);
		NOT DB_ReflectionDialog_Phase1_Index(_Index);
		DB_ReflectionDialog_Phase1_Index(_NewIndex);
		ObjectClearFlag(_Player,"GLO_IsLastPlayerInReflectionDialog",0);
		Proc_ReflectionDialog_Phase1_NextPlayer(_ReflectionDialogName,_NewIndex);
		//END_REGION
		
		
		//REGION Remove individual from an RD
		// First count how many people are left for the RD: if only one is left after this player,
		// then cancel it altogether since there's no one left to reflect with
		PROC
		Proc_ReflectionDialog_CancelForPlayer((CHARACTERGUID)_Player)
		AND
		DB_ReflectionDialogs_Queued(_Player,_ReflectionDialog)
		THEN
		// If the RD was nor queued for this player, we won't declare the counter and hence
		// none of the following will execute either since they all either
		// check DB_ReflectionDialogs_Queued(_Player,_ReflectionDialog) or the counter
		ProcDeclareCounter("ReflectionDialog_CountRemainingQueuedReflectionPlayers");
		
		PROC
		Proc_ReflectionDialog_CancelForPlayer((CHARACTERGUID)_Player)
		AND
		DB_ReflectionDialogs_Queued(_Player,_ReflectionDialog)
		AND
		DB_ReflectionDialogs_Queued(_OtherPlayer,_ReflectionDialog)
		THEN
		ProcIncreaseCounter("ReflectionDialog_CountRemainingQueuedReflectionPlayers");
		
		// Two people (or fewer, although that should never happen for the RD ->
		// kill the RD since after removing this one there will be at most one left
		PROC
		Proc_ReflectionDialog_CancelForPlayer((CHARACTERGUID)_Player)
		AND
		DB_GlobalCounter("ReflectionDialog_CountRemainingQueuedReflectionPlayers",_Count)
		AND
		_Count <= 2
		AND
		DB_ReflectionDialogs_Queued(_Player,_ReflectionDialog)
		THEN
		ProcCancelReflectionDialog(_ReflectionDialog);
		
		// Three or more people left -> just remove this one
		PROC
		Proc_ReflectionDialog_CancelForPlayer((CHARACTERGUID)_Player)
		AND
		DB_GlobalCounter("ReflectionDialog_CountRemainingQueuedReflectionPlayers",_Count)
		AND
		_Count > 2
		AND
		DB_ReflectionDialogs_Queued(_Player,_ReflectionDialog)
		THEN
		ProcRestorePlayerToBeforeReflectionDialog(_Player,_ReflectionDialog);
		
		// Clean up
		PROC
		Proc_ReflectionDialog_CancelForPlayer((CHARACTERGUID)_Player)
		THEN
		ProcRemoveCounter("ReflectionDialog_CountRemainingQueuedReflectionPlayers");
		//END_REGION
		
	}
	EXIT
	{
		
	}
}
Goal(37).Title("_GLOBAL_Shared_RelationshipDialogs");
Goal(37)
{
	INIT
	{
		DB_LoopEffectDisabledInCombat("RS3_FX_UI_PersonIcon_01");
		
	}
	KB
	{
		IF
		GlobalFlagSet("GLO_DisableRelationshipDialogsPermanently")
		THEN
		GoalCompleted;
		
		PROC
		Proc_RelationshipDialog((CHARACTERGUID)_Companion,(STRING)_Dialog,(CHARACTERGUID)_Anchor)
		AND
		NOT DB_Dead(_Companion)
		AND
		DB_CompanionAvatarBond(_Companion,_)
		AND
		NOT DB_RelationshipDialogsFinished(_Companion,_Dialog)
		AND
		NOT DB_HandlingRelationshipDialog(_Companion,_Dialog)
		AND
		GetDistanceTo(_Companion,_Anchor,_Dist)
		AND
		_Dist < 30.0
		THEN
		DB_RelationshipDialog_Queue(_Companion,_Dialog);
		ProcLaunchTestCompanionQueueTimer();
		
		PROC
		ProcLaunchTestCompanionQueueTimer()
		AND
		NOT DB_TestingCompanionQueue(1)
		THEN
		DB_TestingCompanionQueue(1);
		TimerLaunch("Test_RelationshipDialog_Queue",1500);
		
		IF
		TimerFinished("Test_RelationshipDialog_Queue")
		THEN
		NOT DB_TestingCompanionQueue(1);
		Proc_Test_RelationshipDialog_Queue();
		
		IF
		DialogEnded(_Dialog,_)
		AND
		DB_HandlingRelationshipDialog(_Companion,_Dialog)
		THEN
		PROC_StopLoopEffect(_Companion,"RelationshipMarker");
		NOT DB_HandlingRelationshipDialog(_Companion,_Dialog);
		DB_RelationshipDialogsFinished(_Companion,_Dialog);
		
		IF
		DialogEnded(_,_Instance)
		AND
		DB_DialogPlayers(_Instance,_Companion,1)
		AND
		DB_RelationshipDialog_Queue((CHARACTERGUID)_Companion,_Dialog)
		THEN
		Proc_Test_RelationshipDialog_Queue();
		
		IF
		CharacterDied(_Companion)
		AND
		IsTagged(_Companion,"AVATAR",0)
		THEN
		ProcCancelAllRelationshipDialogs(_Companion);
		
		PROC
		Proc_Test_RelationshipDialog_Queue()
		AND
		DB_RelationshipDialog_Queue((CHARACTERGUID)_Companion,(STRING)_Dialog)
		AND
		NOT DB_ReflectionDialogs_Queued(_Companion,_)
		AND
		NOT DB_HandlingRelationshipDialog(_Companion,_)
		THEN
		DB_HandlingRelationshipDialog(_Companion,_Dialog);
		NOT DB_RelationshipDialog_Queue(_Companion,_Dialog);
		PROC_LoopEffect("RS3_FX_UI_PersonIcon_01",_Companion,"RelationshipMarker","__ANY__","Dummy_OverheadFX");
		DB_RelationshipDialogs(_Companion,_Dialog);
		
		IF
		DB_ReflectionDialogs_Queued(_Companion,_)
		AND
		DB_RelationshipDialogs(_Companion,_Dialog)
		THEN
		PROC_StopLoopEffect(_Companion,"RelationshipMarker");
		NOT DB_HandlingRelationshipDialog(_Companion,_Dialog);
		NOT DB_RelationshipDialogs(_Companion,_Dialog);
		DB_RelationshipDialog_Queue(_Companion,_Dialog);
		
		PROC
		ProcCancelAllRelationshipDialogsForAllCompanions()
		AND
		DB_IsPlayer(_Companion)
		AND
		IsTagged(_Companion,"AVATAR",0)
		THEN
		ProcCancelAllRelationshipDialogs(_Companion);
		
		PROC
		ProcCancelAllRelationshipDialogs((CHARACTERGUID)_Companion)
		AND
		DB_HandlingRelationshipDialog(_Companion,_Dialog)
		THEN
		PROC_StopLoopEffect(_Companion,"RelationshipMarker");
		NOT DB_HandlingRelationshipDialog(_Companion,_Dialog);
		NOT DB_RelationshipDialogs(_Companion,_Dialog);
		
		PROC
		ProcCancelAllRelationshipDialogs((CHARACTERGUID)_Companion)
		AND
		DB_RelationshipDialog_Queue((CHARACTERGUID)_Companion,(STRING)_Dialog)
		THEN
		NOT DB_RelationshipDialog_Queue(_Companion,_Dialog);
		
		PROC
		ProcCancelOneRelationshipDialog((CHARACTERGUID)_Companion,(STRING)_Dialog)
		AND
		DB_HandlingRelationshipDialog(_Companion,_Dialog)
		THEN
		PROC_StopLoopEffect(_Companion,"RelationshipMarker");
		NOT DB_HandlingRelationshipDialog(_Companion,_Dialog);
		NOT DB_RelationshipDialogs(_Companion,_Dialog);
		
		PROC
		ProcCancelOneRelationshipDialog((CHARACTERGUID)_Companion,(STRING)_Dialog)
		AND
		DB_RelationshipDialog_Queue((CHARACTERGUID)_Companion,(STRING)_Dialog)
		THEN
		NOT DB_RelationshipDialog_Queue(_Companion,_Dialog);
		
		PROC
		ProcCancelOneRelationshipDialog((CHARACTERGUID)_Companion,(STRING)_Dialog)
		THEN
		DB_RelationshipDialogsFinished(_Companion,_Dialog);
		
	}
	EXIT
	{
		
	}
}
Goal(38).Title("_GLOBAL_Shared_Shapeshifting");
Goal(38)
{
	INIT
	{
		DB_Shapeshifting_OriginalRaces("Undead_Dwarf", "REALLY_DWARF");
		DB_Shapeshifting_OriginalRaces("Undead_Human", "REALLY_HUMAN");
		DB_Shapeshifting_OriginalRaces("Undead_Elf", "REALLY_ELF");
		DB_Shapeshifting_OriginalRaces("Undead_Lizard", "REALLY_LIZARD");
		
	}
	KB
	{
		PROC
		ProcRemovePolymorphs((CHARACTERGUID)_Char)
		THEN
		RemoveStatus(_Char,"POLYMORPHED");
		
		PROC
		ProcRemovePolymorphs((CHARACTERGUID)_Char)
		AND
		DB_CharacterPolymorphedInto(_Char,_Race)
		AND
		DB_PolymorphStatuses(_Race,(STRING)_Status)
		THEN
		RemoveStatus(_Char,_Status);
		
		IF
		CharacterPolymorphedInto(_Char,_Race)
		THEN
		DB_CharacterPolymorphedInto(_Char,_Race);
		ObjectSetFlag(_Char,"GLO_Polymorphed");
		
		IF
		CharacterPolymorphedInto(_Char,_)
		AND
		DB_PolymorphTags(_Char,(STRING)_Tag)
		THEN
		SetTag(_Char,_Tag);
		
		IF
		CharacterPolymorphedInto(_Char,_)
		AND
		NOT DB_PolymorphTags(_Char,_)
		THEN
		SetTag(_Char,"SHAPESHIFT_GENERIC");
		
		IF
		CharacterPolymorphedInto(_Char,_)
		THEN
		SetTag(_Char,"GENERIC");
		
		IF 
		CharacterStoppedPolymorph(_Char)
		AND
		DB_PolymorphTags(_Char,_)
		THEN
		ClearTag(_Char,"GENERIC");
		
		IF 
		CharacterStoppedPolymorph(_Char)
		AND
		DB_PolymorphTags(_Char,_Tag)
		THEN
		ClearTag(_Char,_Tag);
		
		IF 
		CharacterStoppedPolymorph(_Char)
		THEN
		ClearTag(_Char,"SHAPESHIFT_GENERIC");
		ObjectClearFlag(_Char,"GLO_Polymorphed");
		
		IF 
		CharacterStoppedPolymorph(_Char)
		AND
		DB_CharacterPolymorphedInto(_Char,_Race)
		THEN
		NOT DB_CharacterPolymorphedInto(_Char,_Race);
		
		//REGION Polymorph block in dialogs
		PROC
		Proc_DialogFlagSetup((STRING)_Dialog,(GUIDSTRING)_Speaker1)
		AND
		DB_BlockPolymorphDialog(_Dialog)
		THEN
		ProcRemovePolymorphsFromPlayer(_Speaker1);
		
		PROC
		Proc_DialogFlagSetup((STRING)_Dialog,(GUIDSTRING)_Speaker1,(GUIDSTRING)_Speaker2)
		AND
		DB_BlockPolymorphDialog(_Dialog)
		THEN
		ProcRemovePolymorphsFromPlayer(_Speaker1);
		ProcRemovePolymorphsFromPlayer(_Speaker2);
		
		PROC
		Proc_DialogFlagSetup((STRING)_Dialog,(GUIDSTRING)_Speaker1,(GUIDSTRING)_Speaker2,(GUIDSTRING)_Speaker3)
		AND
		DB_BlockPolymorphDialog(_Dialog)
		THEN
		ProcRemovePolymorphsFromPlayer(_Speaker1);
		ProcRemovePolymorphsFromPlayer(_Speaker2);
		ProcRemovePolymorphsFromPlayer(_Speaker3);
		
		PROC
		Proc_DialogFlagSetup((STRING)_Dialog,(GUIDSTRING)_Speaker1,(GUIDSTRING)_Speaker2,(GUIDSTRING)_Speaker3,(GUIDSTRING)_Speaker4)
		AND
		DB_BlockPolymorphDialog(_Dialog)
		THEN
		ProcRemovePolymorphsFromPlayer(_Speaker1);
		ProcRemovePolymorphsFromPlayer(_Speaker2);
		ProcRemovePolymorphsFromPlayer(_Speaker3);
		ProcRemovePolymorphsFromPlayer(_Speaker4);
		
		PROC
		Proc_DialogFlagSetup((STRING)_Dialog,(GUIDSTRING)_Speaker1,(GUIDSTRING)_Speaker2,(GUIDSTRING)_Speaker3,(GUIDSTRING)_Speaker4,(GUIDSTRING)_Speaker5)
		AND
		DB_BlockPolymorphDialog(_Dialog)
		THEN
		ProcRemovePolymorphsFromPlayer(_Speaker1);
		ProcRemovePolymorphsFromPlayer(_Speaker2);
		ProcRemovePolymorphsFromPlayer(_Speaker3);
		ProcRemovePolymorphsFromPlayer(_Speaker4);
		ProcRemovePolymorphsFromPlayer(_Speaker5);
		
		PROC
		Proc_DialogFlagSetup((STRING)_Dialog,(GUIDSTRING)_Speaker1,(GUIDSTRING)_Speaker2,(GUIDSTRING)_Speaker3,(GUIDSTRING)_Speaker4,(GUIDSTRING)_Speaker5,(GUIDSTRING)_Speaker6)
		AND
		DB_BlockPolymorphDialog(_Dialog)
		THEN
		ProcRemovePolymorphsFromPlayer(_Speaker1);
		ProcRemovePolymorphsFromPlayer(_Speaker2);
		ProcRemovePolymorphsFromPlayer(_Speaker3);
		ProcRemovePolymorphsFromPlayer(_Speaker4);
		ProcRemovePolymorphsFromPlayer(_Speaker5);
		ProcRemovePolymorphsFromPlayer(_Speaker6);
		
		PROC
		ProcRemovePolymorphsFromPlayer((GUIDSTRING)_Object)
		AND
		DB_IsPlayer((CHARACTERGUID)_Object)
		THEN
		ProcRemovePolymorphs(_Object);
		//END_REGION
		
		//REGION Remove Poly in Dialog
		
		IF
		TextEventSet("addpolyflag")
		AND
		CharacterGetHostCharacter(_Player)
		THEN
		ObjectSetFlag(_Player,"GLO_Polymorphed");
		
		
		IF
		ObjectFlagSet("GLO_RemovePolymorph",(CHARACTERGUID)_Player,_)
		THEN
		ProcRemovePolymorphs(_Player);
		ObjectClearFlag(_Player,"GLO_RemovePolymorph");
		
		//END_REGION
		
		//REGION Shapeshift form reserving
		PROC
		ProcReservePolymorphShapes((CHARACTERGUID)_Char)
		AND
		DB_PolymorphStatuses(_Race,_)
		THEN
		CharacterReservePolymorphShape(_Char,_Race);
		
		IF
		DB_IsPlayer(_Char)
		THEN
		ProcReservePolymorphShapes(_Char);
		ProcMarkUndeadOrigin(_Char);
		
		PROC
		ProcCheckRemoveOtherOrigins()
		AND
		DB_InCharacterCreation(0)
		AND
		DB_IsPlayer(_Player)
		THEN
		ProcReservePolymorphShapes(_Player);
		ProcMarkUndeadOrigin(_Player);
		
		IF
		CharacterCreationFinished((CHARACTERGUID)NULL_00000000-0000-0000-0000-000000000000)
		AND
		DB_IsPlayer(_Player)
		THEN
		ProcReservePolymorphShapes(_Player);
		ProcMarkUndeadOrigin(_Player);
		
		//END_REGION
		
		//REGION Undead origins
		PROC
		ProcMarkUndeadOrigin((CHARACTERGUID)_Player)
		AND
		IsTagged(_Player,"UNDEAD",1)
		THEN
		DB_UndeadCharacter(_Player);
		//END_REGION
		
		//REGION Get current polymorph status for _Char (even if none)
		// Returns it in DB_GLOBAL_Shapeshifting_PolymorphStatus(_Race). In case not polymorphed, _Race is an empty string
		QRY
		QRY_GLOBAL_Shapeshifting_GetPolymorphStatus((CHARACTERGUID)_Char)
		AND
		DB_GLOBAL_Shapeshifting_PolymorphStatus(_Race)
		THEN
		NOT DB_GLOBAL_Shapeshifting_PolymorphStatus(_Race);
		
		QRY
		QRY_GLOBAL_Shapeshifting_GetPolymorphStatus((CHARACTERGUID)_Char)
		AND
		DB_CharacterPolymorphedInto(_Char,_Race)
		THEN
		DB_GLOBAL_Shapeshifting_PolymorphStatus(_Race);
		
		QRY
		QRY_GLOBAL_Shapeshifting_GetPolymorphStatus((CHARACTERGUID)_Char)
		AND
		NOT DB_CharacterPolymorphedInto(_Char,_)
		THEN
		DB_GLOBAL_Shapeshifting_PolymorphStatus("");
		//END_REGION
		
		//REGION True race query
		QRY
		QRY_IsTrueRace((CHARACTERGUID)_Character,(STRING)_Race)
		AND
		CharacterGetRace(_Character,0,_Race)
		THEN
		DB_NOOP(1);
		
		QRY
		QRY_IsTrueUndead((CHARACTERGUID)_Character)
		AND
		CharacterGetRace(_Character,0,_TrueRace)
		AND
		DB_UndeadRacePresets((INTEGER)_,_TrueRace)
		THEN
		DB_NOOP(1);
		
		//END_REGION
		
		IF
		TextEventSet("getrace")
		AND
		CharacterGetHostCharacter(_Player)
		AND
		CharacterGetRace(_Player,0,_TrueRace)
		THEN
		DebugText(_Player,_TrueRace);
		
		//REGION Keeping track of true race
		IF
		DB_IsPlayer(_Player)
		THEN
		PROC_GLO_SetOriginalRaceTag(_Player);
		
		PROC
		PROC_GLO_SetOriginalRaceTag((CHARACTERGUID)_Player)
		AND
		CharacterGetRace(_Player, 0, _TrueRace)
		AND
		DB_Shapeshifting_OriginalRaces(_TrueRace, (STRING)_Tag)
		THEN
		SetTag(_Player, _Tag);
		
		//END_REGION
		
	}
	EXIT
	{
		
	}
}
Goal(39).Title("_GLOBAL_Subregions");
Goal(39)
{
	INIT
	{
		//When you need to mark the subregion's location on the map:
		//	Use this fact with a 1 as the last value when the subregion's string ID is identical to the marker's ID
		//		DB_Subregion((TRIGGERGUID)_Trigger,(STRING)_,(INTEGER)_)
		//	Use when the marker was defined with a different ID than the subregion's name
		//		DB_SubregionMarker(_Trigger,_Message,_Marker)
		
	}
	KB
	{
		IF
		DB_Subregion((TRIGGERGUID)_Trigger,(STRING)_,(INTEGER)_)
		THEN
		ProcTriggerRegisterForPlayers(_Trigger);
		
		IF
		DB_SubregionMarker((TRIGGERGUID)_Trigger,(STRING)_,(STRING)_) 
		THEN
		ProcTriggerRegisterForPlayers(_Trigger);
		
		IF
		CharacterEnteredTrigger(_Character,_Trigger)
		AND
		DB_Subregion(_Trigger,_Message,_ShowMarker)
		THEN
		CharacterEnteredSubRegion(_Character,_Message);
		ProcCheckSetRegionMarker(_Message,_ShowMarker,_Character);
		
		IF
		CharacterEnteredTrigger(_Character,_Trigger)
		AND
		DB_SubregionMarker(_Trigger,_Message,_Marker)
		THEN
		CharacterEnteredSubRegion(_Character,_Message);
		ProcCheckSetRegionMarker(_Marker,1,_Character);
		
		PROC
		ProcCheckSetRegionMarker((STRING)_Message,1,(CHARACTERGUID)_Character)
		AND
		DB_IsPlayer(_Character)
		THEN
		ProcShowMarker(_Character,_Message);
		
		
		
		
		
	}
	EXIT
	{
		
	}
}
Goal(40).Title("_GLOBAL_TeleporterPyramids");
Goal(40)
{
	INIT
	{
		// PUBLIC PROCs:
		//   Proc_PyramidBlockerTriggerAdd	    - add trigger that blocks pyramid usage
		//   Proc_PyramidBlockerTriggerRemove   - remove trigger from blocking list
		//   Proc_PyramidGlobalBlockerOn        - global pyramids blocker turn on
		//   Proc_PyramidGlobalBlockerOff       - global pyramids blocker turn off
		//   Proc_PyramidCustomBlockAdd         - add custom blocker of a pyramid (used for Tenebrium chests)
		//   Proc_PyramidCustomBlockRemove      - remove custom blocker of a pyramid (used for Tenebrium chests)
		
		
		// Inner DBs:
		//   DB_TeleporterPyramidUnlocked((ITENGUID)_Pyramid) - the ones found by players
		//   DB_PyramidBlockerTrigger((TRIGGERGUID)_Trigger) 	- trigger blockers of pyramid usage
		//   DB_PyramidUsageBlocked(1) 						- global pyramid blocker
		//   DB_PyramidInBlockerTrigger((ITEMGUID)_Pyramid,(TRIGGERGUID)_Trigger)  - used to store which pyramids are in blocking triggers
		//   DB_PyramidCustomBlock((ITEMGUID)_Pyramid,(STRING)_Reason)             - used to store which pyramids are customly blocked
		
	}
	KB
	{
		//REGION Debug
		//END_REGION
		
		IF
		DB_TeleporterPyramid(_Pyramid)
		THEN
		ItemSetForceSynch(_Pyramid,1);
		
		//REGION Unlock pyramids that were found by player
		IF
		ItemAddedToCharacter(_Pyramid,_Player)
		AND
		DB_TeleporterPyramid(_Pyramid)
		AND
		NOT DB_TeleporterPyramidUnlocked(_Pyramid)
		AND
		_Player.DB_IsPlayer()
		THEN
		DB_TeleporterPyramidUnlocked(_Pyramid);
		
		IF
		CharacterUsedItem(_Player,_Pyramid)
		AND
		DB_TeleporterPyramid(_Pyramid)
		AND
		NOT DB_TeleporterPyramidUnlocked(_Pyramid)
		AND
		_Player.DB_IsPlayer()
		THEN
		PROC_CheckPlayTut(_Player,"TUT_PyramidsPickup");
		//END_REGION
		
		
		//REGION Pyramid blockers
		PROC
		Proc_PyramidGlobalBlockerOn()
		THEN
		DB_PyramidUsageBlocked(1);
		
		PROC
		Proc_PyramidGlobalBlockerOn()
		AND
		DB_TeleporterPyramid(_Pyramid)
		THEN
		DisablePyramid(_Pyramid);
		
		PROC
		Proc_PyramidGlobalBlockerOff()
		THEN
		NOT DB_PyramidUsageBlocked(1);
		
		PROC
		Proc_PyramidGlobalBlockerOff()
		AND
		DB_TeleporterPyramid(_Pyramid)
		THEN
		Proc_PyramidCheckEnabled(_Pyramid);
		
		
		PROC
		Proc_PyramidBlockerTriggerAdd((TRIGGERGUID)_Trigger)
		THEN
		DB_PyramidBlockerTrigger(_Trigger);
		TriggerRegisterForItems(_Trigger);
		ProcTriggerRegisterForPlayers(_Trigger);
		
		PROC
		Proc_PyramidBlockerTriggerRemove((TRIGGERGUID)_Trigger)
		THEN
		NOT DB_PyramidBlockerTrigger(_Trigger);
		TriggerUnregisterForItems(_Trigger);
		ProcTriggerUnregisterForPlayers(_Trigger);
		
		PROC
		Proc_PyramidCustomBlockAdd((ITEMGUID)_Pyramid,(STRING)_Reason)
		THEN
		DisablePyramid(_Pyramid);
		DB_PyramidCustomBlock(_Pyramid,_Reason);
		
		PROC
		Proc_PyramidCustomBlockRemove((ITEMGUID)_Pyramid,(STRING)_Reason)
		THEN
		NOT DB_PyramidCustomBlock(_Pyramid,_Reason);
		Proc_PyramidCheckEnabled(_Pyramid);
		
		
		// Pyramid entered/left blocking trigger inside of character's inventory
		IF
		CharacterEnteredTrigger(_Char,_Trigger)
		AND
		DB_PyramidBlockerTrigger(_Trigger)
		AND
		DB_TeleporterPyramid(_Pyramid)
		AND
		ItemIsInCharacterInventory(_Pyramid,_Char,1)
		THEN
		Proc_PyramidEnterBlockerTrigger(_Pyramid,_Trigger);
		
		IF
		CharacterLeftTrigger(_Char,_Trigger)
		AND
		DB_PyramidBlockerTrigger(_Trigger)
		AND
		DB_TeleporterPyramid(_Pyramid)
		AND
		ItemIsInCharacterInventory(_Pyramid,_Char,1)
		AND
		DB_PyramidInBlockerTrigger(_Pyramid,_Trigger)
		THEN
		Proc_PyramidLeaveBlockerTrigger(_Pyramid,_Trigger);
		
		
		// Pyramid entered/left blocking trigger
		IF
		ItemEnteredTrigger(_Pyramid,_Trigger,_)
		AND
		DB_TeleporterPyramid(_Pyramid)
		AND
		DB_PyramidBlockerTrigger(_Trigger)
		THEN
		Proc_PyramidEnterBlockerTrigger(_Pyramid,_Trigger);
		
		IF
		ItemLeftTrigger(_Pyramid,_Trigger,_)
		AND
		DB_PyramidInBlockerTrigger(_Pyramid,_Trigger)
		THEN
		Proc_PyramidLeaveBlockerTrigger(_Pyramid,_Trigger);
		
		
		// Pyramid entered/left blocking trigger inside of another container
		IF
		ItemEnteredTrigger(_Container,_Trigger,_)
		AND
		DB_PyramidBlockerTrigger(_Trigger)
		AND
		DB_TeleporterPyramid(_Pyramid)
		AND
		GetInventoryOwner(_Pyramid,_Container)
		THEN
		Proc_PyramidEnterBlockerTrigger(_Pyramid,_Trigger);
		
		IF
		ItemLeftTrigger(_Container,_Trigger,_)
		AND
		DB_PyramidInBlockerTrigger(_Pyramid,_Trigger)
		AND
		GetInventoryOwner(_Pyramid,_Container)
		THEN
		Proc_PyramidLeaveBlockerTrigger(_Pyramid,_Trigger);
		
		
		// Added to container - remove old triggers that this container is not inside
		IF
		ItemAddedToContainer(_Pyramid,_)
		AND
		DB_TeleporterPyramid(_Pyramid)
		AND
		GetInventoryOwner(_Pyramid,_TopCont)
		AND
		DB_PyramidInBlockerTrigger(_Pyramid,_Trigger)
		AND
		ObjectIsInTrigger(_TopCont,_Trigger,0)
		THEN
		Proc_PyramidLeaveBlockerTrigger(_Pyramid,_Trigger);
		
		IF
		ItemAddedToContainer(_Pyramid,_)
		AND
		DB_TeleporterPyramid(_Pyramid)
		AND
		GetInventoryOwner(_Pyramid,_TopCont)
		AND
		DB_PyramidBlockerTrigger(_Trigger)
		AND
		ObjectIsInTrigger(_TopCont,_Trigger,1)
		THEN
		Proc_PyramidEnterBlockerTrigger(_Pyramid,_Trigger);
		
		IF
		ItemRemovedFromContainer(_Pyramid,_Container)
		AND
		DB_TeleporterPyramid(_Pyramid)
		AND
		DB_PyramidInBlockerTrigger(_Pyramid,_Trigger)
		AND
		ObjectIsInTrigger(_Container,_Trigger,1)
		THEN
		Proc_PyramidLeaveBlockerTrigger(_Pyramid,_Trigger);
		
		IF
		ItemRemovedFromContainer(_Pyramid,_Container)
		AND
		DB_TeleporterPyramid(_Pyramid)
		AND
		DB_PyramidInBlockerTrigger(_Pyramid,_Trigger)
		AND
		GetInventoryOwner(_Container,_TopCont)
		AND
		ObjectIsInTrigger(_TopCont,_Trigger,1)
		THEN
		Proc_PyramidLeaveBlockerTrigger(_Pyramid,_Trigger);
		
		IF
		ItemAddedToCharacter(_Pyramid,_Character)
		AND
		DB_TeleporterPyramid(_Pyramid)
		AND
		DB_PyramidBlockerTrigger(_Trigger)
		AND
		ObjectIsInTrigger(_Character,_Trigger,1)
		THEN
		Proc_PyramidEnterBlockerTrigger(_Pyramid,_Trigger);
		
		IF
		ItemRemovedFromCharacter(_Pyramid,_Character)
		AND
		DB_TeleporterPyramid(_Pyramid)
		AND
		DB_PyramidBlockerTrigger(_Trigger)
		AND
		ObjectIsInTrigger(_Character,_Trigger,1)
		THEN
		Proc_PyramidLeaveBlockerTrigger(_Pyramid,_Trigger);
		
		
		PROC
		Proc_PyramidEnterBlockerTrigger((ITEMGUID)_Pyramid,(TRIGGERGUID)_Trigger)
		THEN
		DisablePyramid(_Pyramid);
		DB_PyramidInBlockerTrigger(_Pyramid,_Trigger);
		
		PROC
		Proc_PyramidLeaveBlockerTrigger((ITEMGUID)_Pyramid,(TRIGGERGUID)_Trigger)
		THEN
		NOT DB_PyramidInBlockerTrigger(_Pyramid,_Trigger);
		Proc_PyramidCheckEnabled(_Pyramid);
		
		
		PROC
		Proc_PyramidCheckEnabled((ITEMGUID)_Pyramid)
		AND
		NOT DB_PyramidUsageBlocked(1)
		AND
		DB_TeleporterPyramid(_Pyramid)
		AND
		NOT DB_PyramidInBlockerTrigger(_Pyramid,_)
		AND
		NOT DB_PyramidCustomBlock(_Pyramid,_)
		THEN
		EnablePyramid(_Pyramid);
		//END_REGION
		
		
		//REGION Level transitions
		IF
		RegionEnded(_Region)
		AND
		DB_TeleporterPyramidUnlocked(_Pyramid)
		AND
		GetRegion(_Pyramid,_Region)
		AND
		GetInventoryOwner(_Pyramid,_TopContainer)
		AND
		NOT DB_IsPlayer((CHARACTERGUID)_TopContainer)
		AND
		ItemGetOriginalOwner(_Pyramid,_Owner)
		THEN
		ItemToInventory(_Pyramid,_Owner,-1);
		
		IF
		RegionEnded(_Region)
		AND
		DB_TeleporterPyramidUnlocked(_Pyramid)
		AND
		GetRegion(_Pyramid,_Region)
		AND
		NOT GetInventoryOwner(_Pyramid,_)
		AND
		ItemGetOriginalOwner(_Pyramid,_Owner)
		THEN
		ItemToInventory(_Pyramid,_Owner,-1);
		
		/*
		IF
		ItemWentOnStage(_Container,0)
		AND
		DB_TeleporterPyramidUnlocked(_Pyramid)
		AND
		//TODO: implement this: ItemIsInItemInventory(_Pyramid,_Container,1)
		AND
		GetPosition(_Container,_X,_Y,_Z)
		THEN
		TeleportToPosition(_Pyramid,_X,_Y,_Z,"",0);
		ItemClearOwner(_Pyramid);
		*/
		
		// Prevent NPCs leaving with Pyramids in their inventory
		IF
		CharacterWentOnStage(_NPC,0)
		AND
		// Players can be set off-stage temporarily by story in some cases
		NOT DB_IsPlayer(_NPC)
		AND
		DB_TeleporterPyramid(_Pyramid)
		AND
		ItemIsInCharacterInventory(_Pyramid,_NPC,1)
		AND
		GetPosition(_NPC,_X,_Y,_Z)
		THEN
		TeleportToPosition(_Pyramid,_X,_Y,_Z,"",0);
		ItemClearOwner(_Pyramid);
		
		PROC
		Proc_CompanionLeftParty((CHARACTERGUID)_Companion,(CHARACTERGUID)_Player)
		AND
		DB_TeleporterPyramid(_Pyramid)
		AND
		ItemIsInCharacterInventory(_Pyramid,_Companion,1)
		THEN
		ItemToInventory(_Pyramid,_Player,-1);
		//END_REGION
		
		
		//REGION Pyramids using (teleportation)
		IF
		CharacterTeleportToPyramid(_Char,_Pyramid)
		AND
		PyramidEnabled(_Pyramid)
		AND
		GetPosition(_Pyramid,_X,_Y,_Z)
		THEN
		TeleportToPosition(_Char,_X,_Y,_Z,"",1,1);
		
		IF
		CharacterTeleportToPyramid(_Char,_Pyramid)
		AND
		NOT PyramidEnabled(_Pyramid)
		THEN
		Proc_StartDialog(1,"GEN_AD_TeleporterPyramidDisabled",_Char);
		// TODO: check if this is needed ---> DB_CustomUseItemResponse(_Char,_Pyramid,0);
		
		PROC
		ProcBlockUseOfItem(_Player,_Pyramid)
		AND
		DB_TeleporterPyramid(_Pyramid)
		AND
		DB_IsPlayer(_Player)
		AND
		NOT PyramidEnabled(_Pyramid)
		THEN
		CloseUI(_Player,"Inventory");
		ObjectSetFlag(_Player,"SourcePyramidBlocked");
		Proc_StartDialog(1,"GEN_AD_TeleporterPyramidDisabled",_Player);
		DB_CustomUseItemResponse(_Player,_Pyramid,0);
		
		PROC
		ProcBlockUseOfItem(_Player,_Pyramid)
		AND
		DB_TeleporterPyramid(_Pyramid)
		AND
		DB_IsPlayer(_Player)
		AND
		DB_PyramidBlockerTrigger(_Trigger)
		AND
		ObjectIsInTrigger(_Player,_Trigger,1)
		THEN
		CloseUI(_Player,"Inventory");
		ObjectSetFlag(_Player,"SourcePyramidBlocked");
		Proc_StartDialog(1,"GEN_AD_TeleporterPyramidDisabled",_Player);
		DB_CustomUseItemResponse(_Player,_Pyramid,0);
		//END_REGION
		
		
		IF
		ItemAddedToCharacter(_Pyramid,_Player)
		AND
		DB_TeleporterPyramid(_Pyramid)
		AND
		DB_IsPlayer(_Player)
		THEN
		PROC_CheckPlayTutWithDelay(_Player,"TUT_Pyramid",2000);
		
		
		//REGION Enable/disable
		//TEMP: needs to be a game calls
		PROC
		DisablePyramid((ITEMGUID)_Item)
		THEN
		SetTag(_Item,"PYRAMID_DISABLED");
		
		PROC
		EnablePyramid((ITEMGUID)_Item)
		THEN
		ClearTag(_Item,"PYRAMID_DISABLED");
		
		QRY
		PyramidEnabled((ITEMGUID)_Item)
		AND
		IsTagged(_Item,"PYRAMID_DISABLED",0)
		THEN
		DB_NOOP(1);
		//END_REGION
		
	}
	EXIT
	{
		
	}
}
Goal(41).Title("_GLOBAL_TutorialMessages");
Goal(41)
{
	INIT
	{
		/***********************
		* Flags field: a bit field
		* 0	: no checks
		* 1 : no combat : don't show the tutorial if the character is active in combat
		* 2 : no UI : don't show the tutorial if the character has a UI open 
		* 4 : cancel on condition fail : the tutorial is removed from the queue if the conditions don't match, it can be sent again after that
		* 8 : force enqueue (wait at least one frame)
		* 16 : newfeature : this tutorial is specific for DOS2
		***********************/
		DB_TutorialInfo("TUT_Book","TUT_CAT_Inventory","TUT_Book_Title",0,0,-1,1,3,0);
		DB_TutorialInfo("TUT_Camera","TUT_CAT_Exploring","TUT_Camera_Title",0,0,-1,1,2,0);
		DB_TutorialInfo("TUT_Combat","TUT_CAT_Combat","TUT_Combat_Title",0,3,-1,1,0,0);
		DB_TutorialInfo("TUT_Combat_Examine","TUT_CAT_Combat","TUT_Combat_Examine_Title",0,0,-1,2,0,0);
		DB_TutorialInfo("TUT_Combat_Guard","TUT_CAT_Combat","TUT_Combat_Guard_Title",0,2,-1,2,0,0);
		DB_TutorialInfo("TUT_Combat_TacticalView","TUT_CAT_Combat","TUT_Combat_TacticalView_Title",0,0,-1,2,0,0);
		DB_TutorialInfo("TUT_Combat_TargetCycle","TUT_CAT_Combat","TUT_Combat_TargetCycle_Controller_Title",2,0,-1,1,0,0);
		DB_TutorialInfo("TUT_Combat_TurnOrder","TUT_CAT_Combat","TUT_Combat_TurnOrder_Title",0,3,-1,1,0,0);
		DB_TutorialInfo("TUT_Died","TUT_CAT_Combat","TUT_Died_Title",0,0,-1,1,0,0);
		DB_TutorialInfo("TUT_Disarm","TUT_CAT_Exploring","TUT_Disarm_Title",0,0,-1,3,0,0);
		DB_TutorialInfo("TUT_DragIcon","TUT_CAT_Exploring","TUT_DragIcon_Title",1,0,-1,1,0,0);
		DB_TutorialInfo("TUT_Equipment","TUT_CAT_Inventory","TUT_Equipment_Title",0,0,-1,1,2,0);
		DB_TutorialInfo("TUT_Flee","TUT_CAT_Combat","TUT_Flee_Title",0,3,-1,3,4,0);
		DB_TutorialInfo("TUT_GasPit","TUT_CAT_Exploring","TUT_GasPit_Title",0,1,-1,3,0,0);
		DB_TutorialInfo("TUT_GenericBehaviors","TUT_CAT_Exploring","TUT_GenericBehaviors_Title",0,0,-1,3,0,0);
		DB_TutorialInfo("TUT_Hammer","TUT_CAT_Inventory","TUT_Hammer_Title",0,0,-1,1,0,0);
		DB_TutorialInfo("TUT_HotbarAssignment","TUT_CAT_Inventory","TUT_HotbarAssignment_Title",0,3,-1,2,6,0);
		DB_TutorialInfo("TUT_IdentifyingGlass","TUT_CAT_Inventory","TUT_IdentifyingGlass_Title",0,0,-1,1,0,0);
		DB_TutorialInfo("TUT_Inventory","TUT_CAT_Inventory","TUT_Inventory_Title",0,1,-1,1,2,0);
		DB_TutorialInfo("TUT_LevelUp","TUT_CAT_Inventory","TUT_LevelUp_Title",0,1,-1,2,3,0);
		DB_TutorialInfo("TUT_Locked","TUT_CAT_Exploring","TUT_Locked_Title",0,0,-1,3,0,0);
		DB_TutorialInfo("TUT_WoodenDoor","TUT_CAT_Exploring","TUT_WoodenDoor_Title",0,0,-1,3,0,0);
		DB_TutorialInfo("TUT_Lockpick","TUT_CAT_Inventory","TUT_Lockpick_Title",0,0,-1,1,0,0);
		DB_TutorialInfo("TUT_Mound","TUT_CAT_Exploring","TUT_Mound_Title",0,0,-1,3,0,0);
		DB_TutorialInfo("TUT_Movement","TUT_CAT_Exploring","TUT_Movement_Title",0,0,-1,1,0,0);
		DB_TutorialInfo("TUT_NoPetPal","TUT_CAT_Social","TUT_PetPal_Title",0,0,-1,2,0,0);
		DB_TutorialInfo("TUT_Perception","TUT_CAT_Inventory","TUT_Perception_Title",0,0,-1,1,0,0);
		DB_TutorialInfo("TUT_PetPal","TUT_CAT_Social","TUT_PetPal_Title",0,0,-1,2,0,0);
		DB_TutorialInfo("TUT_PolymorphDrop","TUT_CAT_Social","TUT_PolymorphDrop_Title",0,0,-1,1,16,0);
		DB_TutorialInfo("TUT_Potion","TUT_CAT_Combat","TUT_Potion_Title",0,1,-1,2,0,0);
		DB_TutorialInfo("TUT_Pyramid","TUT_CAT_Exploring","TUT_Pyramid_Title",0,0,-1,1,0,0);
		DB_TutorialInfo("TUT_Pyramid_2","TUT_CAT_Exploring","TUT_Pyramid_2_Title",0,0,-1,1,0,0);
		DB_TutorialInfo("TUT_PyramidsPickup","TUT_CAT_Exploring","TUT_PyramidsPickup_Title",0,0,-1,1,0,0);
		DB_TutorialInfo("TUT_ReflectionDialog","TUT_CAT_Social","TUT_ReflectionDialog_Title",0,0,-1,1,0,0);
		DB_TutorialInfo("TUT_SaveLoad","TUT_CAT_General","TUT_SaveLoad_Title",0,0,-1,1,0,0);
		DB_TutorialInfo("TUT_Scroll","TUT_CAT_Combat","TUT_Scroll_Title",0,0,-1,2,2,0);
		DB_TutorialInfo("TUT_SpecialArrow","TUT_CAT_Combat","TUT_SpecialArrow_Title",0,0,-1,2,2,0);
		DB_TutorialInfo("TUT_Shovel","TUT_CAT_Exploring","TUT_Shovel_Title",0,0,-1,2,0,0);
		DB_TutorialInfo("TUT_Skill","TUT_CAT_Inventory","TUT_Skill_Title",0,0,-1,2,2,0);
		DB_TutorialInfo("TUT_SkillUnlock","TUT_CAT_Combat","TUT_SkillUnlock_Title",0,0,-1,2,0,0);
		DB_TutorialInfo("TUT_Stealing","TUT_CAT_Exploring","TUT_Stealing_Title",0,0,-1,3,0,0);
		DB_TutorialInfo("TUT_Waypoint","TUT_CAT_Exploring","TUT_Waypoint_Title",0,0,-1,2,0,0);
		DB_TutorialInfo("TUT_BondedAvatar","TUT_CAT_Social","TUT_BondedAvatar_Title",0,0,-1,1,16,0);
		DB_TutorialInfo("TUT_HotbarLocked","TUT_CAT_Combat","TUT_HotbarLocked_Title",0,3,-1,1,0,10);
		DB_TutorialInfo("TUT_Tooltips","TUT_CAT_Exploring","TUT_Tooltips_Title",0,0,-1,2,0,0);
		DB_TutorialInfo("TUT_TagVillain","TUT_CAT_Social","TUT_TagVillain_Title",0,0,-1,2,0,0);
		DB_TutorialInfo("TUT_TagHero","TUT_CAT_Social","TUT_TagHero_Title",0,0,-1,2,0,0);
		DB_TutorialInfo("TUT_Waypoint","TUT_CAT_Exploring","TUT_Waypoint_Title",0,2,-1,1,0,0);
		DB_TutorialInfo("TUT_Homestead","TUT_CAT_Exploring","TUT_Homestead_Title",0,1,-1,1,2,0);
		DB_TutorialInfo("TUT_PolymorphAttribute","TUT_CAT_General","TUT_PolymorphAttribute_Title",2,1,-1,1,16,0);
		
	}
	KB
	{
		//REGION Tutorial Message
		PROC
		ProcPlayTut((CHARACTERGUID)_Char,(STRING)_Message)
		AND 
		DB_TutorialInfo(_Message,(STRING)_Cat,(STRING)_Title,(INTEGER)_ControllerType,(INTEGER)_ModalType,(INTEGER)_Duration,(INTEGER)_Priority,(INTEGER)_Flags,(INTEGER)_MinimumPlaytime)
		THEN
		ShowTutorial(_Char,_Message,_Cat,_Title,_ControllerType,_ModalType,_Duration,_Priority,_Flags,_MinimumPlaytime);
		 
		PROC
		ProcPlayTut((CHARACTERGUID)_Char,(STRING)_Message)
		AND 
		DB_TutorialInfo_MsgBox(_Message,(STRING)_Cat,(STRING)_Title,(INTEGER)_ControllerType,(INTEGER)_ModalType,(INTEGER)_Duration,(INTEGER)_Priority,(INTEGER)_Flags,(INTEGER)_MinimumPlaytime)
		THEN
		OpenMessageBox(_Char,_Message);
		 
		PROC
		ProcPlayTut((CHARACTERGUID)_Char,(STRING)_Message)
		AND
		NOT DB_TutorialInfo(_Message,_,_,_,_,_,_,_,_)
		AND
		NOT DB_TutorialInfo_MsgBox(_Message,_,_,_,_,_,_,_,_)
		AND
		StringConcatenate("Tutorial Message without info: ",_Message,_ErrorMessage)
		THEN
		DebugBreak(_ErrorMessage);
		ShowTutorial(_Char,_Message,"","",0,0,-1,3,0,0);
		//END_REGION
		
		//REGION Tutorial From ProximityTutorial.itemscript
		IF
		CharacterItemEvent(_Character,_Item,"LaunchTutorialMessage")
		AND
		GetVarString(_Item,"TutorialMessage",_TutorialName)
		THEN
		PROC_CheckPlayTut(_Character,_TutorialName);
		//END_REGION
		
		//REGION Movement Popup
		
		// See also _GLOBAL_TutorialMessages_MovementDetection
		IF
		DB_GLO_Tutorial_StartMovementTutorial(1)
		THEN
		TimerLaunch("TUT_Movement",5000);
		
		IF
		TimerFinished("TUT_Movement")
		AND
		DB_IsPlayer(_Player)
		AND
		GetPosition(_Player,_MoveX,_MoveY,_MoveZ)
		AND
		DB_GLO_Tutorial_Movement_LocationTracking(_Player,_MoveX,_MoveZ)
		AND
		NOT DB_GLOBAL_TutorialMessages_MovementTutFinishedFor(_Player)
		THEN
		PROC_CheckPlayTut(_Player,"TUT_Movement");
		
		IF
		TimerFinished("TUT_Camera")
		THEN
		PROC_CheckPlayTut("TUT_Camera");
		DB_InitialTutorialsShown(1);
		//END_REGION 
		
		//REGION Inventory Popup
		IF
		ItemTemplateAddedToCharacter(_,_,_Player)
		AND
		_Player.DB_IsPlayer()
		AND
		DB_InitialTutorialsShown(1)
		THEN
		ProcCheckInventoryTutorial(_Player);
		
		PROC
		ProcCheckInventoryTutorial((GUIDSTRING)_Player)
		AND
		IsSpeakerReserved(_Player,0)
		THEN
		PROC_CheckPlayTut((CHARACTERGUID)_Player,"TUT_Inventory");
		
		PROC
		ProcCheckInventoryTutorial((GUIDSTRING)_Player)
		AND
		IsSpeakerReserved(_Player,1)
		THEN
		DB_InventoryMessageQueued(_Player);
		
		IF
		DialogEnded(_,_ID)
		AND
		DB_DialogPlayers(_ID,_Player,_)
		AND
		DB_InventoryMessageQueued(_Player)
		THEN
		NOT DB_InventoryMessageQueued(_Player);
		//force a frame delay to give Osiris a chance to run other logic, in case this dialog causes combat or another dialog
		SetStoryEvent(_Player,"GLO_CheckInventoryTutorial");
		
		IF
		StoryEvent(_Player,"GLO_CheckInventoryTutorial")
		AND
		QRY_SpeakerIsAvailable(_Player)
		THEN
		PROC_CheckPlayTut((CHARACTERGUID)_Player,"TUT_Inventory");
		
		
		//END_REGION 
		
		//REGION Combat Popup
		IF				
		ObjectTurnStarted((CHARACTERGUID)_Player)
		AND
		_Player.DB_IsPlayer()
		AND
		CharacterGetAbility(_Player, "Loremaster", _Val)
		AND
		_Val > 0
		AND
		DB_CharCountHelper(_Player,"CombatTurnCounter",_Turn)
		AND
		_Turn >= 6
		THEN
		PROC_CheckPlayTut(_Player,"TUT_Combat_Examine");
		//END_REGION 
		
		//REGION Tool Popups
		IF
		ItemTemplateAddedToCharacter(TOOL_LockPick_A_06d0eecb-4271-42a7-bd8c-4cbf24927197,_,_Player)
		AND
		_Player.DB_IsPlayer()
		THEN
		PROC_CheckPlayTut(_Player, "TUT_Lockpick");
		
		IF
		ItemTemplateAddedToCharacter(TOOL_Hammer_Repair_A_be7226da-7211-4250-be95-ca780bcdb3df,_,_Player)
		AND
		_Player.DB_IsPlayer()
		THEN
		PROC_CheckPlayTut(_Player, "TUT_Hammer");
		
		IF
		ItemTemplateAddedToCharacter(TOOL_IdentifyingGlass_A_32288ce4-3d8d-46b3-a655-598350a96201,_,_Player)
		AND
		_Player.DB_IsPlayer()
		THEN
		PROC_CheckPlayTut(_Player, "TUT_IdentifyingGlass");
		
		IF
		ItemTemplateAddedToCharacter(TOOL_Trap_DisarmToolkit_9fda335e-2220-4ae9-a4c2-2424d5ef5165,_,_Player)
		AND
		_Player.DB_IsPlayer()
		THEN
		PROC_CheckPlayTut(_Player, "TUT_Disarm");
		
		IF
		ItemTemplateAddedToCharacter(TOOL_Shovel_A_41486dd2-3fd5-464e-870e-844120cf0517,_,_Player)
		AND
		_Player.DB_IsPlayer()
		THEN
		PROC_CheckPlayTut(_Player,"TUT_Shovel");
		//END_REGION
		
		IF
		ObjectTurnStarted((CHARACTERGUID)_Player)
		AND
		_Player.DB_IsPlayer()
		AND
		CharacterGetHitpointsPercentage(_Player,_Percentage)
		AND
		_Percentage < 25.0
		AND
		_Percentage > 0.0
		AND
		DB_PotionDone(1)
		THEN
		PROC_CheckPlayTut(_Player,"TUT_Flee");
		
		IF
		ObjectTurnStarted((CHARACTERGUID)_Player)
		AND
		_Player.DB_IsPlayer()
		AND
		CharacterGetHitpointsPercentage(_Player,_Percentage)
		AND
		_Percentage < 25.0
		AND
		_Percentage > 0.0
		THEN
		PROC_CheckPlayTut(_Player,"TUT_Potion");
		DB_PotionDone(1);
		
		IF
		CharacterItemEvent(_, _Item, "WaypointDiscovered")
		AND
		DB_WaypointInfo((ITEMGUID)_Item,(TRIGGERGUID)_,(STRING)_)
		THEN
		DB_WaypointTuto(1);
		
		IF
		CharacterDied(_Player)
		AND
		_Player.DB_IsPlayer()
		THEN
		PROC_CheckPlayTutWithDelay(_Player,"TUT_Died",2000);
		
		IF
		StoryEvent((CHARACTERGUID)_Player,_Event)
		AND
		DB_Event2DisplayText(_Event,_Text) //See the goal TrapReactions for context about that DB
		AND
		_Player.DB_IsPlayer()
		THEN
		PROC_CheckPlayTutWithDelay(_Player,"TUT_Perception",2000);
		
		IF
		CharacterUsedItem(_Player,_Mound)
		AND
		DB_ShovelArea(_,_,_Mound)
		THEN
		PROC_CheckPlayTut(_Player,"TUT_Mound");
		
		IF
		TextEventSet("axeltuto")
		THEN
		DB_StartTutMessages(1);
		
		IF
		CharacterLeveledUp(_Player)
		AND
		_Player.DB_IsPlayer()
		THEN
		PROC_CheckPlayTut(_Player, "TUT_LevelUp");
		
		IF
		ItemAddedToCharacter(_Item, _Player)
		AND
		DB_InitialTutorialsShown(1)
		AND
		DB_IsPlayer(_Player)
		AND
		ItemHasOnUse(_Item,"skillbook",1)
		THEN
		PROC_CheckPlayTut(_Player,"TUT_Skill");
		
		IF
		ItemAddedToCharacter(_Item, _Player)
		AND
		DB_InitialTutorialsShown(1)
		AND
		DB_IsPlayer(_Player)
		AND
		ObjectIsItem(ITEMGUID_Scroll_Skill_Water_LightningBolt_000_aabc538c-b76f-4395-9634-f08cff2a1017,0)
		AND
		ItemHasOnUse(_Item,"scrollarrow",1)
		AND
		IsTagged(_Item,"GRENADES",0)
		AND
		IsTagged(_Item,"ARROWS",0)
		THEN
		PROC_CheckPlayTut(_Player, "TUT_Scroll");
		
		IF
		ItemAddedToCharacter(_Item, _Player)
		AND
		DB_InitialTutorialsShown(1)
		AND
		DB_IsPlayer(_Player)
		AND
		ItemHasOnUse(_Item,"scrollarrow",1)
		AND
		IsTagged(_Item,"GRENADES",0)
		AND
		IsTagged(_Item,"ARROWS",1)
		THEN
		PROC_CheckPlayTut(_Player, "TUT_SpecialArrow");
		
		IF
		ItemAddedToCharacter(_Item, _Player)
		AND
		DB_InitialTutorialsShown(1)
		AND
		DB_IsPlayer(_Player)
		AND
		ItemHasOnUse(_Item,"book",1)
		THEN
		PROC_CheckPlayTut(_Player, "TUT_Book");
		
		/*
		0 -> Story
		1 -> Casual
		2 -> Normal
		3 -> Hardcore
		4 -> Honour
		*/
		IF
		DifficultyChanged(_Difficulty)
		AND
		_Difficulty <= 1
		THEN
		DB_TUT_PlayOnEasy(1);
		
		IF
		DifficultyChanged(_Difficulty)
		AND
		_Difficulty > 1
		THEN
		NOT DB_TUT_PlayOnEasy(1);
		
		IF
		SkillAdded(_Player,_,1) 
		AND
		DB_IsPlayer(_Player)
		AND
		CharacterIsControlled(_Player,1)
		AND
		DB_InitialTutorialsShown(1)
		AND
		NOT DB_TutorialMessages_SkillUnlockDone(_Player)
		THEN
		ProcObjectTimer(_Player,"TUT_SkillUnlock",500);
		
		PROC
		ProcObjectTimerFinished(_Player,"TUT_SkillUnlock")
		THEN
		PROC_TutorialMessage_SkillUnlockAfterDialog((CHARACTERGUID)_Player);
		
		PROC
		PROC_TutorialMessage_SkillUnlockAfterDialog((CHARACTERGUID)_Player)
		AND
		NOT DB_DialogPlayers(_,_Player,_)
		THEN
		DB_TutorialMessages_SkillUnlockDone(_Player);
		PROC_CheckPlayTut(_Player, "TUT_SkillUnlock");
		
		PROC
		PROC_TutorialMessage_SkillUnlockAfterDialog((CHARACTERGUID)_Player)
		AND
		NOT DB_TutorialMessages_SkillUnlockDone(_Player)
		AND
		DB_DialogPlayers(_Inst,_Player,_)
		AND
		NOT DB_AutomatedDialog(_Inst)
		THEN
		DB_TutorialMessage_CheckEndDialog_SkillTut(_Inst,_Player);
		
		PROC
		PROC_TutorialMessage_SkillUnlockAfterDialog((CHARACTERGUID)_Player)
		AND
		NOT DB_TutorialMessages_SkillUnlockDone(_Player)
		AND
		DB_DialogPlayers(_Inst,_Player,_)
		AND
		DB_AutomatedDialog(_Inst)
		THEN
		DB_TutorialMessage_CheckEndAutomatedDialog_SkillTut(_Inst,_Player);
		
		IF
		DialogEnded(_,_Inst)
		AND
		DB_TutorialMessage_CheckEndDialog_SkillTut(_Inst,_Player)
		THEN
		NOT DB_TutorialMessage_CheckEndDialog_SkillTut(_Inst,_Player);
		DB_TutorialMessages_SkillUnlockDone(_Player);
		PROC_CheckPlayTut(_Player, "TUT_SkillUnlock");
		
		IF
		AutomatedDialogEnded(_,_Inst)
		AND
		DB_TutorialMessage_CheckEndAutomatedDialog_SkillTut(_Inst,_Player)
		THEN
		NOT DB_TutorialMessage_CheckEndAutomatedDialog_SkillTut(_Inst,_Player);
		DB_TutorialMessages_SkillUnlockDone(_Player);
		PROC_CheckPlayTut(_Player, "TUT_SkillUnlock");
		
		
		//REGION TUT_DragIcon
		
		//REGION Makes a DB_ItemOpened entry for player profile if lacking one
		QRY
		QRY_TUT_DragIcon_ProfileDB((STRING)_Profile)
		AND
		NOT DB_ItemOpened(_, _Profile)
		THEN
		DB_ItemOpened(0, _Profile);
		
		QRY
		QRY_TUT_DragIcon_ProfileDB((STRING)_Profile)
		THEN
		DB_NOOP(1);
		//END_REGION
		
		IF
		ItemTemplateOpening(_,_Item, _Player)
		AND
		DB_IsPlayer(_Player)
		AND
		ItemIsContainer(_Item, 1)
		AND
		CharacterGetReservedUserID(_Player, _UserID)
		AND
		GetUserProfileID(_UserID, _Profile)
		AND
		QRY_TUT_DragIcon_ProfileDB((STRING)_Profile)
		AND
		DB_ItemOpened(_Nb, _Profile)
		AND
		IntegerSum(_Nb,1,_NewNb)
		THEN
		NOT DB_ItemOpened(_Nb, _Profile);
		DB_ItemOpened(_NewNb, _Profile);
		PROC_TUT_DragIcon((CHARACTERGUID)_Player, (INTEGER)_NewNb);
		
		PROC
		PROC_TUT_DragIcon((CHARACTERGUID)_Player, (INTEGER)_Nb)
		AND
		_Nb == 10
		THEN
		PROC_CheckPlayTut(_Player, "TUT_DragIcon");
		
		//END_REGION
		
		IF
		DialogStarted(_,_Instance)
		AND
		DB_DialogNPCs(_Instance,_Animal,1)
		AND
		DB_DialogPlayers(_Instance,_Player,1)
		AND
		CharacterHasTalent((CHARACTERGUID)_Player,"AnimalEmpathy",0)
		AND
		IsTagged(_Animal,"ANIMAL",1)
		THEN
		PROC_CheckPlayTut(_Player,"TUT_NoPetPal");
		
		IF
		DialogStarted(_,_Instance)
		AND
		DB_DialogNPCs(_Instance,_Animal,1)
		AND
		DB_DialogPlayers(_Instance,_Player,1)
		AND
		CharacterHasTalent((CHARACTERGUID)_Player,"AnimalEmpathy",1)
		AND
		IsTagged(_Animal,"ANIMAL",1)
		THEN
		PROC_CheckPlayTut(_Player,"TUT_PetPal");
		
		IF
		ItemAddedToCharacter(_Item,_Player)
		AND
		DB_IsPlayer(_Player)
		AND
		DB_CharCountHelper(_Player,"CombatTurnCounter",_Turn)
		AND
		_Turn >= 3
		AND
		ItemHasOnUse(_Item,"scrollarrow",1)
		AND
		ItemIsEquipable(_Item,0)
		THEN
		PROC_CheckPlayTut(_Player,"TUT_HotbarAssignment");
		
		IF
		ItemAddedToCharacter(_Item,_Player)
		AND
		DB_InitialTutorialsShown(1)
		AND
		DB_IsPlayer(_Player)
		AND
		ItemIsEquipable(_Item,1)
		THEN
		PROC_CheckPlayTut(_Player,"TUT_Equipment");
		
		IF
		CharacterUsedItem(_Player,_Item)
		AND
		DB_IsPlayer(_Player)
		AND
		ObjectIsItem(_Item,1)
		AND
		ObjectIsItem(ITEMGUID_S_TUT_CargoDeck_AnimalPen_DoorToSecurity_b4a7964b-e773-4de2-a340-b157e1a8f89a,0)
		AND
		ItemIsLocked(_Item,1)
		THEN
		PROC_CheckPlayTut(_Player,"TUT_Locked");
		
		IF
		CharacterItemEvent(_Character, _,"WaypointDiscovered")
		THEN
		PROC_CheckPlayTut(_Character, "TUT_Waypoint");
		
		//REGION Free attribute point when gaining level in summoning
		IF
		CharacterBaseAbilityChanged(_Character, "Polymorph", _Old, _New)
		AND
		DB_IsPlayer(_Character)
		THEN
		PROC_CheckPlayTut(_Character, "TUT_PolymorphAttribute");
		//END_REGION
		
		//REGION //Save game Patching
		
		IF
		SavegameLoaded(_Major,_Minor,_Rev,_Build)
		AND
		QRY_VersionIsOlderThan(_Major,_Minor,_Rev,_Build, 3, 5, 1, 0)
		THEN
		NOT DB_TutorialInfo("TUT_Tooltips","TUT_CAT_Exploring","TUT_Tooltips_Title",1,0,-1,2,0,0);
		NOT DB_TutorialInfo("TUT_Tooltips_Controller","TUT_CAT_Exploring","TUT_Tooltips_Title",2,0,-1,2,0,0);
		DB_TutorialInfo("TUT_Tooltips","TUT_CAT_Exploring","TUT_Tooltips_Title",0,0,-1,2,0,0);
		NOT DB_TutorialInfo("TUT_Combat","TUT_CAT_Combat","TUT_Combat_Title",0,0,-1,1,0,0);
		DB_TutorialInfo("TUT_Combat","TUT_CAT_Combat","TUT_Combat_Title",0,3,-1,1,0,0);
		NOT DB_TutorialInfo("TUT_Flee","TUT_CAT_Combat","TUT_Flee_Title",0,0,-1,3,4,0);
		DB_TutorialInfo("TUT_Flee","TUT_CAT_Combat","TUT_Flee_Title",0,3,-1,3,4,0);
		NOT DB_TutorialInfo("TUT_HotbarAssignment","TUT_CAT_Inventory","TUT_HotbarAssignment_Title",0,0,-1,2,6,0);
		DB_TutorialInfo("TUT_HotbarAssignment","TUT_CAT_Inventory","TUT_HotbarAssignment_Title",0,3,-1,2,6,0);
		NOT DB_TutorialInfo("TUT_LevelUp","TUT_CAT_Inventory","TUT_LevelUp_Title",0,2,-1,2,3,0);
		DB_TutorialInfo("TUT_LevelUp","TUT_CAT_Inventory","TUT_LevelUp_Title",0,1,-1,2,3,0);
		NOT DB_TutorialInfo("TUT_Inventory","TUT_CAT_Inventory","TUT_Inventory_Title",0,2,-1,1,2,0);
		DB_TutorialInfo("TUT_Inventory","TUT_CAT_Inventory","TUT_Inventory_Title",0,1,-1,1,2,0);
		DB_TutorialInfo("TUT_Homestead","TUT_CAT_Exploring","TUT_Homestead_Title",0,1,-1,1,2,0);
		
		IF
		SavegameLoaded(_Major,_Minor,_Rev,_Build)
		AND
		QRY_VersionIsOlderThan(_Major,_Minor,_Rev,_Build, 3, 6, 0, 1)
		THEN
		DB_TutorialInfo("TUT_PolymorphAttribute","TUT_CAT_General","TUT_PolymorphAttribute_Title",2,1,-1,1,16,0);
		//END_REGION
		
	}
	EXIT
	{
		
	}
}
Goal(42).Title("_GLOBAL_TutorialMessages_MovementDetection");
Goal(42)
{
	INIT
	{
		// Don't show the movement tutorial for players that move before the tutorial is shown
		
		// Trigger the camera tutorial 10 seconds after all players have moved, or
		// 10 seconds after the first player closed the movement tutorial box
		
	}
	KB
	{
		// Triggers to detect that someone moved from their initial position
		IF
		DB_Tutorial_PlayerMovementDetectionTrigger((TRIGGERGUID)_Trigger)
		THEN
		TriggerRegisterForPlayers(_Trigger);
		
		// Player entered detection trigger -> won't get movement tutorial
		// + check whether everyone has moved (if so, complete this goal
		// and schedule the camera tutorial)
		IF
		CharacterEnteredTrigger(_Player,_Trigger)
		AND
		DB_Tutorial_PlayerMovementDetectionTrigger(_Trigger)
		THEN
		PROC_GLOBAL_TutorialMessages_PlayerMoved(_Player);
		
		// Player got the movement tutorial -> record so we know
		// we should only schedule the camera tutorial after a
		// a movement tutorial box has been closed
		PROC
		PROC_CheckPlayTut(_Char,"TUT_Movement")
		THEN
		DB_GlobalTutorialMessages_TUT_Movement_Shown(1);
		PROC_GLOBAL_TutorialMessages_PlayerMoved(_Char);
		
		//REGION Handle a player moving or getting the movement tutorial
		// This player has moved or got the tutorial
		PROC
		PROC_GLOBAL_TutorialMessages_PlayerMoved((CHARACTERGUID)_Player)
		THEN
		DB_GLOBAL_TutorialMessages_MovementTutFinishedFor(_Player);
		
		// Anyone left that didn't move or didn't get the tutorial?
		PROC
		PROC_GLOBAL_TutorialMessages_PlayerMoved((CHARACTERGUID)_Player)
		AND
		DB_IsPlayer(_AnyPlayer)
		AND
		NOT DB_GLOBAL_TutorialMessages_MovementTutFinishedFor(_AnyPlayer)
		THEN
		DB_GLOBAL_TutorialMessages_MovementTutUnfinished(1);
		
		// No one left -> unregister movement detection triggers
		PROC
		PROC_GLOBAL_TutorialMessages_PlayerMoved((CHARACTERGUID)_Player)
		AND
		NOT DB_GLOBAL_TutorialMessages_MovementTutUnfinished(1)
		AND
		DB_Tutorial_PlayerMovementDetectionTrigger(_Trigger)
		THEN
		ProcTriggerUnregisterForPlayers(_Trigger);
		NOT DB_Tutorial_PlayerMovementDetectionTrigger(_Trigger);
		
		// No one left -> schedule camera tutorial right away if everyone
		// skipped the movement tutorial and complete goal
		PROC
		PROC_GLOBAL_TutorialMessages_PlayerMoved((CHARACTERGUID)_Player)
		AND
		NOT DB_GLOBAL_TutorialMessages_MovementTutUnfinished(1)
		AND
		NOT DB_GlobalTutorialMessages_TUT_Movement_Shown(1)
		THEN
		TimerLaunch("TUT_Camera",10000);
		GoalCompleted;
		
		// Clean up
		PROC
		PROC_GLOBAL_TutorialMessages_PlayerMoved((CHARACTERGUID)_Player)
		THEN
		NOT DB_GLOBAL_TutorialMessages_MovementTutUnfinished(1);
		//END_REGION
		
		// At least one player got the movement tutorial and dismissed it
		// -> schedule the camera tutorial
		IF
		TutorialBoxClosed(_,_Message)
		AND
		StringContains(_Message,"TUT_Movement",1)
		AND
		NOT DB_Tutorial_PlayerCameraTutorialTimerLaunched(1)
		THEN
		// Only launch once, multiple players could have gotten this dialog
		DB_Tutorial_PlayerCameraTutorialTimerLaunched(1);
		TimerLaunch("TUT_Camera",10000);
		GoalCompleted; 
		
	}
	EXIT
	{
		//NOT DB_GlobalTutorialMessages_TUT_Movement_Shown(1);
		//NOT DB_Tutorial_PlayerCameraTutorialTimerLaunched(1);
		
	}
}
Goal(43).Title("_Greevers_Little_Helpers");
Goal(43)
{
	INIT
	{
		DB_Singleton("InitData",0);
		
		DB_GLO_AttributeCheck_Var(1,"Name","Attribute_Check_1_Name_080aa25a-eb82-4060-a20f-93f3f0a3ec85");
		DB_GLO_AttributeCheck_Var(1,"Difficulty","Attribute_Check_1_Difficulty_6645b5b8-4c17-4678-98b2-d5d718c36829");
		DB_GLO_AttributeCheck_Var(1,"LevelOverride","Attribute_Check_1_LevelOverride_08b97107-2d16-4ff5-a2e5-a01ed50e7135");
		DB_GLO_AttributeCheck_Var(1,"Source","Attribute_Check_1_Source_dd323f37-f472-4a67-9a44-5ca9f15646bb");
		DB_GLO_AttributeCheck_Var(1,"Target","Attribute_Check_1_Target_c46387f7-f39b-46c5-b6ec-baeccc34291a");
		
		DB_GLO_AttributeCheck_Var(2,"Difficulty","Attribute_Check_2_Difficulty_eab60140-a9e3-4579-b5fa-3cb5515c2282");
		DB_GLO_AttributeCheck_Var(2,"LevelOverride","Attribute_Check_2_LevelOverride_1dc16030-ece6-4677-ae14-62e7e9d1ac0e");
		DB_GLO_AttributeCheck_Var(2,"Name","Attribute_Check_2_Name_151dfe0f-6575-4ce2-bedc-6f157abdb36e");
		DB_GLO_AttributeCheck_Var(2,"Source","Attribute_Check_2_Source_c40af148-2c37-444b-a462-4387a4c6cede");
		DB_GLO_AttributeCheck_Var(2,"Target","Attribute_Check_2_Target_b8df81e7-d122-452b-bfaa-f9bbe87fd387");
		
		DB_GLO_AttributeCheck_Var(3,"Difficulty","Attribute_Check_3_Difficulty_ff545cea-32e3-4a9a-b005-f3a6e0f0cabd");
		DB_GLO_AttributeCheck_Var(3,"LevelOverride","Attribute_Check_3_LevelOverride_6e3f0bc5-636f-48ad-ad0a-642c3146302b");
		DB_GLO_AttributeCheck_Var(3,"Name","Attribute_Check_3_Name_8281a807-0ae5-4ada-8dc5-3b859310c1f5");
		DB_GLO_AttributeCheck_Var(3,"Source","Attribute_Check_3_Source_32f31478-7329-4902-bb66-a9043819102c");
		DB_GLO_AttributeCheck_Var(3,"Target","Attribute_Check_3_Target_65312317-50da-4cce-a6e9-725a85e7fd46");
		
		
	}
	KB
	{
		//REGION Stacks
		
		//Stacks are a useful tool to mimic a FILO stack structure.
		//Add items using the Stack((STRING)_ID,_Value) command.
		//At any time you can query for DB_TopOfStackCharacter((STRING)_ID,_Value), DB_TopOfStackItem((STRING)_ID,_Value) or DB_TopOfStackTrigger((STRING)_ID,_Value)
		//If you wish to pop the top member of the stack, just call PopStack((STRING)_ID);
		PROC
		Stack_Internal((STRING)_ID,(STRING)_Value)
		AND
		NOT DB_StackInternalCounter(_,_ID)
		THEN
		DB_StackInternalCounter(0,_ID);
		DB_TopOfStack(_ID,_Value);
		
		PROC
		Stack_Internal((STRING)_ID,(STRING)_Value)
		AND
		DB_StackInternalCounter(_Amount,_ID)
		AND
		IntegerSum(_Amount,1,_NewAmount)
		AND
		DB_TopOfStack(_ID,_TopValue)
		THEN
		NOT DB_StackInternalCounter(_Amount,_ID);
		DB_StackInternalCounter(_NewAmount,_ID);
		DB_StackInternalMember(_NewAmount,_ID,_Value);
		NOT DB_TopOfStack(_ID,_TopValue);
		DB_TopOfStack(_ID,_Value);
		
		PROC
		PopStack((STRING)_ID)
		AND
		DB_StackInternalCounter(1,_ID)
		AND
		DB_TopOfStack(_ID,_Value)
		THEN
		NOT DB_TopOfStack(_ID,_Value);
		NOT DB_StackInternalCounter(1,_ID);
		NOT DB_StackInternalMember(1,_ID,_Value);
		ProcClearOldTopOfStack(_ID);
		
		PROC
		PopStack((STRING)_ID)
		AND
		DB_StackInternalCounter(_Amount,_ID)
		AND
		IntegerSubtract(_Amount,1,_NewAmount)
		AND
		DB_StackInternalMember(_Amount,_ID,_OldTopValue)
		AND
		DB_StackInternalMember(_NewAmount,_ID,_NewTopValue)
		THEN
		NOT DB_StackInternalCounter(_Amount,_ID);
		DB_StackInternalCounter(_NewAmount,_ID);
		NOT DB_StackInternalMember(_Amount,_ID,_OldTopValue);
		NOT DB_TopOfStack(_ID,_OldTopValue);
		DB_TopOfStack(_ID,_NewTopValue);
		
		PROC
		Stack((STRING)_ID,(GUIDSTRING)_Object)
		AND
		GetUUID(_Object,_UUID)
		THEN
		DB_Stack_UUID(_Object,_UUID);
		Stack_Internal(_ID,_UUID);
		
		IF
		DB_TopOfStack(_ID,_UUID)
		AND
		DB_Stack_UUID(_Value,_UUID)
		THEN
		ProcClearOldTopOfStack(_ID);
		DB_TopOfStackObject(_ID,_Value);
		
		PROC
		ProcClearOldTopOfStack((STRING)_ID)
		AND
		DB_TopOfStackObject(_ID,_Value)
		THEN
		NOT DB_TopOfStackObject(_ID,_Value);
		
		//END_REGION
		
		//REGION Default Parameters
		PROC
		CharacterLookAt((CHARACTERGUID)_Character1,(GUIDSTRING)_Target)
		THEN
		CharacterLookAt(_Character1,_Target,0);
		
		PROC
		PlayAnimation((GUIDSTRING)_Object,(STRING)_String)
		THEN
		PlayAnimation(_Object,_String,"");
		
		PROC
		TeleportTo((GUIDSTRING)_Object,(GUIDSTRING)_Target)
		THEN
		TeleportTo(_Object,_Target,"",1,0,0);
		
		PROC
		TeleportTo((GUIDSTRING)_Object,(GUIDSTRING)_Target,(STRING)_Event,(INTEGER)_TeleportLinkedCharacters)
		THEN
		TeleportTo(_Object,_Target,_Event,_TeleportLinkedCharacters,0,0);
		
		PROC
		TeleportTo((GUIDSTRING)_Object,(GUIDSTRING)_Target,(STRING)_Event,(INTEGER)_TeleportLinkedCharacters,(INTEGER)_ExcludePartyFollowers)
		THEN
		TeleportTo(_Object,_Target,_Event,_TeleportLinkedCharacters,_ExcludePartyFollowers,0);
		
		PROC
		TeleportToPosition((GUIDSTRING)_Object,(REAL)_X,(REAL)_Y,(REAL)_Z,(STRING)_Event,(INTEGER)_TeleportLinkedCharacters)
		THEN
		TeleportToPosition(_Object,_X,_Y,_Z,_Event,_TeleportLinkedCharacters,0);
		
		PROC
		ApplyStatus((GUIDSTRING)_Target,(STRING)_Status,(REAL)_Duration)
		THEN
		ApplyStatus(_Target,_Status,_Duration,0);
		
		PROC
		PartySetFlag((CHARACTERGUID)_Character,(STRING)_Event)
		THEN
		PartySetFlag(_Character,_Event,0);
		
		PROC
		ObjectSetFlag((GUIDSTRING)_Object,(STRING)_Event)
		THEN
		ObjectSetFlag(_Object,_Event,0);
		
		PROC
		ObjectClearFlag((GUIDSTRING)_Object,(STRING)_Event)
		THEN
		ObjectClearFlag(_Object,_Event,0);
		
		PROC
		UserSetFlag((CHARACTERGUID)_Character,(STRING)_Event)
		THEN
		UserSetFlag(_Character,_Event,0);
		
		PROC
		CharacterUseSkill((CHARACTERGUID)_Character,(STRING)_Skill,(GUIDSTRING)_Target)
		THEN
		CharacterUseSkill(_Character,_Skill,_Target,0,0,0);
		
		PROC
		CharacterUseSkill((CHARACTERGUID)_Character,(STRING)_Skill,(GUIDSTRING)_Target,(INTEGER)_ForceResetCooldown)
		THEN
		CharacterUseSkill(_Character,_Skill,_Target,_ForceResetCooldown,0,0);
		
		PROC
		CharacterUseSkill((CHARACTERGUID)_Character,(STRING)_Skill,(GUIDSTRING)_Target,(INTEGER)_ForceResetCooldown, (INTEGER)_IgnoreHasSkill)
		THEN
		CharacterUseSkill(_Character,_Skill,_Target,_ForceResetCooldown,_IgnoreHasSkill,0);
		
		PROC
		CharacterAddSkill((CHARACTERGUID)_Character, (STRING)_Skill)
		THEN
		CharacterAddSkill((CHARACTERGUID)_Character, (STRING)_Skill, 1);
		
		PROC
		CharacterMakePlayer((CHARACTERGUID)_Character)
		THEN
		CharacterMakePlayer((CHARACTERGUID)_Character,NULL_00000000-0000-0000-0000-000000000000);
		//END_REGION
		
		//REGION Trigger Spotter
		QRY
		Query_IsPlayerHiding((CHARACTERGUID)_Char)
		AND
		HasActiveStatus(_Char,"SNEAKING",1)
		THEN
		DB_NOOP(1);
		
		QRY
		Query_IsPlayerHiding((CHARACTERGUID)_Char)
		AND
		HasActiveStatus(_Char,"INVISIBLE",1)
		THEN
		DB_NOOP(1);
		
		IF
		DB_OneShot_DialogTrigger_NewSystem((TRIGGERGUID)_Trigger,(STRING)_,(CHARACTERGUID)_Spotter)
		THEN
		SetVarInteger(_Spotter,"IgnoreDialogChecks",0);
		DB_SneakTriggerSpotter(_Trigger,_Spotter);
		
		IF
		DB_OneShot_DialogTrigger_NewSystem((TRIGGERGUID)_Trigger,(STRING)_,(CHARACTERGUID)_Spotter1,(CHARACTERGUID)_Spotter2)
		THEN
		SetVarInteger(_Spotter1,"IgnoreDialogChecks",0);
		SetVarInteger(_Spotter2,"IgnoreDialogChecks",0);
		DB_SneakTriggerSpotter(_Trigger,_Spotter1);
		DB_SneakTriggerSpotter(_Trigger,_Spotter2);
		
		IF
		DB_OneShot_DialogTrigger_NewSystem((TRIGGERGUID)_Trigger,(STRING)_,(CHARACTERGUID)_Spotter1,(CHARACTERGUID)_Spotter2,(CHARACTERGUID)_Spotter3)
		THEN
		SetVarInteger(_Spotter1,"IgnoreDialogChecks",0);
		SetVarInteger(_Spotter2,"IgnoreDialogChecks",0);
		SetVarInteger(_Spotter3,"IgnoreDialogChecks",0);
		DB_SneakTriggerSpotter(_Trigger,_Spotter1);
		DB_SneakTriggerSpotter(_Trigger,_Spotter2);
		DB_SneakTriggerSpotter(_Trigger,_Spotter3);
		
		PROC
		ProcCharInTriggerSpotted((CHARACTERGUID)_Player,(TRIGGERGUID)_Trigger)
		AND
		DB_OneShot_DialogTrigger_NewSystem(_Trigger,_Dialog,_Spotter)
		THEN
		Proc_StartDialog(0,_Dialog,_Spotter,_Player);
		NOT DB_OneShot_DialogTrigger_NewSystem(_Trigger,_Dialog,_Spotter);
		
		PROC
		ProcCharInTriggerSpotted((CHARACTERGUID)_Player,(TRIGGERGUID)_Trigger)
		AND
		DB_OneShot_DialogTrigger_NewSystem(_Trigger,_Dialog,_Spotter1,_Spotter2)
		THEN
		Proc_StartDialog(0,_Dialog,_Spotter1,_Spotter2,_Player);
		NOT DB_OneShot_DialogTrigger_NewSystem(_Trigger,_Dialog,_Spotter1,_Spotter2);
		
		PROC
		ProcCharInTriggerSpotted((CHARACTERGUID)_Player,(TRIGGERGUID)_Trigger)
		AND
		DB_OneShot_DialogTrigger_NewSystem(_Trigger,_Dialog,_Spotter1,_Spotter2,_Spotter3)
		THEN
		Proc_StartDialog(0,_Dialog,_Spotter1,_Spotter2,_Spotter3,_Player);
		NOT DB_OneShot_DialogTrigger_NewSystem(_Trigger,_Dialog,_Spotter1,_Spotter2,_Spotter3);
		
		IF
		CharacterStatusRemoved(_Player,"SNEAKING",_)
		AND
		DB_IsPlayer(_Player)
		AND
		NOT Query_IsPlayerHiding(_Player)
		THEN
		SetStoryEvent(_Player,"BecameVisible");
		
		IF
		CharacterStatusRemoved(_Player,"INVISIBLE",_)
		AND
		DB_IsPlayer(_Player)
		AND
		NOT Query_IsPlayerHiding(_Player)
		THEN
		SetStoryEvent(_Player,"BecameVisible");
		
		IF
		CharacterStatusApplied(_Player,"SNEAKING",_)
		AND
		DB_IsPlayer(_Player)
		AND
		Query_IsPlayerHiding(_Player)
		THEN
		SetStoryEvent(_Player,"BecameInvisible");
		
		IF
		CharacterStatusApplied(_Player,"INVISIBLE",_)
		AND
		DB_IsPlayer(_Player)
		AND
		NOT Query_IsPlayerHiding(_Player)
		THEN
		SetStoryEvent(_Player,"BecameInvisible");
		
		IF
		DB_TriggerSendsSpotEvents(_Trigger)
		THEN
		ProcTriggerRegisterForPlayers(_Trigger);
		
		IF
		CharacterEnteredTrigger(_Player,_SpotTrigger)
		AND
		NOT Query_IsPlayerHiding(_Player)
		AND
		DB_TriggerSendsSpotEvents(_SpotTrigger)
		THEN
		DB_Event_CharacterAppearedInSpotTrigger(_Player,_SpotTrigger);
		NOT DB_Event_CharacterAppearedInSpotTrigger(_Player,_SpotTrigger);
		
		IF
		CharacterLeftTrigger(_Player,_SpotTrigger)
		AND
		NOT Query_IsPlayerHiding(_Player)
		AND
		DB_TriggerSendsSpotEvents(_SpotTrigger)
		THEN
		DB_Event_CharacterDisappearedInSpotTrigger(_Player,_SpotTrigger);
		NOT DB_Event_CharacterDisappearedInSpotTrigger(_Player,_SpotTrigger);
		
		IF
		StoryEvent((CHARACTERGUID)_Player,"BecameVisible")
		AND
		DB_InRegion(_Player,_SpotTrigger)
		AND
		DB_TriggerSendsSpotEvents(_SpotTrigger)
		THEN
		DB_Event_CharacterAppearedInSpotTrigger(_Player,_SpotTrigger);
		NOT DB_Event_CharacterAppearedInSpotTrigger(_Player,_SpotTrigger);
		
		IF
		StoryEvent((CHARACTERGUID)_Player,"BecameInvisible")
		AND
		DB_InRegion(_Player,_SpotTrigger)
		AND
		DB_TriggerSendsSpotEvents(_SpotTrigger)
		THEN
		DB_Event_CharacterDisappearedInSpotTrigger(_Player,_SpotTrigger);
		NOT DB_Event_CharacterDisappearedInSpotTrigger(_Player,_SpotTrigger);
		
		//END_REGION
		
		//REGION Global Event Memory
		IF
		GlobalFlagSet(_String)
		THEN
		DB_GlobalFlag(_String);
		
		IF
		GlobalFlagCleared(_String)
		THEN
		NOT DB_GlobalFlag(_String);
		//END_REGION
		
		//REGION Poof / Foop
		PROC
		Poof((GUIDSTRING)_Character)
		THEN
		Poof((GUIDSTRING)_Character,"RS3_FX_GP_ScriptedEvent_Teleport_GenericSmoke_01");
		
		PROC
		Poof((GUIDSTRING)_Character,(STRING)_Effect)
		AND
		GetRegion(_Character,_Region)
		AND
		DB_CurrentLevel(_Region)
		AND
		GetPosition(_Character,_X,_Y,_Z)
		THEN
		PlayEffectAtPosition(_Effect,_X,_Y,_Z);
		
		PROC
		Poof((GUIDSTRING)_Character,(STRING)_Effect)
		THEN
		SetOnStage(_Character,0);
		
		PROC
		Foop((GUIDSTRING)_Character)
		THEN
		Foop(_Character,"RS3_FX_GP_ScriptedEvent_Teleport_GenericSmoke_01");
		
		PROC
		Foop((GUIDSTRING)_Character,(STRING)_Effect)
		AND
		GetRegion(_Character,_Region)
		AND
		DB_CurrentLevel(_Region)
		AND
		GetPosition(_Character,_X,_Y,_Z)
		THEN
		PlayEffectAtPosition(_Effect,_X,_Y,_Z);
		
		PROC
		Foop((GUIDSTRING)_Character,(STRING)_Effect)
		THEN
		SetOnStage(_Character,1);
		
		IF
		StoryEvent(_Character,"GEN_GoOffStage")
		THEN
		SetOnStage(_Character,0);
		
		PROC
		Proc_PoofOnce((GUIDSTRING)_Character,(STRING)_OnlyOnce)
		AND
		NOT DB_OnlyOnce(_OnlyOnce)
		THEN
		Poof(_Character);
		DB_OnlyOnce(_OnlyOnce);
		//END_REGION
		
		//REGION Uniformly distributed Randoms (Fair random with memory)
		//Fair rand requires a UUID and a maxamount. The function will return [0,Maxamount-1]
		//When no previous data found, all possible numbers are added into an array.
		//Every FairRand query returns one random number from the array and removes it.
		//Only when the array is empty, is it reseeded.
		//Output: DB_FairRand_ReturnVal(INTEGER)
		
		//Clear return value
		QRY
		QRY_GetFairRand((STRING)_UUID,(INTEGER)_Amount)
		AND
		DB_FairRand_ReturnVal((INTEGER)_Number)
		THEN
		NOT DB_FairRand_ReturnVal(_Number);
		
		//If first time or all numbers used: reseed.
		QRY
		QRY_GetFairRand((STRING)_UUID,(INTEGER)_Amount)
		AND
		NOT DB_FairRand_Available(_UUID,_Amount,_)
		THEN
		Proc_SeedFairRand(_UUID,_Amount,_Amount);
		
		//Pick a random number from the available array (Put in new array with indeces, pick random index, return number)
		//Special case: Make sure that the first pick of a list is not the same as the last pick of the previous list
		QRY
		QRY_GetFairRand((STRING)_UUID,(INTEGER)_Amount)
		THEN
		DB_FairRandAmount(0);
		
		QRY
		QRY_GetFairRand((STRING)_UUID,(INTEGER)_Amount)
		AND
		_Amount > 1
		AND
		DB_FairRand_Last_Of_Previous_Seeding(_PreviousNumber)
		AND
		DB_FairRand_Available(_UUID,_Amount,_AvailableNumber)
		AND
		_PreviousNumber != _AvailableNumber
		AND
		DB_FairRandAmount(_Count)
		AND
		IntegerSum(_Count,1,_NewCount)
		THEN
		DB_FairRand_Array(_Count,_AvailableNumber);
		NOT DB_FairRandAmount(_Count);
		DB_FairRandAmount(_NewCount);
		DB_FairAmount_ListFilled(1);
		
		QRY
		QRY_GetFairRand((STRING)_UUID,(INTEGER)_Amount)
		AND
		DB_FairRand_Last_Of_Previous_Seeding(_Number)
		THEN
		NOT DB_FairRand_Last_Of_Previous_Seeding(_Number);
		
		QRY
		QRY_GetFairRand((STRING)_UUID,(INTEGER)_Amount)
		AND
		NOT DB_FairAmount_ListFilled(1)
		AND
		DB_FairRand_Available(_UUID,_Amount,_AvailableNumber)
		AND
		DB_FairRandAmount(_Count)
		AND
		IntegerSum(_Count,1,_NewCount)
		THEN
		DB_FairRand_Array(_Count,_AvailableNumber);
		NOT DB_FairRandAmount(_Count);
		DB_FairRandAmount(_NewCount);
		
		QRY
		QRY_GetFairRand((STRING)_UUID,(INTEGER)_Amount)
		AND
		DB_FairAmount_ListFilled(1)
		THEN
		NOT DB_FairAmount_ListFilled(1);
		
		QRY
		QRY_GetFairRand((STRING)_UUID,(INTEGER)_Amount)
		AND
		DB_FairRandAmount(_Count)
		AND
		_Count > 0
		AND
		Random(_Count,_Index)
		AND
		DB_FairRand_Array(_Index,_Number)
		THEN
		NOT DB_FairRand_Available(_UUID,_Amount,_Number);
		DB_FairRand_ReturnVal(_Number);
		
		//If this was the last value in the available list, remember it, so we don't pick it first in the next list.
		QRY
		QRY_GetFairRand((STRING)_UUID,(INTEGER)_Amount)
		AND
		NOT DB_FairRand_Available(_UUID,_Amount,_)
		AND
		DB_FairRand_ReturnVal(_Number)
		THEN
		DB_FairRand_Last_Of_Previous_Seeding(_Number);
		
		//Clean up temp vars
		QRY
		QRY_GetFairRand((STRING)_UUID,(INTEGER)_MaxAmount)
		AND
		DB_FairRandAmount(_Amount)
		THEN
		NOT DB_FairRandAmount(_Amount);
		
		QRY
		QRY_GetFairRand((STRING)_UUID,(INTEGER)_Amount)
		AND
		DB_FairRand_Array(_Index,_Number)
		THEN
		NOT DB_FairRand_Array(_Index,_Number);
		
		PROC
		Proc_SeedFairRand((STRING)_UUID,(INTEGER)_MaxAmount,(INTEGER)_Amount)
		AND
		_Amount > 0
		AND
		IntegerSubtract(_Amount,1,_NewAmount)
		THEN
		DB_FairRand_Available(_UUID,_MaxAmount,_NewAmount);
		Proc_SeedFairRand(_UUID,_MaxAmount,_NewAmount);
		//END_REGION
		
		//REGION Get Random position in coordinate-based area ignoring AI grid
		// Pass in two objects. Returns point within cube defined by their coordinates
		// Returns result in DB_Helper_GetAnyRandomPositionInArea_Result(_X,_Y,_Z)
		// NOTE: only tested currently with all coordinates of FirstPoint <= coordinates of _SecondPoint
		//   I don't know whether our random can handle a negative module.
		QRY
		QRY_Helper_GetAnyRandomPositionInArea((GUIDSTRING)_FirstPoint,(GUIDSTRING)_SecondPoint)
		AND
		DB_Helper_GetAnyRandomPositionInArea_Result(_X,_Y,_Z)
		THEN
		NOT DB_Helper_GetAnyRandomPositionInArea_Result(_X,_Y,_Z);
		
		QRY
		QRY_Helper_GetAnyRandomPositionInArea((GUIDSTRING)_BottomLeftBack,(GUIDSTRING)_TopRightFront)
		AND
		GetPosition(_BottomLeftBack,_X1,_Y1,_Z1)
		AND
		GetPosition(_TopRightFront,_X2,_Y2,_Z2)
		AND
		RealSubtract(_X2,_X1,_XDeltaReal)
		AND
		RealSubtract(_Y2,_Y1,_YDeltaReal)
		AND
		RealSubtract(_Z2,_Z1,_ZDeltaReal)
		AND
		RealProduct(_XDeltaReal,100.0,_XScaledDeltaReal)
		AND
		RealProduct(_YDeltaReal,100.0,_YScaledDeltaReal)
		AND
		RealProduct(_ZDeltaReal,100.0,_ZScaledDeltaReal)
		AND
		Integer(_XScaledDeltaReal,_XScaledDeltaInt)
		AND
		Integer(_YScaledDeltaReal,_YScaledDeltaInt)
		AND
		Integer(_ZScaledDeltaReal,_ZScaledDeltaInt)
		AND
		Random(_XScaledDeltaInt,_XRandScaledDeltaInt)
		AND
		Random(_YScaledDeltaInt,_YRandScaledDeltaInt)
		AND
		Random(_ZScaledDeltaInt,_ZRandScaledDeltaInt)
		AND
		Real(_XRandScaledDeltaInt,_XRandScaledDeltaReal)
		AND
		Real(_YRandScaledDeltaInt,_YRandScaledDeltaReal)
		AND
		Real(_ZRandScaledDeltaInt,_ZRandScaledDeltaReal)
		AND
		RealDivide(_XRandScaledDeltaReal,100.0,_XRandDeltaReal)
		AND
		RealDivide(_YRandScaledDeltaReal,100.0,_YRandDeltaReal)
		AND
		RealDivide(_ZRandScaledDeltaReal,100.0,_ZRandDeltaReal)
		AND
		RealSum(_X1,_XRandDeltaReal,_NewX)
		AND
		RealSum(_Y1,_YRandDeltaReal,_NewY)
		AND
		RealSum(_Z1,_ZRandDeltaReal,_NewZ)
		THEN
		DB_Helper_GetAnyRandomPositionInArea_Result(_NewX,_NewY,_NewZ);
		//END_REGION
		
		//REGION Singleton Variables //A variable which can only hold one value. All old value get overwritten.
		IF
		DB_Singleton(_VariableNam,_NewValue)
		AND
		DB_Singleton(_VariableNam,_OldValue)
		AND
		_NewValue != _OldValue
		THEN
		NOT DB_Singleton(_VariableNam,_OldValue);
		//END_REGION
		
		//REGION Only Once Rule Query
		QRY
		QueryOnlyOnce((STRING)_OnlyOnceUUID)
		AND
		NOT DB_OnlyOnce(_OnlyOnceUUID)
		THEN
		DB_OnlyOnce(_OnlyOnceUUID);
		//END_REGION
		
		//REGION Only once per user, but also mark users of nearby players
		// NOTE: this is intended as replacement for triggering ADs guarded by a
		//   QueryOnlyOnce(). It does not check for all corner cases, such as
		//   character reassignment to another user. It's just meant to increase
		//   the chances that every user will see an AD rather than only the first
		//   one.
		
		// Use for atmospheric ADs that don't influence progression, and which are
		// nice for a player to see/hear at least once. It avoids playing the same
		// AD for multiple users in case they already heard another user's player
		// say it, and at the same time allows different users to have the same AD
		// if they arrive at a spot/perform the same action at different times.
		QRY
		QRY_OncePerUserAndNearbyPlayers((CHARACTERGUID)_Player, (STRING)_Flag)
		AND
		QRY_OncePerUserAndNearbyPlayers(_Player, _Flag, 10.0)
		THEN
		DB_NOOP(1);
		
		QRY
		QRY_OncePerUserAndNearbyPlayers((CHARACTERGUID)_Player, (STRING)_Flag, (REAL)_Range)
		AND
		UserGetFlag(_Player, _Flag, 0)
		THEN
		PROC_OncePerUserAndNearbyPlayers_SetFlag(_Player, _Flag, _Range);
		
		PROC
		PROC_OncePerUserAndNearbyPlayers_SetFlag((CHARACTERGUID)_Player, (STRING)_Flag, (REAL)_Range)
		AND
		DB_IsPlayer(_OtherPlayer)
		AND
		GetDistanceTo(_Player, _OtherPlayer, _Dist)
		AND
		_Dist < _Range
		THEN
		// Will also catch _Player himself
		UserSetFlag(_OtherPlayer, _Flag);
		//END_REGION
		
		//REGION Small macros
		PROC
		PROC_RemoveDialogFromCharacter((CHARACTERGUID)_NPC)
		THEN
		DialogRequestStop(_NPC);
		ProcRemoveAllDialogEntriesForSpeaker(_NPC);
		SetHasDialog(_Npc,0);
		//END_REGION
		
		//REGION Counter Helper
		PROC
		Proc_CountHelper((STRING)_ID)
		AND
		NOT DB_CountHelper(_ID,_)
		THEN
		DB_CountHelper(_ID,0);
		
		PROC
		Proc_CountHelper((STRING)_ID)
		AND
		DB_CountHelper(_ID,_OldValue)
		AND
		IntegerSum(_OldValue,1,_Value)
		THEN
		NOT DB_CountHelper(_ID,_OldValue);
		DB_CountHelper(_ID,_Value);
		
		PROC
		Proc_CharCountHelper((CHARACTERGUID)_Char,(STRING)_ID)
		THEN
		Proc_CharCountHelper(_Char,_ID,1);
		
		PROC
		Proc_CharCountHelper((CHARACTERGUID)_Char,(STRING)_ID,_)
		AND
		NOT DB_CharCountHelper(_Char,_ID,_)
		THEN
		DB_CharCountHelper(_Char,_ID,0);
		
		PROC
		Proc_CharCountHelper((CHARACTERGUID)_Char,(STRING)_ID,(INTEGER)_Count)
		AND
		DB_CharCountHelper(_Char,_ID,_OldValue)
		AND
		IntegerSum(_OldValue,_Count,_Value)
		THEN
		NOT DB_CharCountHelper(_Char,_ID,_OldValue);
		DB_CharCountHelper(_Char,_ID,_Value);
		
		PROC
		Proc_CharCountHelperReset((CHARACTERGUID)_Char,(STRING)_ID)
		AND
		DB_CharCountHelper(_Char,_ID,_Counter)
		THEN
		NOT DB_CharCountHelper(_Char,_ID,_Counter);
		//END_REGION
		
		//REGION Unregister a Trigger For a User
		// Note: this routines errs on the side of keeping the trigger unregistered.
		// E.g., if a character is assigned to a user without other characters, triggers
		// will kept be kept unregistered for that character if they had been unregistered
		// before.
		PROC 
		ProcUnregisterForUser((TRIGGERGUID)_Trigger,(CHARACTERGUID)_Player)
		AND
		CharacterGetReservedUserID(_Player,_UserID)
		AND 
		DB_IsPlayer(_OtherPlayer)
		AND
		CharacterGetReservedUserID(_OtherPlayer,_UserID)
		THEN 
		DB_TriggerUnregisteredForUserChar(_Trigger,_OtherPlayer);
		TriggerUnregisterForCharacter(_Trigger,_OtherPlayer);
		
		IF
		CharacterReservedUserIDChanged(_Player,_,_UserID)
		AND
		DB_IsPlayer(_Player)
		AND
		DB_IsPlayer(_OtherPlayer)
		AND
		NOT DB_UnregisterForUserIDChanged(1)
		AND
		_OtherPlayer != _Player
		AND
		CharacterGetReservedUserID(_OtherPlayer,_UserID)
		THEN
		DB_UnregisterForUserIDChanged(1);
		// Only have to call this for one character, because this logic keeps it the
		// same for all of the characters assigned to a single user
		ProcUnregisterForUserIDChanged(_OtherPlayer,_Player);
		
		PROC
		ProcUnregisterForUserIDChanged((CHARACTERGUID)_ExistingPlayer,(CHARACTERGUID)_NewPlayer)
		AND
		DB_TriggerUnregisteredForUserChar(_Trigger,_ExistingPlayer)
		AND
		NOT DB_TriggerUnregisteredForUserChar(_Trigger,_NewPlayer)
		THEN
		DB_TriggerUnregisteredForUserChar(_Trigger,_NewPlayer);
		TriggerUnregisterForCharacter(_Trigger,_NewPlayer);
		
		PROC
		ProcUnregisterForUserIDChanged((CHARACTERGUID)_ExistingPlayer,(CHARACTERGUID)_NewPlayer)
		AND
		DB_TriggerUnregisteredForUserChar(_Trigger,_NewPlayer)
		AND
		NOT DB_TriggerUnregisteredForUserChar(_Trigger,_ExistingPlayer)
		THEN
		NOT DB_TriggerUnregisteredForUserChar(_Trigger,_NewPlayer);
		TriggerRegisterForCharacter(_Trigger,_NewPlayer);
		
		IF
		CharacterReservedUserIDChanged(_Player,_,_UserID)
		THEN
		NOT DB_UnregisterForUserIDChanged(1);
		
		//END_REGION
		
		//REGION Turn Skipping
		//While in DB_CharacterSkipTurn(_Char), skip turn
		//
		IF
		ObjectFlagSet("GEN_EndTurn",_Char,_)
		THEN
		EndTurn(_Char);
		ObjectClearFlag(_Char,"GEN_EndTurn",0);
		
		IF
		ObjectFlagSet("GEN_SkipToTurn",_Char,_)
		AND
		DB_CombatObjects(_Char,_)
		THEN
		DB_CharacterSkipTurn(_Char);
		ObjectClearFlag(_Char,"GEN_SkipToTurn",0);
		
		IF
		ObjectTurnStarted(_Char)
		AND
		DB_CharacterSkipTurn(_Char)
		THEN
		EndTurn(_Char);
		
		PROC
		Proc_PurgeSkipTurnDB()
		AND
		DB_CharacterSkipTurn(_Char)
		THEN
		NOT DB_CharacterSkipTurn(_Char);
		
		IF
		ObjectTurnStarted(_Char)
		AND
		DB_SkipToCharactersTurn(_CharsTurn)
		AND
		DB_CombatObjects(_Char,_ID)
		AND
		DB_CombatObjects(_CharsTurn,_ID)
		AND
		_Char != _CharsTurn
		THEN
		EndTurn(_Char);
		
		IF
		ObjectTurnStarted(_Char)
		AND
		DB_SkipToCharactersTurn(_Char)
		THEN
		NOT DB_SkipToCharactersTurn(_Char);
		
		IF
		ObjectFlagSet("GEN_DisappearOutOfSight",(CHARACTERGUID)_Char,_)
		THEN
		ProcCharacterDisappearOutOfSight(_Char,0,1,"",0);
		ObjectClearFlag(_Char,"GEN_DisappearOutOfSight",0);
		
		IF
		ObjectLeftCombat((CHARACTERGUID)_Char,_)
		AND
		ObjectGetFlag(_Char,"GEN_DisappearOutOfSightWhenAvailable",1)
		AND
		QRY_SpeakerIsAvailable(_Char)
		THEN
		ProcCharacterDisappearOutOfSight(_Char,0,1,"",0);
		ObjectClearFlag(_Char,"GEN_DisappearOutOfSightWhenAvailable",0);
		
		IF
		DialogEnded(_,_ID)
		AND
		DialogGetInvolvedNPC(_ID,1,(CHARACTERGUID)_Char)
		AND
		ObjectGetFlag(_Char,"GEN_DisappearOutOfSightWhenAvailable",1)
		AND
		QRY_SpeakerIsAvailable(_Char)
		THEN
		ProcCharacterDisappearOutOfSight(_Char,0,1,"",0);
		ObjectClearFlag(_Char,"GEN_DisappearOutOfSightWhenAvailable",0);
		
		IF
		CharacterStoppedPolymorph(_Char)
		AND
		ObjectGetFlag(_Char,"GEN_DisappearOutOfSightWhenAvailable",1)
		AND
		QRY_SpeakerIsAvailable(_Char)
		THEN
		ProcCharacterDisappearOutOfSight(_Char,0,1,"",0);
		ObjectClearFlag(_Char,"GEN_DisappearOutOfSightWhenAvailable",0);
		//END_REGION
		
		//REGION Move an item locally
		//Add to an items X, Y and Z values
		//
		PROC 
		ProcItemLocalMove((ITEMGUID)_Item,(REAL)_PlusX,(REAL)_PlusY,(REAL)_PlusZ,(REAL)_Speed,(REAL)_Acceleration)
		AND
		GetPosition(_Item,_X,_Y,_Z)
		AND
		RealSum(_X,_PlusX,_TargetX)
		AND
		RealSum(_Y,_PlusY,_TargetY)
		AND
		RealSum(_Z,_PlusZ,_TargetZ)
		THEN
		Proc_ItemMoveToPosition(_Item,_TargetX,_TargetY,_TargetZ,_Speed,_Acceleration);
		
		
		//END_REGION
		
		//REGION Force End a Dialog
		//for use in behaviour scripts 
		IF
		StoryEvent((GUIDSTRING)_Object,"ForceStopDialog")
		THEN
		ProcForceStopDialog(_Object);
		
		PROC 
		ProcForceStopDialog((GUIDSTRING)_Object)
		THEN
		DialogRequestStop(_Object);
		
		//END_REGION
		
		//REGION Generic hostile after dialog
		//NPC in the dialogue will go hostile to the Player that this event is set on at the end of the dialog
		IF
		ObjectFlagSet("FactionHostileToIndivPlayerAfterDialog",(CHARACTERGUID)_Player,_Id)
		THEN
		DB_HostileToIndivPlayerAfterDialog(_Player,_Id);
		
		IF
		DialogEnded(_,_Id)
		AND
		DB_HostileToIndivPlayerAfterDialog(_Player,_Id)
		AND
		DB_DialogNPCs(_Id,_Char,_)
		THEN
		ProcSetHostileToIndivPlayer((CHARACTERGUID)_Char,_Player);
		ObjectClearFlag(_Player,"FactionHostileToIndivPlayerAfterDialog",_Id);
		NOT DB_HostileToIndivPlayerAfterDialog(_Player,_Id);
		
		//NPC in the dialogue will go hostile to the Player that this event is set on at the end of the dialog, and stay hostile to other players who attack it.
		IF
		ObjectFlagSet("FactionHostileToPlayerGroupAfterDialog",(CHARACTERGUID)_Player,_Id)
		AND
		DB_HostileToPlayerGroupCancelFlag(_Flag, _Character)
		AND
		PartyGetFlag(_Player, _Flag,  0)
		THEN
		DB_HostileToPlayerGroupAfterDialog(_Player,_Id);
		
		//NPC in the dialogue will go hostile to the Player that this event is set on at the end of the dialog, and stay hostile to other players who attack it.
		IF
		ObjectFlagSet("FactionHostileToPlayerGroupAfterDialog",(CHARACTERGUID)_Player,_Id)
		AND
		NOT DB_HostileToPlayerGroupCancelFlag(_, _)
		THEN
		DB_HostileToPlayerGroupAfterDialog(_Player,_Id);
		
		IF
		ObjectFlagSet("FactionHostileToPlayerGroupAfterDialog",(CHARACTERGUID)_Player,_Id)
		AND
		DB_HostileToPlayerGroupCancelFlag(_Flag, _Character)
		AND
		PartyGetFlag(_Player, _Flag,  1)
		THEN
		DB_TemporaryHostilityAfterDialog(_Player,_Id);
		NOT DB_SetNeutralToPlayerGroupAfterDialog(_ID, (CHARACTERGUID)_Player, (CHARACTERGUID)_Character);
		
		IF
		DialogEnded(_,_Id)
		AND
		DB_HostileToPlayerGroupAfterDialog(_Player,_Id)
		AND
		DB_DialogNPCs(_Id,_Char,_)
		THEN
		ObjectClearFlag(_Player,"FactionHostileToPlayerGroupAfterDialog",_Id);
		DB_HostileToPlayerGroup(_Char, _Player);
		NOT DB_HostileToPlayerGroupAfterDialog(_Player,_Id);
		EnterCombat(_Char, _Player);
		
		IF
		DB_CombatCharacters(_, _ID)
		THEN
		PROC_GEN_UpdateHostilePlayerGroup(_ID);
		
		PROC
		PROC_GEN_UpdateHostilePlayerGroup((INTEGER)_ID)
		AND
		DB_CombatCharacters(_Char, _ID)
		AND
		DB_HostileToPlayerGroup(_Char, _)
		THEN
		PROC_GEN_UpdateHostilePlayerGroupForChar(_Char);
		
		PROC
		PROC_GEN_UpdateHostilePlayerGroupForChar((CHARACTERGUID)_Char)
		AND
		DB_CombatCharacters(_Char, _ID)
		AND
		DB_CombatCharacters(_Player, _ID)
		AND
		DB_HostileToPlayerGroup(_Char, _Player)
		AND
		DB_IsPlayer(_OtherPlayer)
		AND
		DB_CombatCharacters(_OtherPlayer, _ID)
		AND
		NOT DB_HostileToPlayerGroup(_Char, _OtherPlayer)
		AND
		CharacterIsInPartyWith(_Player, _OtherPlayer, 1)
		THEN
		DB_HostileToPlayerGroup(_Char, _OtherPlayer);
		
		IF
		DB_HostileToPlayerGroup(_Char, _Player)
		AND
		GetFaction(_Char, _Faction1)
		AND
		GetFaction(_Player, _Faction2)
		THEN
		CharacterSetRelationFactionToFaction(_Faction1, _Faction2, 0);
		CharacterSetRelationFactionToFaction(_Faction2, _Faction1, 0);
		
		IF
		ObjectFlagSet(_Flag, _Player, _)
		AND
		DB_HostileToPlayerGroupCancelFlag(_Flag, _Character)
		AND
		DB_HostileToPlayerGroupAfterDialog((CHARACTERGUID)_Player, _Id)
		AND
		DB_DialogNPCs(_Id, _Character, _)
		THEN
		NOT DB_HostileToPlayerGroupAfterDialog(_Player, _Id);
		DB_TemporaryHostilityAfterDialog(_Player,_Id);
		
		IF
		DB_HostileToPlayerGroup(_Character, _Player)
		AND
		DB_HostileToPlayerGroupCancelFlag(_Flag, _Character)
		AND
		PartyGetFlag((CHARACTERGUID)_Player, _Flag, 1)
		THEN
		NOT DB_HostileToPlayerGroup(_Character, _Player);
		
		IF
		ObjectFlagSet(_Flag, _Player, _)
		AND
		DB_HostileToPlayerGroupCancelFlag(_Flag, _Character)
		THEN
		NOT DB_HostileToPlayerGroup(_Character, (CHARACTERGUID)_Player);
		
		IF
		ObjectFlagSet(_Flag, _Player, _)
		AND
		DB_HostileToPlayerGroup(_Character, (CHARACTERGUID)_Player)
		AND
		DB_HostileToPlayerGroupCancelFlag(_Flag, _Character)
		THEN
		PROC_HostileToPlayerGroupCancelFlag_TryCancel((CHARACTERGUID)_Player, (CHARACTERGUID)_Character);
		
		PROC
		PROC_HostileToPlayerGroupCancelFlag_TryCancel((CHARACTERGUID)_Player, (CHARACTERGUID)_Character)
		AND
		NOT DB_DialogPlayers(_, _Player, _)
		AND
		NOT DB_DialogNPCs(_, _Character, _)
		AND
		GetFaction(_Player, _Faction)
		AND
		GetFaction(_Character, _OtherFaction)
		THEN
		CharacterSetRelationFactionToFaction(_OtherFaction, _Faction, 50);
		CharacterSetRelationFactionToFaction(_Faction, _OtherFaction, 50);
		
		PROC
		PROC_HostileToPlayerGroupCancelFlag_TryCancel((CHARACTERGUID)_Player, (CHARACTERGUID)_Character)
		AND
		DB_DialogPlayers(_ID, _Player, _)
		AND
		NOT QRY_SFI_PEN_HostileToPlayergroupAfterDialog_InHostileDialog((CHARACTERGUID)_Player, (CHARACTERGUID)_Character, _ID)
		THEN
		DB_SetNeutralToPlayerGroupAfterDialog(_ID, _Player, _Character);
		
		PROC
		PROC_HostileToPlayerGroupCancelFlag_TryCancel((CHARACTERGUID)_Player, (CHARACTERGUID)_Character)
		AND
		DB_DialogNPCs(_ID, _Character, _)
		AND
		NOT QRY_SFI_PEN_HostileToPlayergroupAfterDialog_InHostileDialog((CHARACTERGUID)_Player, (CHARACTERGUID)_Character, _ID)
		THEN
		DB_SetNeutralToPlayerGroupAfterDialog(_ID, _Player, _Character);
		
		QRY
		QRY_SFI_PEN_HostileToPlayergroupAfterDialog_InHostileDialog((CHARACTERGUID)_Player, (CHARACTERGUID)_Character, (INTEGER)_Id)
		AND
		DB_HostileToPlayerGroupAfterDialog((CHARACTERGUID)_Player, _Id)
		AND
		DB_DialogNPCs(_Id,_Character,_)
		THEN
		DB_NOOP(0);
		
		IF
		DialogEnded(_, _ID)
		AND
		DB_SetNeutralToPlayerGroupAfterDialog(_ID, _Player, _Character)
		THEN
		NOT DB_SetNeutralToPlayerGroupAfterDialog(_ID, _Player, _Character);
		PROC_HostileToPlayerGroupCancelFlag_TryCancel((CHARACTERGUID)_Player, (CHARACTERGUID)_Character);
		
		//Temp Hostility
		IF
		ObjectFlagSet("TemporaryHostilityAfterDialog",(CHARACTERGUID)_Player,_Id)
		THEN
		DB_TemporaryHostilityAfterDialog(_Player,_Id);
		
		IF
		DialogEnded(_,_Id)
		AND
		DB_TemporaryHostilityAfterDialog(_Player,_Id)
		AND
		DB_DialogNPCs(_Id,_Char,_)
		THEN
		ProcMakeNPCHostile((CHARACTERGUID)_Char,_Player);
		ObjectClearFlag(_Player,"TemporaryHostilityAfterDialog",_Id);
		NOT DB_TemporaryHostilityAfterDialog(_Player,_Id);
		
		//Set Attitude to -100 after dialog
		IF
		ObjectFlagSet("HostileAttitudeAfterDialog",(CHARACTERGUID)_Player,_Id)
		THEN
		DB_HostileAttitudeAfterDialog(_Player,_Id);
		
		IF
		DialogEnded(_,_Id)
		AND
		DB_HostileAttitudeAfterDialog(_Player,_Id)
		AND
		DB_DialogNPCs(_Id,_Char,_)
		THEN
		CharacterAddAttitudeTowardsPlayer((CHARACTERGUID)_Char,_Player,-100);
		ObjectClearFlag(_Player,"HostileAttitudeAfterDialog",_Id);
		NOT DB_HostileAttitudeAfterDialog(_Player,_Id);
		
		
		//Set Evil NPC after Dialog
		IF
		ObjectFlagSet("HostileAlignmentAfterDialog",(CHARACTERGUID)_Player,_Id)
		THEN
		DB_HostileAlignmentAfterDialog(_Player,_Id);
		
		IF
		DialogEnded(_,_Id)
		AND
		DB_HostileAlignmentAfterDialog(_Player,_Id)
		AND
		DialogGetInvolvedNPC(_Id,1,(CHARACTERGUID)_Char)
		THEN
		ProcSetRelationToPlayers(_Char,0);
		ObjectClearFlag(_Player,"HostileAlignmentAfterDialog",_Id);
		NOT DB_HostileAlignmentAfterDialog(_Player,_Id);
		
		
		//END_REGION
		
		//REGION Character Dies After Dialog Ends
		
		IF
		ObjectFlagSet("CharacterDieAfterDialog",(CHARACTERGUID)_Player,_Id)
		THEN
		DB_CharacterDieAfterDialog(_Player,_Id);
		
		IF
		DialogEnded(_,_Id)
		AND
		DB_CharacterDieAfterDialog(_Player,_Id)
		THEN
		CharacterDie(_Player,0,"DoT");
		ObjectClearFlag(_Player,"CharacterDieAfterDialog",_Id);
		NOT DB_CharacterDieAfterDialog(_Player,_Id);
		
		
		
		//END_REGION
		
		//REGION Res, Heal, and remove statuses from a player
		
		PROC
		Proc_CharacterFullRestore((CHARACTERGUID)_Char)
		THEN
		CharacterResurrect(_Char);
		RemoveHarmfulStatuses(_Char);
		CharacterSetHitpointsPercentage(_Char,100.0);
		CharacterSetArmorPercentage(_Char,100.0);
		CharacterSetMagicArmorPercentage(_Char,100.0);
		CharacterResetCooldowns(_Char);
		
		
		//END_REGION
		
		//REGION Camera Shake around Player
		
		PROC
		Proc_ShakeCameraForTime((CHARACTERGUID)_Char,(INTEGER)_Time)
		AND
		GetUUID(_Char,_UUID)
		AND
		StringConcatenate("CameraShake_",_UUID,_ID)
		THEN
		PROC_LoopEffect("RS3_FX_GP_ScriptedEvent_CameraShake_Loop_00-50",_Char,_ID,"__ANY__","");
		ProcObjectTimer(_Char,"Timer_LoopCameraShakeHelper",_Time);
		
		PROC
		ProcObjectTimerFinished(_Char,"Timer_LoopCameraShakeHelper")
		AND
		GetUUID(_Char,_UUID)
		AND
		StringConcatenate("CameraShake_",_UUID,_ID)
		THEN
		PROC_StopLoopEffect(_Char,_ID);
		
		PROC
		Proc_CameraShakeAroundCharacter((GUIDSTRING)_Object,(INTEGER)_Duration,(REAL)_Radius)
		AND
		DB_IsPlayer(_Player)
		AND
		GetDistanceTo(_Player,_Object,_Dist)
		AND
		_Dist <= _Radius
		THEN
		PlayEffect(_Player,"RS3_FX_GP_Combat_CameraShake_A");
		ProcObjectTimer(_Player,"ShakeCameraOn_",200);
		DB_CameraShakeAroundCharacter(_Object,_Duration,_Radius);
		
		
		PROC
		ProcObjectTimerFinished((CHARACTERGUID)_Player,"ShakeCameraOn_")
		AND
		DB_CameraShakeAroundCharacter(_Object,_Duration,_Radius)
		AND
		IntegerSubtract(_Duration,200,_Dif)
		AND
		_Dif >= 0
		THEN
		NOT DB_CameraShakeAroundCharacter(_Object,_Duration,_Radius);
		Proc_CameraShakeAroundCharacter(_Object,_Dif,_Radius);
		
		PROC
		ProcObjectTimerFinished((CHARACTERGUID)_Player,"ShakeCameraOn_")
		AND
		DB_CameraShakeAroundCharacter(_Object,_Duration,_Radius)
		AND
		IntegerSubtract(_Duration,200,_Dif)
		AND
		_Dif < 0.0
		THEN
		NOT DB_CameraShakeAroundCharacter(_Object,_Duration,_Radius);
		
		//END_REGION
		
		//REGION Add/Remove Source Points
		IF
		ObjectFlagSet("RemoveSourcePoints",(CHARACTERGUID)_Char,_)
		THEN
		ObjectClearFlag(_Char,"RemoveSourcePoints",0);
		Proc_RemoveSourcePoints(_Char);
		
		IF
		ObjectFlagSet("RemoveOneSourcePoint",(CHARACTERGUID)_Char,_)
		THEN
		ObjectClearFlag(_Char,"RemoveOneSourcePoint",0);
		CharacterAddSourcePoints(_Char, -1);
		
		
		IF
		ObjectFlagSet("AddSourcePoint",(CHARACTERGUID)_Char,_)
		THEN
		ObjectClearFlag(_Char,"AddSourcePoint",0);
		Proc_AddSourcePoint(_Char);
		
		IF
		ObjectFlagSet("AddTwoSourcePoints",(CHARACTERGUID)_Char,_)
		THEN
		ObjectClearFlag(_Char,"AddTwoSourcePoints",0);
		Proc_AddSourcePoint(_Char);
		Proc_AddSourcePoint(_Char);
		
		PROC
		Proc_AddSourcePoint((CHARACTERGUID)_Char)
		THEN
		CharacterAddSourcePoints(_Char,1);
		
		PROC
		Proc_RemoveSourcePoints((CHARACTERGUID)_Char)
		THEN
		CharacterAddSourcePoints(_Char,-100);
		
		//END_REGION
		
		QRY
		QRY_GLO_IsVisibleUndead((CHARACTERGUID)_Char)
		AND
		IsTagged(_Char, "UNDEAD", 1)
		AND
		IsTagged(_Char, "VEILED_UNDEAD", 0)
		AND
		IsTagged(_Char, "MASKED_UNDEAD", 0)
		THEN
		DB_NOOP(0);
		
		IF
		StoryEvent((CHARACTERGUID)_Char,"GEN_PurgeQueue")
		THEN
		ProcClearStoryMove(_Char);
		
		//REGION Do Knockdown fall / getup Animation
		IF
		StoryEvent((CHARACTERGUID)_Char,"GEN_FallAndGetUp")
		THEN
		PlayAnimation(_Char,"knockdown_fall","Play_Anim_knockdown_getup");
		
		IF
		StoryEvent((CHARACTERGUID)_Char,"Play_Anim_knockdown_getup")
		THEN
		PlayAnimation(_Char,"knockdown_getup");
		
		//END_REGION
		
		//REGION Do Knockdown fall / knockdown loop Animation
		IF
		StoryEvent((CHARACTERGUID)_Char,"GEN_FallAndLie")
		THEN
		PlayAnimation(_Char,"knockdown_fall","Play_Anim_knockdown_loop");
		
		IF
		StoryEvent((CHARACTERGUID)_Char,"Play_Anim_knockdown_loop")
		THEN
		CharacterSetAnimationOverride(_Char,"knockdown_loop");
		
		//END_REGION
		
		//REGION Is Available to
		
		QRY
		QRY_IsAvailableTo((CHARACTERGUID)_Char,(CHARACTERGUID)_Target)
		AND
		QRY_SpeakerIsAvailable(_Char)
		AND
		QRY_SpeakerIsAvailable(_Target)
		AND
		CharacterCanSee(_Char,_Target,1)
		THEN
		DB_NOOP(1);
		
		//END_REGION
		
		//REGION Lookat in Dialog
		
		IF
		ObjectFlagSet("LookAtPlayer",(CHARACTERGUID)_Char,_ID)
		AND
		DialogGetInvolvedPlayer(_ID,1,(CHARACTERGUID)_Player)
		THEN
		CharacterLookAt(_Char,_Player);
		ObjectClearFlag(_Char,"LookAtPlayer",0);
		
		//END_REGION
		
		//REGION MoveTo in Dialog
		
		IF
		ObjectFlagSet("Speaker1MoveTo",(CHARACTERGUID)_Char,_ID)
		AND
		DialogGetInvolvedNPC(_ID,1,(CHARACTERGUID)_Speaker1)
		THEN
		CharacterMoveTo(_Speaker1,_Char,0,"",0);
		ObjectClearFlag(_Char,"Speaker1MoveTo",0);
		
		IF
		ObjectFlagSet("Speaker2MoveTo",(CHARACTERGUID)_Char,_ID)
		AND
		DialogGetInvolvedNPC(_ID,2,(CHARACTERGUID)_Speaker2)
		THEN
		CharacterMoveTo(_Speaker2,_Char,0,"",0);
		ObjectClearFlag(_Char,"Speaker2MoveTo",0);
		
		IF
		ObjectFlagSet("Player1MoveTo",(CHARACTERGUID)_Char,_ID)
		AND
		DialogGetInvolvedPlayer(_ID,1,(CHARACTERGUID)_Player)
		THEN
		CharacterMoveTo(_Player,_Char,0,"",0);
		ObjectClearFlag(_Char,"Player1MoveTo",0);
		
		IF
		ObjectFlagSet("Player2MoveTo",(CHARACTERGUID)_Char,_ID)
		AND
		DialogGetInvolvedPlayer(_ID,2,(CHARACTERGUID)_Player)
		THEN
		CharacterMoveTo(_Player,_Char,0,"",0);
		ObjectClearFlag(_Char,"Player2MoveTo",0);
		
		IF
		ObjectFlagSet("Speaker1RunTo",(CHARACTERGUID)_Char,_ID)
		AND
		DialogGetInvolvedNPC(_ID,1,(CHARACTERGUID)_Speaker1)
		THEN
		CharacterMoveTo(_Speaker1,_Char,1,"",0);
		ObjectClearFlag(_Char,"Speaker1MoveTo",0);
		
		IF
		ObjectFlagSet("Speaker2RunTo",(CHARACTERGUID)_Char,_ID)
		AND
		DialogGetInvolvedNPC(_ID,2,(CHARACTERGUID)_Speaker2)
		THEN
		CharacterMoveTo(_Speaker2,_Char,1,"",0);
		ObjectClearFlag(_Char,"Speaker2MoveTo",0);
		
		IF
		ObjectFlagSet("Player1RunTo",(CHARACTERGUID)_Char,_ID)
		AND
		DialogGetInvolvedPlayer(_ID,1,(CHARACTERGUID)_Player)
		THEN
		CharacterMoveTo(_Player,_Char,1,"",0);
		ObjectClearFlag(_Char,"Player1MoveTo",0);
		
		IF
		ObjectFlagSet("Player2RunTo",(CHARACTERGUID)_Char,_ID)
		AND
		DialogGetInvolvedPlayer(_ID,2,(CHARACTERGUID)_Player)
		THEN
		CharacterMoveTo(_Player,_Char,1,"",0);
		ObjectClearFlag(_Char,"Player2MoveTo",0);
		
		//END_REGION
		
		//REGION Animation testing
		IF
		TextEventSet("AnimTest")
		AND
		CharacterGetHostCharacter((CHARACTERGUID)_Player)
		AND
		GetTextEventParamInteger(1,0)
		THEN
		CharacterPurgeQueue(_Player);
		
		IF
		TextEventSet("AnimTest")
		AND
		CharacterGetHostCharacter((CHARACTERGUID)_Player)
		AND
		GetTextEventParamInteger(1,0)
		AND
		DB_AnimTestLoopingAnimation(_Player,_AnimName)
		THEN
		NOT DB_AnimTestLoopingAnimation(_Player,_AnimName);
		
		// oe animtest animation_name 
		IF
		TextEventSet("AnimTest")
		AND
		CharacterGetHostCharacter((CHARACTERGUID)_Player)
		AND
		GetTextEventParamString(1,_AnimName)
		AND
		NOT GetTextEventParamInteger(2,_)
		THEN
		PlayAnimation(_Player,_AnimName);
		
		IF
		TextEventSet("AnimTest")
		AND
		CharacterGetHostCharacter((CHARACTERGUID)_Player)
		AND
		GetTextEventParamString(1,_AnimName)
		AND
		GetTextEventParamInteger(2,1)
		THEN
		PlayAnimation(_Player,_AnimName);
		
		
		IF
		TextEventSet("AnimTest")
		AND
		CharacterGetHostCharacter((CHARACTERGUID)_Player)
		AND
		GetTextEventParamString(1,_AnimName)
		AND
		GetTextEventParamInteger(2,-1)
		THEN
		PlayAnimation(_Player,_AnimName,"AnimTest_PlayLoopingAnim");
		DB_AnimTestLoopingAnimation(_Player,_AnimName);
		
		IF
		StoryEvent((CHARACTERGUID)_Player,"AnimTest_PlayLoopingAnim")
		AND
		DB_AnimTestLoopingAnimation(_Player,_AnimName)
		THEN
		PlayAnimation(_Player,_AnimName,"AnimTest_PlayLoopingAnim");
		
		
		IF
		TextEventSet("AnimTest")
		AND
		CharacterGetHostCharacter((CHARACTERGUID)_Player)
		AND
		GetTextEventParamString(1,_AnimName)
		AND
		GetTextEventParamInteger(2,0)
		THEN
		CharacterPurgeQueue(_Player);
		
		
		
		IF
		TextEventSet("AnimTest")
		AND
		CharacterGetHostCharacter((CHARACTERGUID)_Player)
		AND
		GetTextEventParamString(1,_AnimName)
		AND
		GetTextEventParamInteger(2,0)
		AND
		DB_AnimTestLoopingAnimation(_Player,_AnimName)
		THEN
		NOT DB_AnimTestLoopingAnimation(_Player,_AnimName);
		
		
		//END_REGION
		
		//REGION FX testing
		
		// oe animtest animation_name 
		//REGION OneShot
		
		IF
		TextEventSet("FxTest")
		AND
		CharacterGetHostCharacter((CHARACTERGUID)_Player)
		AND
		GetTextEventParamString(1,_FxName)
		AND
		GetTextEventParamInteger(2,1)
		THEN
		PlayEffect(_Player,_FxName);
		//END_REGION
		
		//REGION Looping FX
		IF
		TextEventSet("FxTest")
		AND
		CharacterGetHostCharacter((CHARACTERGUID)_Player)
		AND
		GetTextEventParamString(1,_FxName)
		AND
		GetTextEventParamInteger(2,-1)
		THEN
		PROC_LoopEffect(_FxName,_Player,"FxTest","__ANY__","Dummy_FX");
		
		IF
		TextEventSet("FxTest")
		AND
		CharacterGetHostCharacter((CHARACTERGUID)_Player)
		AND
		GetTextEventParamString(1,_FxName)
		AND
		GetTextEventParamString(2,_BoneName)
		AND
		GetTextEventParamInteger(3,-1)
		THEN
		PROC_LoopEffect(_FxName,_Player,"FxTest","__ANY__",_BoneName);
		
		/////// 0 or STOP to stop looping
		
		IF
		TextEventSet("FxTest")
		AND
		CharacterGetHostCharacter((CHARACTERGUID)_Player)
		AND
		GetTextEventParamString(1,"Stop")
		THEN
		PROC_StopLoopEffect(_Player,"FxTest");
		
		IF
		TextEventSet("FxTestStop")
		AND
		CharacterGetHostCharacter((CHARACTERGUID)_Player)
		THEN
		PROC_StopLoopEffect(_Player,"FxTest");
		
		//END_REGION
		
		//END_REGION
		
		//REGION AddTag OE
		
		IF
		TextEventSet("AddTag")
		AND
		CharacterGetHostCharacter((CHARACTERGUID)_Player)
		AND
		GetTextEventParamString(1,_TagName)
		THEN
		SetTag(_Player,_TagName);
		DebugText(_Player,_TagName);
		
		//END_REGION
		
		//REGION DrawWeaponforXTime
		PROC
		proc_DrawWeaponforXTime((CHARACTERGUID)_NPC,(INTEGER)_Time)
		THEN
		CharacterSetFightMode(_NPC,1,0);
		ProcObjectTimer(_NPC,"GLO_DrawWeaponsForXTime",_Time);
		
		PROC
		ProcObjectTimerFinished(_NPC,"GLO_DrawWeaponsForXTime")
		AND
		CharacterIsInCombat((CHARACTERGUID)_NPC,0)
		THEN
		CharacterSetFightMode(_NPC,0,0);
		//END_REGION
		
		//REGION Conditional Object Flag Setter
		PROC
		Proc_SetConditionalObjectFlag((GUIDSTRING)_Object,(STRING)_Flag,(INTEGER)_Condition)
		AND
		_Condition == 0
		THEN
		ObjectClearFlag(_Object,_Flag,0);
		
		PROC
		Proc_SetConditionalObjectFlag((GUIDSTRING)_Object,(STRING)_Flag,(INTEGER)_Condition)
		AND
		_Condition != 0
		THEN
		ObjectSetFlag(_Object,_Flag,0);
		
		QRY
		QRY_IsEmptyDB((STRING)_DB,(INTEGER)_Size)
		AND
		SysCount(_DB,_Size,0)
		THEN
		DB_NOOP(1);
		
		QRY
		QRY_IsInRange((GUIDSTRING)_Source,(GUIDSTRING)_Target,(REAL)_Range)
		AND
		GetDistanceTo(_Source,_Target,_Dist)
		AND
		_Dist <= _Range
		THEN
		DB_NOOP(1);
		
		QRY
		Query_CharacterIsAliveAndNotInCombat((CHARACTERGUID)_Char)
		AND
		CharacterIsDead(_Char,0)
		AND
		CharacterIsInCombat(_Char,0)
		THEN
		DB_NOOP(1);
		
		//END_REGION
		
		//REGION Attribute checks
		QRY
		QRY_CheckPlayerStat((CHARACTERGUID)_Player,(STRING)_Stat,(INTEGER)_Value)
		AND
		CharacterGetAttribute(_Player,_Stat,_PlayerStat)
		AND
		_PlayerStat >= _Value
		THEN
		DB_NOOP(1);
		
		IF
		DB_GLO_Attribute_Check_AgainstSpeaker((STRING)_Dialog,(INTEGER)_Index,(STRING)_Attribute,(STRING)_Difficulty,(INTEGER)_Source,(INTEGER)_Target)
		THEN
		PROC_Define_GLO_Attribute_Check_Internal(_Dialog,_Index,_Attribute,_Difficulty,_Source,_Target,0);
		
		IF
		DB_GLO_Attribute_Check_AgainstLevel((STRING)_Dialog,(INTEGER)_Index,(STRING)_Attribute,(STRING)_Difficulty,(INTEGER)_Source,(INTEGER)_Level)
		THEN
		PROC_Define_GLO_Attribute_Check_Internal(_Dialog,_Index,_Attribute,_Difficulty,_Source,1,_Level);
		
		PROC
		PROC_Define_GLO_Attribute_Check_Internal((STRING)_Dialog,(INTEGER)_Index,(STRING)_Attribute,(STRING)_Difficulty,(INTEGER)_Source,(INTEGER)_Target,(INTEGER)_Level)
		AND
		DB_GLO_Attribute_Check_Internal(_Dialog,_Index,_AnyAttribute,_AnyDifficulty,_AnySource,_AnyTarget,_AnyLevel)
		THEN
		NOT DB_GLO_Attribute_Check_Internal(_Dialog,_Index,_AnyAttribute,_AnyDifficulty,_AnySource,_AnyTarget,_AnyLevel);
		
		PROC
		PROC_Define_GLO_Attribute_Check_Internal((STRING)_Dialog,(INTEGER)_Index,(STRING)_Attribute,(STRING)_Difficulty,(INTEGER)_Source,(INTEGER)_Target,(INTEGER)_Level)
		THEN
		DB_GLO_Attribute_Check_Internal(_Dialog,_Index,_Attribute,_Difficulty,_Source,_Target,_Level);
		
		PROC
		Proc_DialogFlagSetup(_Dialog,_Speaker1)
		AND
		DB_GLO_Attribute_Check_Internal(_Dialog,_,_,_,_,_,_)
		THEN
		PROC_GLO_Attribute_Check_Setup(_Dialog);
		
		PROC
		Proc_DialogFlagSetup(_Dialog,_Speaker1,_Speaker2)
		AND
		DB_GLO_Attribute_Check_Internal(_Dialog,_,_,_,_,_,_)
		THEN
		PROC_GLO_Attribute_Check_Setup(_Dialog);
		
		PROC
		Proc_DialogFlagSetup(_Dialog,_Speaker1,_Speaker2,_Speaker3)
		AND
		DB_GLO_Attribute_Check_Internal(_Dialog,_,_,_,_,_,_)
		THEN
		PROC_GLO_Attribute_Check_Setup(_Dialog);
		
		PROC
		Proc_DialogFlagSetup(_Dialog,_Speaker1,_Speaker2,_Speaker3,_Speaker4)
		AND
		DB_GLO_Attribute_Check_Internal(_Dialog,_,_,_,_,_,_)
		THEN
		PROC_GLO_Attribute_Check_Setup(_Dialog);
		
		PROC
		Proc_DialogFlagSetup(_Dialog,_Speaker1,_Speaker2,_Speaker3,_Speaker4,_Speaker5)
		AND
		DB_GLO_Attribute_Check_Internal(_Dialog,_,_,_,_,_,_)
		THEN
		PROC_GLO_Attribute_Check_Setup(_Dialog);
		
		PROC
		Proc_DialogFlagSetup(_Dialog,_Speaker1,_Speaker2,_Speaker3,_Speaker4,_Speaker5,_Speaker6)
		AND
		DB_GLO_Attribute_Check_Internal(_Dialog,_,_,_,_,_,_)
		THEN
		PROC_GLO_Attribute_Check_Setup(_Dialog);
		
		PROC
		PROC_GLO_Attribute_Check_Setup((STRING)_Dialog)
		AND
		DB_GLO_Attribute_Check_Internal(_Dialog,_Index,_Attribute,_Difficulty,_Source,_Target,_Level)
		AND
		DB_GLO_AttributeCheck_Var(_Index,"Difficulty",_DifficultyVar)
		AND
		DB_GLO_AttributeCheck_Var(_Index,"LevelOverride",_LevelOverrideVar)
		AND
		DB_GLO_AttributeCheck_Var(_Index,"Name",_NameVar)
		AND
		DB_GLO_AttributeCheck_Var(_Index,"Source",_SourceVar)
		AND
		DB_GLO_AttributeCheck_Var(_Index,"Target",_TargetVar)
		THEN
		DialogSetVariableString(_Dialog,_DifficultyVar,_Difficulty);
		DialogSetVariableInt(_Dialog,_LevelOverrideVar,_Level);
		DialogSetVariableString(_Dialog,_NameVar,_Attribute);
		DialogSetVariableInt(_Dialog,_SourceVar,_Source);
		DialogSetVariableInt(_Dialog,_TargetVar,_Target);
		
		//END_REGION
		
		//REGION User Based Voice Bark
		
		IF
		DB_OneShotUser_VoicebarkTrigger((TRIGGERGUID)_Trigger,_)
		THEN
		ProcTriggerRegisterForPlayers(_Trigger);
		
		IF
		CharacterEnteredTrigger(_Player,_Trigger)
		AND
		DB_OneShotUser_VoicebarkTrigger((TRIGGERGUID)_Trigger,(STRING)_Bark)
		AND
		StringConcatenate("Commented_",_Bark,_Flag)
		AND
		UserGetFlag(_Player,_Flag,0)
		THEN
		UserSetFlag(_Player,_Flag);
		StartVoiceBark(_Bark,_Player);
		
		//END_REGION
		
		//REGION 
		IF
		CharacterUsedItem(_Player, _Item)
		AND
		DB_VBItem(_Item, _)
		AND
		DB_IsPlayer(_Player)
		AND
		DB_CombatCharacters(_Player, _)
		AND
		NOT DB_IgnoreCombatItems(_Item)
		THEN
		Proc_StartDialog(1,"GLO_AD_CannotUseNow", _Player);
		
		IF
		CharacterUsedItem(_Player, _Item)
		AND
		DB_VBItem((ITEMGUID)_Item, (STRING)_VB)
		AND
		DB_IsPlayer(_Player)
		AND
		NOT DB_CombatCharacters(_Player, _)
		THEN
		StartVoiceBark(_VB, _Player);
		
		IF
		CharacterUsedItem(_Player, _Item)
		AND
		DB_VBItem(_Item, _VB)
		AND
		DB_IsPlayer(_Player)
		AND
		DB_CombatCharacters(_Player, _)
		AND
		DB_IgnoreCombatItems(_Item)
		THEN
		StartVoiceBark(_VB, _Player);
		//END_REGION
		
		PROC
		Proc_TeleportSmoke((GUIDSTRING)_Object)
		AND
		GetPosition(_Object,_X,_Y,_Z)
		THEN
		PlayEffectAtPosition("RS3_FX_GP_ScriptedEvent_Teleport_GenericSmoke_01",_X,_Y,_Z);
		
		
		//REGION
		IF
		DB_HideEquippedWeapon((CHARACTERGUID)_Char)
		AND
		CharacterGetEquippedItem(_Char,"Weapon",(ITEMGUID)_Weapon)
		THEN
		CharacterUnequipItem(_Char,_Weapon);
		DB_HiddenEquippedWeapon(_Char,_Weapon);
		
		IF
		DB_HideEquippedShield((CHARACTERGUID)_Char)
		AND
		CharacterGetEquippedItem(_Char,"Shield",(ITEMGUID)_Shield)
		THEN
		CharacterUnequipItem(_Char,_Shield);
		DB_HideEquippedShield(_Char,_Shield);
		
		PROC
		Proc_EquipHiddenWeapon((CHARACTERGUID)_Char)
		AND
		DB_HiddenEquippedWeapon(_Char,_Weapon)
		THEN
		CharacterEquipItem(_Char,_Weapon);
		NOT DB_HiddenEquippedWeapon(_Char,_Weapon);
		
		PROC
		Proc_EquipHiddenShield((CHARACTERGUID)_Char)
		AND
		DB_HideEquippedShield(_Char,_Shield)
		THEN
		CharacterEquipItem(_Char,_Shield);
		NOT DB_HideEquippedShield(_Char,_Shield);
		
		//END_REGION
		
		//REGION Combat Cutscene - control whos turn it is
		
		IF
		DB_CombatCutscene_PrioritizedObject(_PrioritiedObject)
		THEN
		JumpToTurn(_PrioritiedObject);
		
		PROC
		Proc_CombatCutscene_PrioritizedObject_Purge()
		AND
		DB_CombatCutscene_PrioritizedObject(_PrioritiedObject)
		THEN
		NOT DB_CombatCutscene_PrioritizedObject(_PrioritiedObject);
		
		IF
		DB_CombatCutscene_PrioritizedObject(_PrioritiedObject)
		AND
		DB_CombatCutscene_PrioritizedObject(_OtherObject)
		AND
		_OtherObject != _PrioritiedObject
		THEN
		NOT DB_CombatCutscene_PrioritizedObject(_OtherObject);
		
		IF
		ObjectTurnStarted((CHARACTERGUID)_Combatant)
		AND
		DB_CombatCutscene_PrioritizedObject(_PrioritiedObject)
		AND
		ObjectIsCharacter(_PrioritiedObject,1)
		AND
		DB_CombatCharacters(_Combatant,_Id)
		AND
		_Combatant != _PrioritiedObject
		AND
		DB_CombatCharacters(_PrioritiedObject,_PId)
		AND
		_Id == _PId
		THEN
		JumpToTurn(_PrioritiedObject);
		
		IF
		CharacterWentOnStage(_PrioritiedObject,0) 
		AND
		ObjectIsCharacter(_PrioritiedObject,1)
		AND
		DB_CombatCutscene_PrioritizedObject(_PrioritiedObject)
		THEN
		NOT DB_CombatCutscene_PrioritizedObject(_PrioritiedObject);
		
		//END_REGION
		
		//REGION Remove Weapons
		
		PROC
		Proc_RemoveWeapons((CHARACTERGUID)_Char)
		AND
		CharacterGetEquippedItem(_Char,"Weapon",(ITEMGUID)_Weapon)
		THEN
		ItemRemove(_Weapon);
		
		PROC
		Proc_RemoveWeapons((CHARACTERGUID)_Char)
		AND
		CharacterGetEquippedItem(_Char,"Shield",(ITEMGUID)_Shield)
		THEN
		ItemRemove(_Shield);
		
		
		
		//END_REGION
		
		
		//REGION //Killed Event - User Level
		IF
		CharacterKilledBy(_Defender,_AttackerOwner,_Attacker)
		AND
		DB_IsPlayer(_AttackerOwner)
		AND
		DB_KilledEvent(_Defender, (STRING)_Event) 
		THEN
		UserSetFlag(_AttackerOwner,_Event,0);
		
		IF
		CharacterDying(_Killed)
		AND
		DB_KilledEvent(_Killed, _Event)
		AND
		DB_CombatCharacters(_Killed, _ID)
		AND
		DB_IsPlayer(_Killer)
		AND
		DB_CombatCharacters(_Killer, _ID)
		AND
		QRY_GLO_KilledEvent_WasEnemy((CHARACTERGUID)_Killed,(CHARACTERGUID)_Killer, _ID)
		THEN
		UserSetFlag(_Killer, _Event, 0);
		
		QRY
		QRY_GLO_KilledEvent_WasEnemy((CHARACTERGUID)_Killed, (CHARACTERGUID)_Killer, (INTEGER)_ID)
		AND
		DB_KilledEvent_HostileToTarget(_Killer, _Killed, _ID)
		THEN
		DB_NOOP(0);
		
		QRY
		QRY_GLO_KilledEvent_WasEnemy((CHARACTERGUID)_Killed, (CHARACTERGUID)_Killer, (INTEGER)_ID)
		AND
		CharacterIsEnemy(_Killed, _Killer, 1)
		THEN
		DB_NOOP(0);
		
		IF
		ObjectEnteredCombat((CHARACTERGUID)_NPC, _ID)
		AND
		DB_KilledEvent(_NPC, _)
		AND
		DB_IsPlayer(_Player)
		AND
		DB_CombatCharacters(_Player, _ID)
		AND
		CharacterIsEnemy(_Player, _NPC, 1)
		THEN
		DB_KilledEvent_HostileToTarget((CHARACTERGUID)_Player, (CHARACTERGUID)_NPC, _ID);
		
		IF
		ObjectEnteredCombat((CHARACTERGUID)_Player, _ID)
		AND
		DB_IsPlayer(_Player)
		AND
		DB_KilledEvent(_NPC, _)
		AND
		DB_CombatCharacters(_Player, _ID)
		AND
		CharacterIsEnemy(_Player,(CHARACTERGUID)_NPC,1)
		THEN
		DB_KilledEvent_HostileToTarget((CHARACTERGUID)_Player, (CHARACTERGUID)_NPC, _ID);
		
		IF
		CombatEnded(_ID)
		AND
		DB_KilledEvent_HostileToTarget(_Player, _NPC, _ID)
		THEN
		NOT DB_KilledEvent_HostileToTarget(_Player, _NPC, _ID);
		//END_REGION
		
		//REGION //Killed Event - Party Level
		IF
		CharacterKilledBy(_Defender,_AttackerOwner,_Attacker)
		AND
		DB_IsPlayer(_AttackerOwner)
		AND
		DB_KilledPartyEvent(_Defender, (STRING)_Event) 
		THEN
		PartySetFlag(_AttackerOwner,_Event,0);
		
		IF
		CharacterDying(_Killed)
		AND
		DB_KilledPartyEvent(_Killed, _Event)
		AND
		DB_CombatCharacters(_Killed, _ID)
		AND
		DB_IsPlayer(_Killer)
		AND
		DB_CombatCharacters(_Killer, _ID)
		AND
		QRY_GLO_KilledEvent_WasEnemy((CHARACTERGUID)_Killed,(CHARACTERGUID)_Killer, _ID)
		THEN
		PartySetFlag(_Killer, _Event, 0);
		//END_REGION
		
		//REGION 
		//This will add characters within a trigger to the dialog
		//first int, if 1, will also add character when the enter the trigger after the dialog started
		
		IF
		DialogStarted(_Dialog,_Id)
		AND
		DB_AddCharactersInTriggerToDialog((STRING)_Dialog,(TRIGGERGUID)_Trigger,(INTEGER)_)
		THEN
		DB_AddCharactersInTriggerToDialog_ID(_Dialog,_Id);
		
		IF
		DialogStarted(_Dialog,_Id)
		AND
		DB_AddCharactersInTriggerToDialog(_Dialog,_Trigger,_)
		AND
		DB_InRegion(_Char,_Trigger)
		AND
		DB_IsPlayer(_Char)
		AND
		QRY_SpeakerIsAvailable(_Char)
		AND
		DB_AddCharactersInTriggerToDialog_ID(_Dialog,_Id)
		THEN
		DialogAddActor(_Id,_Char);
		
		IF
		CharacterEnteredTrigger(_Char,_Trigger)
		AND
		DB_AddCharactersInTriggerToDialog(_Dialog,_Trigger,1)
		AND
		DB_IsPlayer(_Char)
		AND
		DB_AddCharactersInTriggerToDialog_ID(_Dialog,_Id)
		THEN
		DialogAddActor(_Id,_Char);
		
		IF
		DialogEnded(_Dialog,_Id)
		AND
		DB_AddCharactersInTriggerToDialog_ID(_Dialog,_Id)
		THEN
		NOT DB_AddCharactersInTriggerToDialog_ID(_Dialog,_Id);
		//END_REGION
		
		//REGION Replace one-time use dialog flag into a proc call (for flags used to trigger actions)
		PROC
		Proc_OneTimeEventFlag((STRING)_Flag)
		THEN
		DB_NOOP(1);
		
		PROC
		Proc_OneTimeEventFlag((GUIDSTRING)_Object,(STRING)_Flag)
		THEN
		DB_NOOP(1);
		
		PROC
		Proc_OneTimeEventFlag((GUIDSTRING)_Object,(STRING)_Flag,(INTEGER)_DialogInst)
		THEN
		DB_NOOP(1);
		
		IF
		ObjectFlagSet(_Flag,_Object,_DlgInst)
		AND
		DB_OneTimeEventFlag(_Flag)
		THEN
		ObjectClearFlag(_Object,_Flag);
		Proc_OneTimeEventFlag(_Object,_Flag);
		Proc_OneTimeEventFlag(_Object,_Flag,_DlgInst);
		
		IF
		GlobalFlagSet(_Flag)
		AND
		DB_OneTimeEventFlag(_Flag)
		THEN
		GlobalClearFlag(_Flag);
		Proc_OneTimeEventFlag(_Flag);
		//END_REGION
		
		//REGION Generic Leave Through Portal (_Poof Variation)
		
		PROC
		Proc_CreatePortalAndLeave((CHARACTERGUID)_Char,(STRING)_Event)
		AND
		GetPosition(_Char,_X,_Y,_Z)
		AND
		RealSum(_Y,1.25,_Y2)
		AND
		RealSum(_X,2.0,_X2)
		AND
		CreateItemTemplateAtPosition("Helper_Invisible_A_835c266c-2619-41a6-9591-50fc937bf97d",_X2,_Y2,_Z,(ITEMGUID)_Portal)
		THEN
		DB_GEN_CreatePortalAndLeave(_Char,_Portal,_Event);
		CharacterLookAt(_Char,_Portal);
		PlayAnimation(_Char,"cast_target_cast","GEN_CreatePortalAndLeave_CreatePortal");
		PROC_LoopEffect("RS3_FX_Skills_Voodoo_Cast_Hand_01",_Char,"GEN_CreatePortalAndLeave_Fx","__ANY__","Dummy_R_HandFX");
		PROC_LoopEffect("RS3_FX_GP_ScriptedEvent_DarkOrb_Summoning_01",_Char,"GEN_CreatePortalAndLeave_Fx","__ANY__","");
		ProcObjectTimer(_Char,"GEN_CreatePortalAndLeave_CreatePortal_Timer",1800);
		
		PROC
		ProcObjectTimerFinished((CHARACTERGUID)_Char,"GEN_CreatePortalAndLeave_CreatePortal_Timer")
		AND
		GetRotation(_Char,_,_Yr,_)
		AND
		DB_GEN_CreatePortalAndLeave(_Char,(ITEMGUID)_Portal,_Event)
		THEN
		ItemRotateToAngleY(_Portal,_Yr,1000.0);
		PROC_LoopEffect("RS3_FX_GP_ScriptedEvent_Portal_01",_Portal,"GEN_CreatePortalAndLeave","__ANY__","");
		
		
		IF
		StoryEvent((CHARACTERGUID)_Char,"GEN_CreatePortalAndLeave_CreatePortal")
		AND
		DB_GEN_CreatePortalAndLeave(_Char,_Portal,_Event)
		THEN
		PROC_StopLoopEffect(_Char,"GEN_CreatePortalAndLeave_Fx");
		ProcObjectTimer(_Char,"GEN_CreatePortalAndLeave_MoveToDelay",800);
		
		PROC
		ProcObjectTimerFinished((CHARACTERGUID)_Char,"GEN_CreatePortalAndLeave_MoveToDelay")
		AND
		DB_GEN_CreatePortalAndLeave(_Char,(ITEMGUID)_Portal,_Event)
		THEN
		CharacterMoveTo(_Char,_Portal,0,"GEN_CreatePortalAndLeave_Offstage",0);
		
		IF
		StoryEvent((CHARACTERGUID)_Char,"GEN_CreatePortalAndLeave_Offstage")
		AND
		DB_GEN_CreatePortalAndLeave(_Char,(ITEMGUID)_Portal,_Event)
		THEN
		ProcObjectTimer(_Portal,"GEN_CreatePortalAndLeave_Offstage_PortalRemove",3500);
		PROC_StopLoopEffect(_Portal,"GEN_CreatePortalAndLeave");
		SetStoryEvent(_Char,_Event);
		NOT DB_GEN_CreatePortalAndLeave(_Char,_Portal,_Event);
		
		PROC
		ProcObjectTimerFinished((ITEMGUID)_Portal,"GEN_CreatePortalAndLeave_Offstage_PortalRemove")
		THEN
		ItemRemove(_Portal);
		
		
		IF
		TextEventSet("GEN_CreatePortalAndLeave_Offstage")
		AND
		CharacterGetHostCharacter((CHARACTERGUID)_Player)
		THEN
		Proc_CreatePortalAndLeave(_Player,"");
		
		//END_REGION
		 
		//REGION StartDialog With Visible Tagged Player 
		
		PROC
		PROC_StartDialog_WithVisibleTag((CHARACTERGUID)_NPC,(CHARACTERGUID)_Player,(STRING)_Dialog,(STRING)_MainTag,(STRING)_FallBackTag,(INTEGER)_AddOtherPlayersToDialog)
		AND
		NOT DB_PROC_StartDialogWithVisibleTag(1)
		AND
		IsTagged(_Player,_MainTag,1)
		AND
		QRY_SpeakerIsAvailableAndInDialogRange(_NPC,_Player)
		THEN
		Proc_StartDialog(0,_Dialog,_NPC,_Player);
		DB_PROC_StartDialogWithVisibleTag(1);
		
		PROC
		PROC_StartDialog_WithVisibleTag((CHARACTERGUID)_NPC,(CHARACTERGUID)_Player,(STRING)_Dialog,(STRING)_MainTag,(STRING)_FallBackTag,(INTEGER)_AddOtherPlayersToDialog)
		AND
		NOT DB_PROC_StartDialogWithVisibleTag(1)
		AND
		IsTagged(_Player,_MainTag,0)
		AND
		DB_IsPlayer(_OtherPlayers)
		AND
		IsTagged(_OtherPlayers,_MainTag,1)
		AND
		QRY_SpeakerIsAvailableAndInDialogRange(_NPC,_OtherPlayers)
		THEN
		Proc_StartDialog(0,_Dialog,_NPC,_OtherPlayers);
		DB_PROC_StartDialogWithVisibleTag(1);
		
		PROC
		PROC_StartDialog_WithVisibleTag((CHARACTERGUID)_NPC,(CHARACTERGUID)_Player,(STRING)_Dialog,(STRING)_MainTag,(STRING)_FallBackTag,(INTEGER)_AddOtherPlayersToDialog)
		AND
		NOT DB_PROC_StartDialogWithVisibleTag(1)
		AND
		IsTagged(_Player,_FallBackTag,1)
		AND
		QRY_SpeakerIsAvailableAndInDialogRange(_NPC,_Player)
		THEN
		Proc_StartDialog(0,_Dialog,_NPC,_Player);
		DB_PROC_StartDialogWithVisibleTag(1);
		
		PROC
		PROC_StartDialog_WithVisibleTag((CHARACTERGUID)_NPC,(CHARACTERGUID)_Player,(STRING)_Dialog,(STRING)_MainTag,(STRING)_FallBackTag,(INTEGER)_AddOtherPlayersToDialog)
		AND
		NOT DB_PROC_StartDialogWithVisibleTag(1)
		AND
		IsTagged(_Player,_FallBackTag,0)
		AND
		DB_IsPlayer(_OtherPlayers)
		AND
		IsTagged(_OtherPlayers,_FallBackTag,1)
		AND
		QRY_SpeakerIsAvailableAndInDialogRange(_NPC,_OtherPlayers)
		THEN
		Proc_StartDialog(0,_Dialog,_NPC,_OtherPlayers);
		DB_PROC_StartDialogWithVisibleTag(1);
		
		PROC
		PROC_StartDialog_WithVisibleTag((CHARACTERGUID)_NPC,(CHARACTERGUID)_Player,(STRING)_Dialog,(STRING)_MainTag,(STRING)_FallBackTag,(INTEGER)_AddOtherPlayersToDialog)
		AND
		NOT DB_PROC_StartDialogWithVisibleTag(1)
		AND
		QRY_SpeakerIsAvailableAndInDialogRange(_NPC,_Player)
		THEN
		Proc_StartDialog(0,_Dialog,_NPC,_Player);
		DB_PROC_StartDialogWithVisibleTag(1);
		
		PROC
		PROC_StartDialog_WithVisibleTag((CHARACTERGUID)_NPC,(CHARACTERGUID)_Player,(STRING)_Dialog,(STRING)_MainTag,(STRING)_FallBackTag,1)
		AND
		DB_PROC_StartDialogWithVisibleTag(1)
		THEN
		DB_PROC_StartDialog_WithVisibleTag_AddPlayers(_NPC,_Player,_Dialog);
		
		PROC
		PROC_StartDialog_WithVisibleTag((CHARACTERGUID)_NPC,(CHARACTERGUID)_Player,(STRING)_Dialog,(STRING)_MainTag,(STRING)_FallBackTag,(INTEGER)_AddOtherPlayersToDialog)
		AND
		DB_PROC_StartDialogWithVisibleTag(1)
		THEN
		NOT DB_PROC_StartDialogWithVisibleTag(1);
		
		IF
		DialogStarted(_Dialog,_ID)
		AND
		DB_PROC_StartDialog_WithVisibleTag_AddPlayers(_NPC,_Player,_Dialog)
		AND
		DB_IsPlayer(_Players)
		AND
		NOT DB_DialogPlayers(_ID,_Players,_)
		AND
		CharacterCanSee(_NPC,_Players,1)
		AND
		QRY_SpeakerIsAvailable(_Players)
		THEN
		DialogAddActor(_ID,_Players);
		
		
		IF
		DialogStarted(_Dialog,_ID)
		AND
		DB_PROC_StartDialog_WithVisibleTag_AddPlayers(_NPC,_Player,_Dialog)
		THEN
		NOT DB_PROC_StartDialog_WithVisibleTag_AddPlayers(_NPC,_Player,_Dialog);
		
		//END_REGION
		
		//REGION Repair / Loremaster traders
		
		IF
		DB_LoremasterTrader((CHARACTERGUID)_Trader,(INTEGER)_Level)
		THEN
		CharacterAddAbility(_Trader,"Loremaster",_Level);
		
		IF
		DB_RepairTrader((CHARACTERGUID)_Trader,(INTEGER)_Level)
		THEN
		CharacterAddAbility(_Trader,"Repair",_Level);
		
		//END_REGION
		
		//REGION Safe teleport for characters: teleport and flush/stop existing commands
		PROC
		PROC_Helper_SafeTeleportTo((CHARACTERGUID)_Char,(GUIDSTRING)_Dest)
		THEN
		PROC_Helper_SafeTeleportTo(_Char,_Dest,"",1);
		
		PROC
		PROC_Helper_SafeTeleportTo((CHARACTERGUID)_Char,(GUIDSTRING)_Dest,(STRING)_Event,(INTEGER)_TeleportLinkedCharacters)
		THEN
		TeleportTo(_Char,_Dest,_Event,_TeleportLinkedCharacters);
		CharacterFlushQueue(_Char);
		LeaveCombat(_Char);
		SetStoryEvent(_Char,"ClearPeaceReturn");
		// Clear ongoing animations
		PlayAnimation(_Char,"");
		
		//END_REGION
		
		//REGION Teleport In/Out script helpers
		
		IF
		StoryEvent((CHARACTERGUID)_Char,"GEN_Teleport_In")
		THEN
		SetOnStage(_Char,1);
		PlayAnimation(_Char,"Teleport_In_01");
		
		
		IF
		StoryEvent((CHARACTERGUID)_Char,"GEN_Teleport_Out")
		THEN
		PlayAnimation(_Char,"Teleport_Out_01","GEN_GoOffStage");
		
		
		//END_REGION
		
		
		
		//REGION Sign function
		QRY
		QRY_IntegerSign((INTEGER)_Value)
		AND
		DB_IntegerSign(_Result)
		THEN
		NOT DB_IntegerSign(_Result);
		
		QRY
		QRY_IntegerSign((INTEGER)_Value)
		AND
		_Value < 0
		THEN
		DB_IntegerSign(-1);
		
		QRY
		QRY_IntegerSign((INTEGER)_Value)
		AND
		_Value == 0
		THEN
		DB_IntegerSign(0);
		
		QRY
		QRY_IntegerSign((INTEGER)_Value)
		AND
		_Value > 0
		THEN
		DB_IntegerSign(0);
		//END_REGION
		
		//REGION Angle normalisation
		QRY
		QRY_NormaliseAngle((INTEGER)_Angle)
		AND
		DB_NormaliseAngle_Result(_Result)
		THEN
		NOT DB_NormaliseAngle_Result(_Result);
		
		QRY
		QRY_NormaliseAngle((INTEGER)_Angle)
		AND
		_Angle < 0
		AND
		IntegerSum(_Angle, 360, _NormalisedAngle)
		THEN
		DB_NormaliseAngle_Result(_NormalisedAngle);
		
		QRY
		QRY_NormaliseAngle((INTEGER)_Angle)
		AND
		_Angle >= 0
		AND
		IntegerModulo(_Angle, 360, _NormalisedAngle)
		THEN
		DB_NormaliseAngle_Result(_NormalisedAngle);
		//END_REGION
		
		//REGION Clear a party flag on all players and potential companions
		//NOTE: This call will not work for characters that are not currently loaded,
		//e.g. local characters currently in another level that you could re-recruit.
		IF
		CharacterJoinedParty(_Character)
		THEN
		DB_JoinedParty(_Character);
		
		IF
		CharacterDied(_Character)
		AND
		DB_JoinedParty(_Character)
		AND
		CharacterIsSummon(_Character, 1)
		THEN
		NOT DB_JoinedParty(_Character);
		
		PROC
		Proc_PurgeLevelPartyFlag((STRING)_Flagname)
		AND
		DB_JoinedParty(_Character)
		AND
		ObjectExists(_Character, 1)
		AND
		DB_IsPlayer(_Character)
		THEN
		PartyClearFlag(_Character,_Flagname,0);
		
		PROC
		Proc_PurgeLevelPartyFlag((STRING)_Flagname)
		AND
		DB_JoinedParty(_Character)
		AND
		ObjectExists(_Character, 1)
		AND
		NOT DB_IsPlayer(_Character)
		THEN
		ObjectClearFlag(_Character,_Flagname,0);
		//END_REGION
		
		
		//REGION Generic Remove From Dialog
		
		IF
		ObjectFlagSet("GEN_RemoveFromDialog",_Char,_Id)
		AND
		DialogRemoveActorFromDialog(_Id,_Char,1)
		THEN
		DB_NOOP(1);
		
		//END_REGION
		
		//REGION Resurrection Idol
		IF
		CharacterDied(_Player)
		AND
		DB_IsPlayer(_Player)
		AND
		IsTagged(_Player,"BLOCK_RESURRECTION",0)
		AND
		ItemTemplateIsInCharacterInventory(_Player,"Quest_Resurrection_Idol_6b70e6e1-855e-4295-b79b-d87ebd6bd4af",_Amount)
		AND
		_Amount > 0
		THEN
		ProcObjectTimer(_Player,"ResurrectionIdol",1000);
		DB_ResurrectionIdol_Timer(_Player);
		
		PROC
		ProcObjectTimerFinished(_Player,"ResurrectionIdol")
		AND
		DB_ResurrectionIdol_Timer((CHARACTERGUID)_Player)
		THEN
		NOT DB_ResurrectionIdol_Timer(_Player);
		
		PROC
		ProcObjectTimerFinished(_Player,"ResurrectionIdol")
		AND
		IsTagged(_Player,"BLOCK_RESURRECTION",0)
		AND
		CharacterIsDead((CHARACTERGUID)_Player,1)
		AND
		ItemTemplateIsInCharacterInventory(_Player,"Quest_Resurrection_Idol_6b70e6e1-855e-4295-b79b-d87ebd6bd4af",_Amount)
		AND
		_Amount > 0
		AND
		GetPosition(_Player,_x,_y,_z)
		THEN
		CharacterResurrect(_Player);
		PlayEffectAtPosition("RS3_FX_GP_Combat_Resurrect_Idol_01",_x,_y,_z);
		ItemTemplateRemoveFrom("Quest_Resurrection_Idol_6b70e6e1-855e-4295-b79b-d87ebd6bd4af",_Player,1);
		ItemTemplateAddTo("Quest_Resurrection_Idol_Inert_79a029d2-57fd-4330-b41f-5deebdfe6e05",_Player,1);
		
		QRY
		QRY_CharIsAboutToResurrect((CHARACTERGUID)_Player)
		AND
		IsTagged(_Player,"BLOCK_RESURRECTION",0)
		AND
		ItemTemplateIsInCharacterInventory(_Player,"Quest_Resurrection_Idol_6b70e6e1-855e-4295-b79b-d87ebd6bd4af",_Amount)
		AND
		_Amount > 0
		THEN
		DB_NoOp(1);
		//END_REGION
		
		//REGION Clear Tag After Combat 
		
		PROC
		Proc_SetTagForCombat((CHARACTERGUID)_Char,(STRING)_Tag)
		THEN
		SetTag(_Char,_Tag);
		DB_ClearTagAfterCombat(_Char,_Tag);
		
		IF
		CombatEnded(_CombatID)
		AND
		DB_ClearTagAfterCombat(_Char,_Tag)
		AND
		IsTagged((CHARACTERGUID)_Char,_Tag,1)
		AND
		NOT DB_CombatCharacters(_Char,_)
		THEN
		NOT DB_ClearTagAfterCombat(_Char,_Tag);
		ClearTag(_Char,_Tag);
		
		IF
		ObjectLostTag((CHARACTERGUID)_Char,_Tag)
		AND
		DB_ClearTagAfterCombat(_Char,_Tag)
		THEN
		NOT DB_ClearTagAfterCombat(_Char,_Tag);
		
		//END_REGION
		
		//REGION Hidden Rveal On Iteraction
		IF
		ItemMoved(_IteractiveItem)
		AND
		DB_HiddenRevealOnInteraction(_HiddenItem,_IteractiveItem)
		THEN
		SetStoryEvent(_HiddenItem,"RevealFromStory");
		NOT DB_HiddenRevealOnInteraction(_HiddenItem,_IteractiveItem);
		
		IF
		ItemAddedToCharacter(_IteractiveItem,_Player)
		AND
		DB_HiddenRevealOnInteraction(_HiddenItem,_IteractiveItem)
		THEN
		SetStoryEvent(_HiddenItem,"RevealFromStory");
		NOT DB_HiddenRevealOnInteraction(_HiddenItem,_IteractiveItem);
		
		IF
		ItemDestroying(_IteractiveItem)
		AND
		DB_HiddenRevealOnInteraction(_HiddenItem,_IteractiveItem)
		THEN
		SetStoryEvent(_HiddenItem,"RevealFromStory");
		NOT DB_HiddenRevealOnInteraction(_HiddenItem,_IteractiveItem);
		
		IF
		StoryEvent(_HiddenItem,"StoryReveal")
		AND
		DB_HiddenRevealOnInteraction(_HiddenItem,_IteractiveItem)
		THEN
		NOT DB_HiddenRevealOnInteraction(_HiddenItem,_IteractiveItem);
		//END_REGION
		
	}
	EXIT
	{
		
	}
}
Goal(44).Title("_InitGoal");
Goal(44)
{
	INIT
	{
		
	}
	KB
	{
		PROC
		InitStory()
		THEN
		DB_StoryStarted(1);
		GoalCompleted;
		
	}
	EXIT
	{
		
	}
}
Goal(45).Title("_NPC_Stats");
Goal(45)
{
	INIT
	{
		
	}
	KB
	{
		
	}
	EXIT
	{
		
	}
}
Goal(46).Title("_PlayerAlignments");
Goal(46)
{
	INIT
	{
		
	}
	KB
	{
		PROC
		ProcFixPlayerAlignments()
		AND
		DB_IsPlayer(_Player)
		AND
		NOT DB_PlayerAlignments_BlockFix(_Player)
		AND
		IsInArena(_Player,0)
		AND
		CharacterIsPlayer(_Player,1)
		AND
		DB_IsPlayer(_OtherPlayer)
		AND
		NOT DB_PlayerAlignments_BlockFix(_OtherPlayer)
		AND
		_Player!=_OtherPlayer
		AND
		IsInArena(_OtherPlayer,0)
		AND
		CharacterIsPlayer(_OtherPlayer,1)
		AND
		CharacterGetReservedUserID(_Player,_User)
		AND
		CharacterGetReservedUserID(_OtherPlayer,_OtherUser)
		AND
		GetUserProfileID(_User,_UserProfileID)
		AND
		GetUserProfileID(_OtherUser,_OtherUserProfileID)
		THEN
		ProcSetPlayerAlignment(_Player,_OtherPlayer,_UserProfileID,_OtherUserProfileID);
		
		PROC
		ProcFixPlayerAlignments()
		AND
		DB_IsPlayer((CHARACTERGUID)_Player)
		AND
		NOT DB_PlayerAlignments_BlockFix(_Player)
		AND
		IsInArena(_Player,0)
		AND
		DB_IsPlayer((CHARACTERGUID)_OtherPlayer)
		AND
		NOT DB_PlayerAlignments_BlockFix(_OtherPlayer)
		AND
		_Player != _OtherPlayer
		AND
		IsInArena(_OtherPlayer,0)
		AND
		CharacterGetRelationToCharacter(_Player,_OtherPlayer,_Relation)
		THEN
		ProcLeavePartyIfRelationLow(_Player,_OtherPlayer,_Relation);
		
		PROC
		ProcSetPlayerAlignment((CHARACTERGUID)_Player,(CHARACTERGUID)_OtherPlayer,(STRING)_User,(STRING)_OtherUser)
		AND
		DB_UserAlign(_User,_OtherUser,_Result)
		THEN
		CharacterSetRelationIndivFactionToIndivFaction(_Player,_OtherPlayer,_Result);
		
		PROC
		ProcSetPlayerAlignment((CHARACTERGUID)_Player,(CHARACTERGUID)_OtherPlayer,(STRING)_User,(STRING)_OtherUser)
		AND
		NOT DB_UserAlign(_User,_OtherUser,_)
		AND
		CharacterIsInPartyWith(_Player,_OtherPlayer,1)	
		THEN
		CharacterSetRelationIndivFactionToIndivFaction(_Player,_OtherPlayer,100);
		
		PROC
		ProcSetPlayerAlignment((CHARACTERGUID)_Player,(CHARACTERGUID)_OtherPlayer,(STRING)_User,(STRING)_OtherUser)
		AND
		NOT DB_UserAlign(_User,_OtherUser,_)
		AND
		CharacterIsInPartyWith(_Player,_OtherPlayer,0)	
		THEN
		CharacterSetRelationIndivFactionToIndivFaction(_Player,_OtherPlayer,50);
		
		PROC
		ProcLeavePartyIfRelationLow((CHARACTERGUID)_Player,(CHARACTERGUID)_OtherPlayer,(INTEGER)_Relation)
		AND
		_Relation < 25
		AND
		CharacterIsInPartyWith(_Player,_OtherPlayer,1)
		AND
		CharacterGetReservedUserID(_Player,_UserID)
		AND
		CharacterGetReservedUserID(_OtherPlayer,_OtherUserID)
		AND
		_UserID != _OtherUserID
		THEN
		LeaveParty(_OtherUserID);
		
		/***************************************************************************************
			Fix alignments when swapping characters between users or creating new players.
		****************************************************************************************/
		
		IF
		CharacterReservedUserIDChanged(_,_,_)
		THEN
		ProcFixPlayerAlignments();
		
		IF 
		DB_IsPlayer(_)
		THEN
		ProcFixPlayerAlignments();
		
		IF 
		GlobalFlagSet("SetupUserAlignments")
		THEN
		ProcFixPlayerAlignments();
		GlobalClearFlag("SetupUserAlignments");
		
		IF
		CharacterJoinedParty(_)
		THEN
		ProcFixPlayerAlignments();
		
		/***************************************************************************************
			DB_UserAlign logic
		****************************************************************************************/
		
		IF
		GameStarted(_,_)
		THEN
		GlobalSetFlag("SetupUserAlignments");
		
		IF 
		UserDisconnected(_User,_,_UserProfileID)
		AND
		DB_UserAlign(_UserProfileID,_OtherUser,_Result)
		THEN
		NOT DB_UserAlign(_UserProfileID,_OtherUser,_Result);
		
		IF 
		UserDisconnected(_User,_,_UserProfileID)
		AND
		DB_UserAlign(_OtherUser,_UserProfileID,_Result)
		THEN
		NOT DB_UserAlign(_OtherUser,_UserProfileID,_Result);
		
		IF 
		UserMakeWar(_Source,_Target,1)
		AND
		GetUserProfileID(_Source,_SourceProfileID)
		AND
		GetUserProfileID(_Target,_TargetProfileID)
		THEN
		ProcSetUserAlign(_SourceProfileID,_TargetProfileID,0);
		ProcSetUserAlign(_TargetProfileID,_SourceProfileID,0);
		ProcFixPlayerAlignments();
		
		IF 
		UserMakeWar(_Source,_Target,0)
		AND
		GetUserProfileID(_Source,_SourceProfileID)
		AND
		GetUserProfileID(_Target,_TargetProfileID)
		THEN
		NOT DB_UserAlign(_SourceProfileID,_TargetProfileID,0);
		NOT DB_UserAlign(_TargetProfileID,_SourceProfileID,0);
		ProcFixPlayerAlignments();
		
		PROC
		ProcSetUserAlign((STRING)_SourceProfileID,(STRING)_TargetProfileID,(INTEGER)_NewResult)
		AND
		DB_UserAlign(_SourceProfileID,_TargetProfileID,_Result)
		THEN
		NOT DB_UserAlign(_SourceProfileID,_TargetProfileID,_Result);
		
		PROC
		ProcSetUserAlign((STRING)_SourceProfileID,(STRING)_TargetProfileID,(INTEGER)_NewResult)
		THEN
		DB_UserAlign(_SourceProfileID,_TargetProfileID,_NewResult);
		
		/***************************************************************************************
			DB_UserAlign Debugging
		****************************************************************************************/
		
		IF 
		TextEventSet("useralign")
		AND 
		DB_UserAlign(_User,_OtherUser,_Result)
		AND
		DB_IsPlayer(_Player)
		AND
		StringConcatenate(_User," vs ",_Res)
		AND
		StringConcatenate(_Res,_OtherUser,_Res2)
		AND
		StringConcatenate(_Res2,":  ",_Res3)
		AND
		IntegertoString(_Result,_IntStr)
		AND
		StringConcatenate(_Res3,_IntStr,_FinalResult)
		THEN
		DebugText(_Player,_FinalResult);
		
	}
	EXIT
	{
		
	}
}
Goal(47).Title("_PROC_AUDIO");
Goal(47)
{
	INIT
	{
		//MoveToTrigger Audio Events 
		DB_MoveToTrigger_Materials("STONE");
		DB_MoveToTrigger_Materials("WOOD");
		DB_MoveToTrigger_Materials("METAL");
		
		DB_CameraShakeAudioEventTrigger(800,5001);
		
		DB_DebugCameraShakerParser("500",500);
		DB_DebugCameraShakerParser("1000",1000);
		DB_DebugCameraShakerParser("3000",3000);
		DB_DebugCameraShakerParser("5000",5000);
		DB_DebugCameraShakerParser("8000",8000);
		DB_DebugCameraShakerParser("13000",13000);
		
		
		DB_DebugCameraShakerParser("2",2);
		DB_DebugCameraShakerParser("5",5);
		DB_DebugCameraShakerParser("1",1);
		DB_DebugCameraShakerParser("25",25);
		DB_DebugCameraShakerParser("60",60);
		
	}
	KB
	{
		//REGION MoveToTrigger //Audio Play Sounds according to Material
		
		PROC
		proc_ItemMoveToTrigger((ITEMGUID)_Item,(TRIGGERGUID)_Trigger,(REAL)_Speed,(REAL)_Acceleration,(INTEGER)_UseRotation)
		THEN
		ItemMoveToTrigger(_Item,_Trigger,_Speed,_Acceleration,_UseRotation);
		
		PROC
		Proc_ItemMoveToPosition((ITEMGUID)_Item,(REAL)_X,(REAL)_Y,(REAL)_Z,(REAL)_Speed,(REAL)_Acceleration)
		THEN
		ItemMoveToPosition(_Item,_X,_Y,_Z,_Speed,_Acceleration);
		
		PROC
		Proc_ItemMoveToPosition((ITEMGUID)_Item,(REAL)_PlusX,(REAL)_PlusY,(REAL)_PlusZ,(REAL)_Speed,(REAL)_Acceleration)
		AND
		NOT DB_MovingItem(_Item,_)
		AND
		DB_MoveToTrigger_Materials(_Tag)
		AND
		IsTagged(_Item,_Tag,1)
		AND
		StringConcatenate("Items_Puzzles_MovingObjects_",_Tag,_SoundEventPre)
		AND
		StringConcatenate(_SoundEventPre,"_Start",_SoundEvent)
		THEN
		DB_MovingItem(_Item,_Tag);
		PlaySound(_Item,_SoundEvent);
		DebugText(_Item,"PlayEvent_Move_Start");
		
		
		PROC
		proc_ItemMoveToTrigger((ITEMGUID)_Item,(TRIGGERGUID)_Trigger,(REAL)_Speed,(REAL)_Acceleration,(INTEGER)_UseRotation)
		AND
		NOT DB_MovingItem(_Item,_)
		AND
		DB_MoveToTrigger_Materials(_Tag)
		AND
		IsTagged(_Item,_Tag,1)
		AND
		StringConcatenate("Items_Puzzles_MovingObjects_",_Tag,_SoundEventPre)
		AND
		StringConcatenate(_SoundEventPre,"_Start",_SoundEvent)
		THEN
		DB_MovingItem(_Item,_Tag);
		PlaySound(_Item,_SoundEvent);
		DebugText(_Item,"PlayEvent_Move_Start");
		
		
		IF
		StoryEvent(_Item,"GEN_ItemMoved")
		AND
		NOT DB_MovingItem((ITEMGUID)_Item,_)
		AND
		DB_MoveToTrigger_Materials(_Tag)
		AND
		IsTagged(_Item,_Tag,1)
		AND
		StringConcatenate("Items_Puzzles_MovingObjects_",_Tag,_SoundEventPre)
		AND
		StringConcatenate(_SoundEventPre,"_Start",_SoundEvent)
		THEN
		DB_MovingItem(_Item,_Tag);
		PlaySound(_Item,_SoundEvent);
		DebugText(_Item,"PlayEvent_Move_Start");
		
		
		IF
		ItemMoved(_Item)
		AND
		DB_MovingItem(_Item,_Tag)
		AND
		StringConcatenate("Items_Puzzles_MovingObjects_",_Tag,_SoundEventPre)
		AND
		StringConcatenate(_SoundEventPre,"_Stop",_SoundEvent)
		THEN
		NOT DB_MovingItem(_Item,_Tag);
		PlaySound(_Item,_SoundEvent);
		DebugText(_Item,"PlayEvent_Move_END");
		//END_REGION
		
		//REGION ScreenShake Audio Logic
		
		PROC
		ProcObjectTimer(_Char,"Timer_LoopCameraShakeHelper",_Time)
		AND
		DB_CameraShakeAudioEventTrigger(_MinDuration,_)
		AND
		_Time > _MinDuration
		THEN
		PlaySound(_Char,"SE_GP_ScriptedEvent_CameraShake_Earth");
		
		PROC
		ProcObjectTimer(_Char,"Timer_LoopCameraShakeHelper",_Time)
		AND
		DB_CameraShakeAudioEventTrigger(_MinDuration,_MaxDurationToCallStop)
		AND
		_Time > _MinDuration
		AND
		_Time < _MaxDurationToCallStop
		THEN
		DB_Timer_LoopCameraShakeHelper_StopSound(_Char);
		
		PROC
		ProcObjectTimerFinished(_Char,"Timer_LoopCameraShakeHelper")
		AND
		DB_Timer_LoopCameraShakeHelper_StopSound(_Char)
		THEN
		NOT DB_Timer_LoopCameraShakeHelper_StopSound(_Char);
		PlaySound(_Char,"SE_GP_ScriptedEvent_CameraShake_Earth_Stop");
		
		
		IF
		TextEventSet("TestCameraShakeAudio")
		AND
		GetTextEventParamString(1,_TimeString)
		AND
		DB_DebugCameraShakerParser(_TimeString,_TimerInt)
		AND
		DB_IsPlayer(_Player)
		THEN
		Proc_ShakeCameraForTime((CHARACTERGUID)_Player,_TimerInt);
		
		
		IF
		TextEventSet("TestCameraShake_AroundChar_Audio")
		AND
		GetTextEventParamString(1,_TimeString)
		AND
		DB_DebugCameraShakerParser(_TimeString,_TimerInt)
		AND
		DB_IsPlayer(_Player)
		THEN
		Proc_CameraShakeAroundCharacter(_Player,_TimerInt,6.0);
		//END_REGION
		
	}
	EXIT
	{
		
	}
}
Goal(48).Title("_Sandbox");
Goal(48)
{
	INIT
	{
		DB_Dialogs(CHARACTERGUID_Sandbox_Ship_Captain_dc36935c-4452-47af-8bab-f34c48754e13, CHARACTERGUID_Sandbox_Ship_Elisabeth_Fendrish_a7b94f10-865f-4ffd-8770-fce3973366ff, "Sandbox_Quest");
		
		DB_QuestDef_State("SandboxQuest","Accept", 1);
		DB_QuestDef_State("SandboxQuest","GoBack");
		DB_QuestDef_State("SandboxQuest","Finish", -1);
		
		ProcTriggerRegisterForPlayers(TRIGGERGUID_CaveQuestTrigger_fb308de8-145b-4749-8b92-db51ea2bc019);
		
		DB_QuestDef_QuestReward("SandboxQuest","Finish","QuestUpdate_SandboxQuest_Finish");
		
	}
	KB
	{
		IF
		CharacterEnteredTrigger(_Player, TRIGGERGUID_CaveQuestTrigger_fb308de8-145b-4749-8b92-db51ea2bc019)
		THEN
		ObjectSetFlag(_Player, "QuestUpdate_SandboxQuest_GoBack");
		
	}
	EXIT
	{
		
	}
}
Goal(49).Title("_Shroud");
Goal(49)
{
	INIT
	{
		
	}
	KB
	{
		PROC
		ProcDisableShroud()
		AND
		NOT DB_ShroudDisabled(1)
		THEN
		DB_ShroudDisabled(1);
		ShroudRender(0);
		
		PROC
		ProcEnableShroud()
		AND
		DB_ShroudDisabled(1)
		THEN
		NOT DB_ShroudDisabled(1);
		ShroudRender(1);
		
	}
	EXIT
	{
		
	}
}
Goal(50).Title("_Story Npcs");
Goal(50)
{
	INIT
	{
		
	}
	KB
	{
		PROC
		SetStoryNpc((CHARACTERGUID)_Npc,(INTEGER)_State)
		THEN
		CharacterMakeStoryNpc(_Npc,_State);	
		
		PROC	
		SetStoryNpc((CHARACTERGUID)_Npc,0)
		THEN	
		NOT DB_IsStoryNpc(_Npc);
		
		PROC	
		SetStoryNpc((CHARACTERGUID)_Npc,1)
		THEN	
		DB_IsStoryNpc(_Npc);
		
		PROC	
		MakeAttackable((CHARACTERGUID)_Player,(CHARACTERGUID)_Npc)
		THEN
		SetStoryNpc(_Npc,0);
		CharacterSetTemporaryHostileRelation(_Npc,_Player);
		CharacterAddAttitudeTowardsPlayer(_Npc,_Player,-100);
			
		// Default arg:
		PROC	
		SetStoryNpc((CHARACTERGUID)_Npc)
		THEN	
		SetStoryNpc(_Npc,1);
		
		PROC	
		SetStoryNpcStatus((CHARACTERGUID)_Npc) 
		AND
		DB_IsStoryNpc(_Npc)
		THEN
		CharacterMakeStoryNpc(_Npc,1);
		
		PROC
		SetStoryNpcStatus((CHARACTERGUID)_Npc) 
		AND 
		NOT DB_IsStoryNpc(_Npc)
		THEN
		CharacterMakeStoryNpc(_Npc,0);
		
	}
	EXIT
	{
		
	}
}
Goal(51).Title("_Trade");
Goal(51)
{
	INIT
	{
		DB_DoubleAttitudePrice(1, 2);
		DB_DoubleAttitudePrice(2, 2);
		DB_DoubleAttitudePrice(3, 3);
		DB_DoubleAttitudePrice(4, 3);
		DB_DoubleAttitudePrice(5, 4);
		DB_DoubleAttitudePrice(6, 5);
		DB_DoubleAttitudePrice(7, 6);
		DB_DoubleAttitudePrice(8, 7);
		DB_DoubleAttitudePrice(9, 12);
		DB_DoubleAttitudePrice(10, 15);
		DB_DoubleAttitudePrice(11, 20);
		DB_DoubleAttitudePrice(12, 25);
		DB_DoubleAttitudePrice(13, 30);
		DB_DoubleAttitudePrice(14, 35);
		DB_DoubleAttitudePrice(15, 40);
		DB_DoubleAttitudePrice(16, 60);
		DB_DoubleAttitudePrice(17, 65);
		DB_DoubleAttitudePrice(18, 75);
		DB_DoubleAttitudePrice(19, 85);
		DB_DoubleAttitudePrice(20, 95);
		// For 21 and higher
		DB_DoubleAttitudePrice(21, 100);
		
	}
	KB
	{
		//REGION Creating and resetting TraderTreasure
		PROC
		GenTradeItems((CHARACTERGUID)_Player,(CHARACTERGUID)_Trader)
		AND
		NOT DB_TraderGeneratedTreasureForLevel(_Trader,_)
		THEN
		DB_TraderGeneratedTreasureForLevel(_Trader,0);
		
		PROC
		GenTradeItems((CHARACTERGUID)_Player,(CHARACTERGUID)_Trader)
		AND
		DB_TraderGeneratedTreasureForLevel(_Trader,_OldLevel)
		AND
		CharacterGetLevel(_Player,_NewLevel)
		AND
		_NewLevel > _OldLevel
		THEN
		NOT DB_TraderGeneratedTreasureForLevel(_Trader,_OldLevel);
		DB_TraderGeneratedTreasureForLevel(_Trader,_NewLevel);
		DoGenTradeItems(_Player,_Trader);
		
		PROC
		ProcClearTradeFacts((CHARACTERGUID)_Trader)
		AND
		DB_TraderGeneratedTreasureForLevel(_Trader,_OldLevel)
		THEN
		NOT DB_TraderGeneratedTreasureForLevel(_Trader,_OldLevel);
		
		PROC	
		GenTradeItems((CHARACTERGUID)_Player,(CHARACTERGUID)_Trader) 
		AND
		DB_LastTradeItemGeneration(_Trader,(INTEGER)_THLastGen) 
		AND 
		_THLastGen != 0 
		AND		// check if last generation was long enough ago:
		DB_Time(_,_,_TH) 
		AND
		IntegerSubtract(_TH,_THLastGen,_Delta) 
		AND
		_Delta >= 12
		THEN	
		DoGenTradeItems(_Player,_Trader);
		
		// If not yet an inventory generated for this npc, do it:
		PROC	
		GenTradeItems((CHARACTERGUID)_Player,(CHARACTERGUID)_Npc) 
		AND
		DB_LastTradeItemGeneration(_Npc,0)		// not yet generated
		THEN	
		DoGenTradeItems(_Player,_Npc);
		
		//
		PROC	
		DoGenTradeItems((CHARACTERGUID)_Player,(CHARACTERGUID)_Npc) 
		AND 
		DB_LastTradeItemGeneration(_Npc,_THLastGen)
		THEN	
		NOT DB_LastTradeItemGeneration(_Npc,_THLastGen);
		
		//
		PROC	
		DoGenTradeItems((CHARACTERGUID)_Player,(CHARACTERGUID)_Npc) 
		AND 
		DB_Time(_,_,_TH)
		THEN	
		ProcGenerateTradeTreasure(_Player,_Npc);
		DB_LastTradeItemGeneration(_Npc,_TH);
		
		PROC
		ProcClearGeneratedItems((CHARACTERGUID)_Npc)
		AND
		NOT DB_ItemsCleared(_Npc)
		THEN
		DB_ItemsCleared(_Npc);
		CharacterClearTradeGeneratedItems(_Npc);
		
		IF
		DB_CustomTradeTreasure(_Npc,_Treasure)
		THEN
		ProcClearLastTradeTime(_Npc);
		
		PROC
		ProcClearLastTradeTime((CHARACTERGUID)_Trader)
		AND
		DB_LastTradeItemGeneration(_Trader,(INTEGER)_THLastGen) 
		THEN
		NOT DB_LastTradeItemGeneration(_Trader,_THLastGen);
		DB_LastTradeItemGeneration(_Trader,0);
		
		PROC
		ProcGenerateTradeTreasure((CHARACTERGUID)_Player,(CHARACTERGUID)_Npc) 
		AND
		DB_CustomTradeTreasure((CHARACTERGUID)_Npc,(STRING)_Treasure)
		THEN
		ProcClearGeneratedItems(_Npc);
		DB_CharacterGenerateCustomTradeTreasure(_Player,_Npc,_Treasure);
		DB_TreasureGenerated(1);
		
		PROC
		ProcGenerateTradeTreasure((CHARACTERGUID)_Player,(CHARACTERGUID)_Npc) 
		AND
		NOT DB_TreasureGenerated(1)
		THEN
		GenerateItems(_Player,_Npc);
		
		PROC
		ProcGenerateTradeTreasure((CHARACTERGUID)_Player,(CHARACTERGUID)_Npc) 
		THEN
		NOT DB_TreasureGenerated(1);
		NOT DB_ItemsCleared(_Npc);
		
		//Trader dies and trade treasure never generated -> generate
		IF
		CharacterPrecogDying(_Npc)
		AND
		IsTagged(_Npc, "TRADER", 1)
		AND
		CharacterIsPlayer(_Npc, 0)
		AND
		NOT DB_TraderGeneratedTreasureForLevel(_Npc, _)
		AND
		GetClosestPlayer(_NPC, _Player, _)
		THEN
		ProcGenerateTradeTreasure(_Player, _Npc);
		//END_REGION
		
		//REGION Start Trade
		//
		// StartTrade: set all facts and startup the trade window:
		//
		PROC	
		StartTrade((CHARACTERGUID)_Player,(CHARACTERGUID)_Npc)
		THEN	
		GenTradeItems(_Player,_Npc);					// regenerate items (clear if _Npc.DB_IsHostile())
		ResetInsults(_Player,_Npc);
		
		PROC	
		StartTrade((CHARACTERGUID)_Player,(CHARACTERGUID)_Npc) 
		THEN	
		DoStartTrade_1(_Player,_Npc);
		
		PROC	
		DoStartTrade_1((CHARACTERGUID)_Player,(CHARACTERGUID)_Npc) 
		AND
		DB_NoRepair(_Npc) 
		AND
		DB_NoIdentify(_Npc)
		THEN	
		ActivateTrade(_Player,_Npc,0,0,1);
		
		PROC	
		DoStartTrade_1((CHARACTERGUID)_Player,(CHARACTERGUID)_Npc) 
		AND
		NOT DB_NoRepair(_Npc) 
		AND
		DB_NoIdentify(_Npc)
		THEN	
		ActivateTrade(_Player,_Npc,1,0,1);
		
		PROC	
		DoStartTrade_1((CHARACTERGUID)_Player,(CHARACTERGUID)_Npc) 
		AND
		DB_NoRepair(_Npc) 
		AND
		NOT DB_NoIdentify(_Npc)
		THEN	
		ActivateTrade(_Player,_Npc,0,1,1);
		
		PROC	
		DoStartTrade_1((CHARACTERGUID)_Player,(CHARACTERGUID)_Npc) 
		AND
		NOT DB_NoRepair(_Npc) 
		AND
		NOT DB_NoIdentify(_Npc)
		THEN	
		ActivateTrade(_Player,_Npc,1,1,1);
		
		IF		
		RequestTrade(_Player,_Npc)
		THEN
		StartTrade(_Player,_Npc);
		
		PROC 
		ResetInsults((CHARACTERGUID)_Player,(CHARACTERGUID)_Npc)
		AND
		DB_InsultCounter(_Player, _Npc, _Counter)
		THEN
		NOT DB_InsultCounter(_Player, _Npc, _Counter);
		
		PROC 
		ResetInsults((CHARACTERGUID)_Player,(CHARACTERGUID)_Npc)
		THEN
		DB_InsultCounter(_Player, _Npc, 0);
		
		//END_REGION
		
		//REGION Finish trade and adjust attitude if necessary
		IF
		HappyWithDeal(_Player,_Npc,_ValuePlayer,_ValueNpc)
		AND
		QRY_GetAttitudeChangeForTrade(_Player,_Npc,_ValuePlayer,_ValueNpc)
		AND
		DB_AttitudeAdjustMent(_Player,_Npc,_Att)
		AND
		_Att != 0
		THEN
		CharacterAddAttitudeTowardsPlayer(_Npc,_Player,_Att);
		
		IF		
		HappyWithDeal(_Player,_Npc,_ValuePlayer,_ValueNpc) 
		AND
		_ValuePlayer >= _ValueNpc
		AND
		DB_AttitudeAdjustMent(_Player,_Npc,_Att)
		THEN	
		ExecuteDeal(_Player,1,_Att);
		
		IF		
		HappyWithDeal(_Player,_Npc,_ValuePlayer,_ValueNpc) 
		AND
		_ValuePlayer < _ValueNpc
		AND
		DB_AttitudeAdjustMent(_Player,_Npc,_Att)
		THEN	
		ExecuteDeal(_Player,0,_Att);
		
		QRY
		QRY_GetAttitudeChangeForTrade((CHARACTERGUID)_Player,(CHARACTERGUID)_Npc,(INTEGER)_ValuePlayer,(INTEGER)_ValueNpc)
		AND
		NOT DB_TempTradeBalance(_Player,_Npc,_)
		THEN
		DB_TempTradeBalance(_Player,_Npc,0);
		
		QRY
		QRY_GetAttitudeChangeForTrade((CHARACTERGUID)_Player,(CHARACTERGUID)_Npc,(INTEGER)_ValuePlayer,(INTEGER)_ValueNpc)
		AND
		IntegerSubtract(_ValuePlayer,_ValueNPC,_Delta)
		AND
		DB_TempTradeBalance(_Player,_Npc,_OldBalance)
		AND
		IntegerSum(_Delta,_OldBalance,_NewBalance)
		AND
		CharacterGetLevel(_Npc,_NpcLevel)
		AND
		IntegerMin(_NpcLevel, 21, _NpcLevelCapped)
		AND
		DB_DoubleAttitudePrice(_NpcLevelCapped,_DoublePrice)// Working with doubles to allow us to work with halves in integer envirnoment
		AND
		IntegerSum(_NewBalance,_NewBalance,_DoubleBalance)
		AND
		IntegerDivide(_DoubleBalance,_DoublePrice,_Q) // 1 Attitude point costs (L+1)/2
		AND
		IntegerProduct(_Q,_DoublePrice,_DoubleSubtracted)
		AND
		// Map to [-1..1] to adjust for rounding before division by 2 (0 stays 0)
		IntegerMax(_DoubleSubtracted, -1, _RoundToInfinityAdj1)
		AND
		IntegerMin(_RoundToInfinityAdj1, 1, _RoundToInfinityAdj)
		AND
		IntegerSum(_DoubleSubtracted,_RoundToInfinityAdj,_DoubleSubtractedIncremented)
		AND
		IntegerDivide(_DoubleSubtractedIncremented,2,_TotalSubtracted)
		AND
		IntegerSubtract(_NewBalance,_TotalSubtracted,_Remainder)
		THEN
		NOT DB_TempTradeBalance(_Player,_Npc,_OldBalance);
		DB_TempTradeBalance(_Player,_Npc,_Remainder);
		PROC_Trade_SetAttitudeAdjustment(_Player, _Npc, _Q);
		
		PROC
		PROC_Trade_SetAttitudeAdjustment((CHARACTERGUID)_Player, (CHARACTERGUID)_Npc, (INTEGER)_Q)
		AND
		DB_AttitudeAdjustMent(_Player,_Npc,_Att)
		THEN
		NOT DB_AttitudeAdjustMent(_Player,_Npc,_Att);
		
		PROC
		PROC_Trade_SetAttitudeAdjustment((CHARACTERGUID)_Player, (CHARACTERGUID)_Npc, (INTEGER)_Q)
		AND
		_Q >= 0
		THEN
		DB_AttitudeAdjustMent(_Player,_Npc,_Q);
		
		PROC
		PROC_Trade_SetAttitudeAdjustment((CHARACTERGUID)_Player, (CHARACTERGUID)_Npc, (INTEGER)_Q)
		AND
		_Q < 0
		AND
		DB_InsultCounter(_Player, _Npc, _InsultCount)
		AND
		_InsultCount < 2 // Player can insult trader with the offer 2 times before Attitude reduction kicks in
		AND
		IntegerSum(_InsultCount, 1, _NewInsultCount)
		AND
		DB_TempTradeBalance(_Player,_Npc,_Remainder)
		THEN
		DB_AttitudeAdjustMent(_Player,_Npc,0);
		NOT DB_InsultCounter(_Player,_Npc,_InsultCount);
		DB_InsultCounter(_Player,_Npc,_NewInsultCount);
		// If we ignore the insult, don't keep track of the balance either
		NOT DB_TempTradeBalance(_Player,_Npc,_Remainder);
		DB_TempTradeBalance(_Player,_Npc,0);
		
		PROC
		PROC_Trade_SetAttitudeAdjustment((CHARACTERGUID)_Player, (CHARACTERGUID)_Npc, (INTEGER)_Q)
		AND
		_Q < 0
		AND
		NOT DB_AttitudeAdjustMent(_Player,_Npc,_)
		AND
		CharacterGetAttitudeTowardsPlayer(_Npc,_Player,_OldAtt)
		AND
		IntegerSubtract(_OldAtt,15,_NewAtt)
		AND
		IntegerMax(_NewAtt,-45,_NewAttCapped)
		AND
		IntegerSubtract(_NewAttCapped,_oldAtt,_NewDelta)
		THEN
		DB_AttitudeAdjustMent(_Player,_Npc,_NewDelta);
		//END_REGION
		
		//Start Trade via Event (instead of button click in dialog)
		IF
		ObjectFlagSet("StartTrade",(CHARACTERGUID)_Player,_Instance)
		AND
		DB_DialogNPCs(_Instance,_Npc,1)
		THEN
		StartTrade((CHARACTERGUID)_Player,(CHARACTERGUID)_Npc);
		ObjectClearFlag(_Player,"StartTrade",_Instance);
		
		//REGION Manual Trade Toggling Per Player
		
		PROC
		Proc_DialogFlagSetup(_,(GUIDSTRING)_NPC,(GUIDSTRING)_Player)
		AND
		DB_ManualTradeNPC(_NPC)
		AND
		DB_PreventTradeBetween(_NPC,_Player)
		THEN
		CharacterSetCanTrade((CHARACTERGUID)_NPC,0);
		
		PROC
		Proc_DialogFlagSetup(_,(GUIDSTRING)_NPC,(GUIDSTRING)_Player)
		AND
		IsTagged(_NPC,"GHOST",1)
		THEN
		CharacterSetCanTrade((CHARACTERGUID)_NPC,0);
		
		IF
		ObjectFlagSet("PreventTradeWithPlayer",(GUIDSTRING)_NPC,_ID)
		AND
		DialogGetInvolvedPlayer(_ID,1,(CHARACTERGUID)_Player)
		THEN
		DB_ManualTradeNPC(_NPC);
		DB_PreventTradeBetween(_NPC,_Player);
		ObjectClearFlag(_NPC,"PreventTradeWithPlayer",_ID);
		
		PROC
		Proc_DialogFlagSetup(_,(GUIDSTRING)_NPC,(GUIDSTRING)_Player)
		AND
		DB_ManualTradeNPC(_NPC)
		AND
		NOT DB_PreventTradeBetween(_NPC,_Player)
		THEN
		CharacterSetCanTrade((CHARACTERGUID)_NPC,1);
		//END_REGION
		
		//REGION Savegame patching
		IF
		SavegameLoaded(_Major,_Minor,_Rev,_Build)
		AND
		QRY_VersionIsOlderThan(_Major,_Minor,_Rev,_Build, 3, 6, 0, 0)
		THEN
		NOT DB_DoubleAttitudePriceOverTwenty(100);
		DB_DoubleAttitudePrice(21, 100);
		//END_REGION
		
	}
	EXIT
	{
		
	}
}
Goal(52).Title("_TrapReactions");
Goal(52)
{
	INIT
	{
		DB_Event2DisplayText("HiddenPerceptionReveal","GEN_AD_HiddenPerceptionReveal");
		DB_Event2DisplayText("HiddenTrapReveal","GEN_AD_HiddenTrapReveal");
		DB_Event2DisplayText("FakePerceptionReveal","GEN_AD_FakePerceptionReveal");
		DB_Event2DisplayText("AmbushReveal","GLO_AD_AmbushDetected");
		
	}
	KB
	{
		IF
		CharacterItemEvent(_Player,_Item,_Event)
		AND
		NOT DB_BlockTextSpam(_Player)
		AND
		DB_CustomEvent2DisplayText_Item((ITEMGUID)_Item,(STRING)_Event,(STRING)_Text)
		AND
		_Player.DB_IsPlayer()
		AND
		QRY_SpeakerIsAvailable(_Player)
		THEN
		Proc_StartDialog(1,_Text, _Player);
		DB_BlockTextSpam(_Player);
		ProcObjectTimer(_Player,"BlockTextSpam",5000);
		
		IF
		StoryEvent((CHARACTERGUID)_Player,_Event)
		AND
		NOT DB_BlockTextSpam(_Player)
		AND
		_Player.DB_IsPlayer()
		AND
		DB_CustomEvent2DisplayText((CHARACTERGUID)_Player,(STRING)_Event,(STRING)_Text)
		AND
		QRY_SpeakerIsAvailable(_Player)
		THEN
		Proc_StartDialog(1,_Text, _Player);
		DB_BlockTextSpam(_Player);
		ProcObjectTimer(_Player,"BlockTextSpam",5000);
		
		IF
		StoryEvent((CHARACTERGUID)_Player,_Event)
		AND
		NOT DB_BlockTextSpam(_Player)
		AND
		_Player.DB_IsPlayer()
		AND
		DB_Event2DisplayText(_Event,_Text)
		AND
		QRY_SpeakerIsAvailable(_Player)
		THEN
		Proc_StartDialog(1,_Text, _Player);
		DB_BlockTextSpam(_Player);
		ProcObjectTimer(_Player,"BlockTextSpam",5000);
		
		PROC
		ProcObjectTimerFinished(_Player,"BlockTextSpam")
		THEN
		NOT DB_BlockTextSpam((CHARACTERGUID)_Player);
		
		
		
	}
	EXIT
	{
		
	}
}
Goal(53).Title("_Waypoints");
Goal(53)
{
	INIT
	{
		// Waypoint registration:
		//   DB_WaypointInfo((ITEMGUID)_WaypointItem,(TRIGGERGUID)_TeleportTrigger,(STRING)_WaypointID)
		
		// Waypoint Lock/Unlock:
		//   PROC_UnlockWaypoint((STRING)_WaypointID,(CHARACTERGUID)_Player) : unlocks waypoint for party, shows notification, updates DB
		//   PROC_LockWaypoint  ((STRING)_WaypointID,(CHARACTERGUID)_Player) : locks waypoint for party, updates DB
		//   DB_WaypointUnlocked((STRING)_WaypointID,(CHARACTERGUID)_Player) : waypoint unlock status for party
		// To lock certain character from using any waypoints (including Flee From Combat):
		//   PROC_BlockWaypointUsage  ((CHARACTERGUID)_Player) : block waypoints for character including Flee (blocks Waypoints button)
		//   PROC_UnblockWaypointUsage((CHARACTERGUID)_Player) : unblock waypoints for character including Flee (returns Waypoints button to previous state)
		//   DB_BlockWaypointUsage    ((CHARACTERGUID)_Player) : check status on character
		// Note: blocking is achieved through homestead button disabling
		
		// Helper PROCs for homestead button state at the end, all accept (CHARACTERGUID)_Player
		//   PROC_SetHomesteadKey_Invisible : no button
		//   PROC_SetHomesteadKey_Enabled   : button can be pressed
		//   PROC_SetHomesteadKey_NewRooms  : button can be pressed, has "new waypoints" indication
		//   PROC_SetHomesteadKey_Disabled  : buttone cannot be pressed (e.g. combat)
		//   DB_HomesteadKeyState((CHARACTERGUID)_Player,(INTEGER)_State) : homestead key state from 0 to 3
		
		// For Waypoints without DB_Dialogs but that should not open UI right away they are added to this DB (for example, used in FTJ):
		//   DB_WaypointBlockUI((ITEMGUID)_Item)
		
	}
	KB
	{
		// Register for map/minimap
		IF
		DB_WaypointInfo((ITEMGUID)_WaypointItem,(TRIGGERGUID)_TeleportTrigger,(STRING)_WaypointID)
		THEN
		RegisterWaypoint(_WaypointID,_WaypointItem);
		
		
		//REGION Waypoint unlock/lock for showing in waypoints UI
		// Through WaypointShrine Behavior script event
		IF
		CharacterItemEvent(_Player,_Item,"WaypointDiscovered")
		AND
		DB_WaypointInfo(_Item,(TRIGGERGUID)_TeleportTrigger,(STRING)_WaypointID)
		THEN
		PROC_UnlockWaypoint(_WaypointID,_Player);
		
		// Through direct interaction
		IF
		CharacterUsedItem(_Player,_Item)
		AND
		DB_WaypointInfo(_Item,_,_WaypointID)
		THEN
		PROC_UnlockWaypoint(_WaypointID,_Player);
		
		PROC
		PROC_UnlockWaypoint((STRING)_WaypointID,(CHARACTERGUID)_Player)
		AND
		NOT DB_WaypointUnlocked(_WaypointID,_Player)
		AND
		DB_WaypointInfo(_,_Trigger,_WaypointID)
		THEN
		PROC_UnlockWaypoint_Notification(_WaypointID,_Player);
		UnlockWaypoint(_WaypointID,_Trigger,_Player);
		PROC_UnlockWaypoint_RecordDB(_WaypointID,_Player);
		
		PROC
		PROC_UnlockWaypoint_Notification((STRING)_WaypointID,(CHARACTERGUID)_Player)
		AND
		NOT QRY_UnlockWaypoint_AlreadyUnlockedForParty(_WaypointID,_Player)
		AND
		DB_WaypointInfo(_Item,_Trigger,_WaypointID)
		THEN
		ShowNotification(_Player,"GLO_WaypointDiscovered");
		SetStoryEvent(_Item, "WaypointDiscoveredEffect");
		
		PROC
		PROC_UnlockWaypoint_Notification((STRING)_WaypointID,(CHARACTERGUID)_Player)
		AND
		CharacterGetReservedUserID(_Player, _User)
		AND
		DB_AtLeastOneWayPointUnlockedFor(_Player)
		AND
		NOT DB_BlockWaypointUsage(_Player)
		THEN
		PROC_CheckPlayTut(_Player, "TUT_Homestead");
		
		PROC
		PROC_UnlockWaypoint_Notification((STRING)_WaypointID,(CHARACTERGUID)_Player)
		THEN
		DB_AtLeastOneWayPointUnlockedFor(_Player);
		
		QRY
		QRY_UnlockWaypoint_AlreadyUnlockedForParty((STRING)_WaypointID,(CHARACTERGUID)_Player)
		AND
		DB_WaypointUnlocked(_WaypointID,_OtherPlayer)
		AND
		_OtherPlayer != _Player
		AND
		CharacterIsInPartyWith(_OtherPlayer,_Player,1)
		THEN
		DB_NOOP(1);
		
		PROC
		PROC_UnlockWaypoint_RecordDB((STRING)_WaypointID,(CHARACTERGUID)_Player)
		AND
		DB_IsPlayer((CHARACTERGUID)_OtherPlayer)
		AND
		CharacterIsInPartyWith(_OtherPlayer,_Player,1)
		THEN
		DB_WaypointUnlocked(_WaypointID,_OtherPlayer);
		PROC_WaypointUnlocked_Event(_OtherPlayer); // notify to change homestead button state
		
		
		PROC
		PROC_UnlockWaypointForAll((STRING)_WaypointID)
		AND
		DB_WaypointInfo(_,_,_WaypointID)
		AND
		DB_IsPlayer(_Player)
		THEN
		PROC_UnlockWaypoint(_WaypointID,_Player);
		
		
		PROC
		PROC_LockWaypoint((STRING)_WaypointID,(CHARACTERGUID)_Player)
		AND
		DB_WaypointUnlocked(_WaypointID,_Player)
		THEN
		LockWaypoint(_WaypointID,_Player);
		PROC_LockWaypoint_DBRecord(_WaypointID,_Player);
		
		PROC
		PROC_LockWaypoint_DBRecord((STRING)_WaypointID,(CHARACTERGUID)_Player)
		AND
		DB_IsPlayer((CHARACTERGUID)_OtherPlayer)
		AND
		CharacterIsInPartyWith(_OtherPlayer,_Player,1)
		THEN
		NOT DB_WaypointUnlocked(_WaypointID,_OtherPlayer);
		PROC_WaypointLocked_Event(_OtherPlayer); // notify to change homestead button state
		
		
		PROC
		PROC_LockWaypointForAll((STRING)_WaypointID)
		AND
		DB_WaypointInfo(_,_,_WaypointID)
		AND
		DB_IsPlayer(_Player)
		THEN
		PROC_LockWaypoint(_WaypointID,_Player);
		
		IF
		RegionEnded(_Region)
		AND
		DB_WaypointInfo(_Shrine,_,_Waypoint)
		AND
		ObjectExists(_Shrine,1)
		AND
		GetRegion(_Shrine,_Region)
		THEN
		PROC_LockWaypointForAll(_Waypoint);
		
		
		// Homestead button state changes
		PROC
		PROC_WaypointUnlocked_Event((CHARACTERGUID)_Player)
		AND
		NOT DB_BlockWaypointUsage(_Player) // and not story-blocked
		THEN
		PROC_SetHomesteadKey_NewRooms(_Player);
		
		PROC
		PROC_WaypointLocked_Event((CHARACTERGUID)_Player)
		AND
		NOT DB_WaypointUnlocked(_,_Player) // and no other waypoints
		THEN
		PROC_SetHomesteadKey_Disabled(_Player);
		//END_REGION
		
		
		//REGION Blocking Waypoint usage for characters
		
		PROC
		PROC_BlockWaypointUsage((CHARACTERGUID)_Player)
		AND
		DB_IsPlayer(_Player)
		THEN
		DB_BlockWaypointUsage(_Player);
		SetHomesteadKeyState(3,_Player); // call this directly, so that DB_HomesteadKeyState isn't updated
		
		PROC
		PROC_UnblockWaypointUsage((CHARACTERGUID)_Player)
		THEN
		NOT DB_BlockWaypointUsage(_Player);
		
		PROC
		PROC_UnblockWaypointUsage((CHARACTERGUID)_Player)
		AND
		DB_HomesteadKeyState(_Player,_StateBeforeBlock) // restore previous state
		THEN
		PROC_UnblockWaypointUsage_Helper(_Player,_StateBeforeBlock);
		
		PROC
		PROC_UnblockWaypointUsage_Helper((CHARACTERGUID)_Player,0)
		THEN
		PROC_SetHomesteadKey_Invisible(_Player);
		
		PROC
		PROC_UnblockWaypointUsage_Helper((CHARACTERGUID)_Player,1)
		THEN
		PROC_SetHomesteadKey_Enabled(_Player);
		
		PROC
		PROC_UnblockWaypointUsage_Helper((CHARACTERGUID)_Player,2)
		THEN
		PROC_SetHomesteadKey_NewRooms(_Player);
		
		PROC
		PROC_UnblockWaypointUsage_Helper((CHARACTERGUID)_Player,3)
		THEN
		PROC_SetHomesteadKey_Disabled(_Player);
		//END_REGION
		
		
		//REGION Waypoint usage
		
		IF
		CharacterUsedItem(_Player,_Item)
		AND
		DB_WaypointInfo(_Item,_,_WaypointID)
		AND
		NOT DB_CombatCharacters(_Player,_)
		AND
		NOT DB_BlockWaypointUsage(_Player)
		AND
		NOT DB_WaypointBlockUI(_Item)
		AND
		NOT DB_Dialogs(_Item,_)
		AND
		NOT DB_IsSign(_Item,(STRING)_,(STRING)_) // can't tell why was it placed here
		THEN
		PROC_OpenWaypointUI(_Player,_WaypointID,_Item);
		PROC_CheckPlayTut(_Player,"TUT_Waypoint");
		
		IF
		CharacterUsedItem(_Player,_Item)
		AND
		DB_WaypointInfo(_Item,_,_)
		AND
		DB_IsPlayer(_Player)
		AND
		DB_CombatCharacters(_Player,_)
		THEN
		Proc_StartDialog(1,"GLO_AD_CannotUseNow",_Player);
		
		IF
		ObjectFlagSet("OpenWaypointUI",_Player,_ID)
		AND
		NOT DB_BlockWaypointUsage((CHARACTERGUID)_Player)
		AND
		DB_DialogNPCs(_ID,_Item,1)
		AND
		DB_WaypointInfo((ITEMGUID)_Item,_Trigger,_CurrentWP)
		THEN
		PROC_OpenWaypointUI((CHARACTERGUID)_Player,_CurrentWP,_Item);
		ObjectClearFlag(_Player,"OpenWaypointUI",_ID);
		PROC_CheckPlayTut(_Player,"TUT_Waypoint");
		
		IF
		CharacterRequestsHomestead(_Player)
		AND
		NOT DB_BlockWaypointUsage(_Player)
		AND
		QRY_HasWaypointsUnlocked(_Player)
		THEN
		PROC_OpenWaypointUI(_Player,"",NULL_00000000-0000-0000-0000-000000000000);
		
		QRY
		QRY_HasWaypointsUnlocked((CHARACTERGUID)_Player)
		AND
		DB_WaypointUnlocked(_,_Player)
		THEN
		DB_NOOP(1);
		//END_REGION
		
		
		//REGION Waypoint teleportation
		
		IF
		CharacterTeleportToWaypoint(_Char,_Trigger)
		THEN
		TeleportTo(_Char,_Trigger,"",1,1);
		
		IF
		CharacterTeleportToFleeWaypoint(_Char,_Trigger)
		THEN
		TeleportTo(_Char,_Trigger,"",0,1,1);
		//END_REGION
		
		
		//REGION Waypoint UI helpers
		
		PROC
		PROC_OpenWaypointUI((CHARACTERGUID)_Player,(STRING)_WaypointCurrent,(ITEMGUID)_Item)
		THEN
		OpenWaypointUI(_Player,_WaypointCurrent,_Item,0);
		
		PROC
		PROC_OpenWaypointUIForFlee((CHARACTERGUID)_Player,(STRING)_WaypointCurrent,(ITEMGUID)_Item)
		THEN
		OpenWaypointUI(_Player,_WaypointCurrent,_Item,1);
		//END_REGION
		
		
		//REGION Homestead button state helpers
		
		PROC
		PROC_SetHomesteadKey_Invisible((CHARACTERGUID)_Player)
		THEN
		SetHomesteadKeyState(0,_Player);
		PROC_HomesteadKey_ReplaceHelper(_Player,0);
		
		PROC
		PROC_SetHomesteadKey_Enabled((CHARACTERGUID)_Player)
		THEN
		SetHomesteadKeyState(1,_Player);
		PROC_HomesteadKey_ReplaceHelper(_Player,1);
		
		PROC
		PROC_SetHomesteadKey_NewRooms((CHARACTERGUID)_Player)
		THEN
		SetHomesteadKeyState(2,_Player);
		PROC_HomesteadKey_ReplaceHelper(_Player,2);
		
		PROC
		PROC_SetHomesteadKey_Disabled((CHARACTERGUID)_Player)
		THEN
		SetHomesteadKeyState(3,_Player);
		PROC_HomesteadKey_ReplaceHelper(_Player,3);
		
		
		PROC
		PROC_HomesteadKey_ReplaceHelper((CHARACTERGUID)_Player,(INTEGER)_NewValue)
		AND
		DB_HomesteadKeyState(_Player,_PreviousValue)
		THEN
		NOT DB_HomesteadKeyState(_Player,_PreviousValue);
		DB_HomesteadKeyState(_Player,_NewValue);
		
		PROC
		PROC_HomesteadKey_ReplaceHelper((CHARACTERGUID)_Player,(INTEGER)_NewValue)
		AND
		NOT DB_HomesteadKeyState(_Player,_)
		THEN
		DB_HomesteadKeyState(_Player,_NewValue);
		//END_REGION
		
		
		//REGION Character joins party -> unlocked waypoints get shared by code
		// So also share the databases
		IF
		CharacterJoinedParty(_Joiner)
		AND
		DB_IsPlayer(_Joiner)
		AND
		DB_IsPlayer(_PartyMember)
		AND
		_Joiner != _PartyMember
		AND
		CharacterIsInPartyWith(_PartyMember, _Joiner, 1)
		THEN
		PROC_WayPoints_ShareWayPointState(_Joiner, _PartyMember);
		
		PROC
		PROC_WayPoints_ShareWayPointState((CHARACTERGUID)_Joiner, (CHARACTERGUID)_PartyMember)
		AND
		DB_WaypointUnlocked(_WaypointID, _Joiner)
		THEN
		PROC_UnlockWaypoint(_WayPointID, _PartyMember);
		
		PROC
		PROC_WayPoints_ShareWayPointState((CHARACTERGUID)_Joiner, (CHARACTERGUID)_PartyMember)
		AND
		DB_WaypointUnlocked(_WaypointID, _PartyMember)
		THEN
		PROC_UnlockWaypoint(_WayPointID, _Joiner);
		
		// Savegame fix
		IF
		SavegameLoaded(_Major,_Minor,_Rev,_Build)
		AND
		QRY_VersionIsOlderThan(_Major,_Minor,_Rev,_Build, 3, 5, 1, 0)
		AND
		DB_IsPlayer(_Joiner)
		AND
		DB_IsPlayer(_PartyMember)
		AND
		_Joiner != _PartyMember
		AND
		CharacterIsInPartyWith(_PartyMember,_Joiner,1)
		THEN
		PROC_WayPoints_ShareWayPointState(_Joiner,_PartyMember);
		
		// Blocking only gets inherited when recruiting, because it is region-based
		// rather than user/party-based
		PROC
		PROC_GLO_PartyMembers_RecruiteeAvatarBond_IfDifferent(_Origin,_Recruiter)
		AND
		DB_BlockWaypointUsage(_Recruiter)
		THEN
		PROC_BlockWaypointUsage(_Origin);
		
		PROC
		PROC_GLO_PartyMembers_RecruiteeAvatarBond_IfDifferent(_Origin,_Recruiter)
		AND
		DB_BlockWaypointUsage(_Origin)
		THEN
		PROC_BlockWaypointUsage(_Recruiter);
		//END_REGION
		
		//REGION Reset databases when dismissing
		IF
		CharacterReservedUserIDChanged(_Player, _, -65536)
		AND
		DB_WaypointUnlocked(_WaypointID,_Player)
		THEN
		// The actual unlock state is kept per party, so we don't have to actually lock
		// the waypoint. Just make sure it doesn't get unlocked by story again on next
		// recruitment (to avoid issues in case that recruitment is in another level;
		// new/existing waypoints will be shared again by the recruiter via code)
		NOT DB_WaypointUnlocked(_WaypointID,_Player);
		
		// Don't touch DB_BlockWaypointUsage, that one is handled manually and
		// since they all check DB_IsPlayer() and change the waypoint button state,
		// it's dangerous to start changing it automatically.
		//END_REGION
		
		//REGION Debug
		
		IF
		TextEventSet("wp")
		THEN
		PROC_Debug_UnlockAllWP();
		PROC_Debug_OpenWaypointUI();
		
		IF
		TextEventSet("wpunlock")
		THEN
		PROC_Debug_UnlockAllWP();
		
		IF
		TextEventSet("wpmenu")
		THEN
		PROC_Debug_OpenWaypointUI();
		
		PROC
		PROC_Debug_UnlockAllWP()
		AND
		DB_WaypointInfo(_,_Trigger,_WaypointID)
		THEN
		PROC_UnlockWaypointForAll(_WaypointID);
		
		PROC
		PROC_Debug_OpenWaypointUI()
		AND
		CharacterGetHostCharacter(_Player)
		THEN
		PROC_OpenWaypointUI(_Player,"",NULL_00000000-0000-0000-0000-000000000000);
		//END_REGION
		
		
	}
	EXIT
	{
		
	}
}
Goal(54).Title("GLO_Arena");
Goal(54)
{
	INIT
	{
		//	DB_ArenaMaster_SetFlags((STRING)ArenaName,(STRING)FlagUsedInDialog_ArenaType,(STRING)ArenaType,(TRIGGERGUID)CheckTrigger);
		//	Variables:
		//		ArenaName - groups all Databases to the Arena used (Driftwood, FTJ, etc)
		//		FlagUsedInDialog_ - Used at ObjectFlagSet from dialog (See RC_DW_Driftwood for example)
		//		ArenaType - defines which grouping type and checks we use:
		//			User - checks for Companions in region, available and groups them
		//			Party - checks for all characters in party in region, availabe, and groups them
		//			PVP - checks for initiator's Companions, and target and her Companions, in region, available and group in two teams
		//		CheckTrigger - trigger where characters need to be to be considered as "in region" availability
		
		//DB_ArenaMaster_SetFlags("Driftwood","Arena_Driftwood_User","User",(TRIGGERGUID)TRIGGERGUID_S_RC_DW_Undertavern_41caf09c-8ddd-461f-a892-a085009b648b);
		//DB_ArenaMaster_SetFlags("Driftwood","Arena_Driftwood_Party","Party",(TRIGGERGUID)TRIGGERGUID_S_RC_DW_Undertavern_41caf09c-8ddd-461f-a892-a085009b648b);
		//DB_ArenaMaster_SetFlags("Driftwood","Arena_Driftwood_Pvp","PVP",(TRIGGERGUID)TRIGGERGUID_S_RC_DW_Undertavern_41caf09c-8ddd-461f-a892-a085009b648b);
		
		//	DB_ArenaMaster_WinFlags((STRING)ArenaName,(STRING)WinFlag,(STRING)LostFlag);
		// 	Variables
		//		ArenaName - groups all Databases to the Arena used (Driftwood, FTJ, etc)
		//		WinFlag - flags winner character 
		//		LostFlag - flags loser character 
		
		//DB_ArenaMaster_WinFlags("Driftwood","Arena_Driftwood_Champion","Arena_Driftwood_Lost");
		
		//	DB_ArenaMaster((STRING)ArenaMasterDialog,(STRING)ArenaName,(TRIGGER)ArenaMasterPosition);
		// 	Variables
		//		ArenaMasterDialog - dialog used for checking and initiating Arena fights
		//		ArenaName - as mentioned before
		//		ArenaMasterPosition - position where players will be teleported after arena
		//DB_ArenaMaster((CHARACTERGUID)CHARACTERGUID_S_RC_DW_ArenaMaster_8a1c0600-aca0-479b-8044-a36d011ccff7,"RC_DW_ArenaMaster","Driftwood",(TRIGGERGUID)TRIGGERGUID_S_RC_DW_ArenaMaster_FnlPos_02858901-3e40-4a11-a724-4a289bbecff6);
		
		//	DB_ArenaPresets_Player((STRING)ArenaName,(STRING)Arena_TeamX,(TRIGGERGUID)Trigger);
		// 	Here we declare the position in which the characters will be teleportered when arena starts, according to their team
		//	Variables
		//		ArenaName - as mentioned before
		//		Arena_TeamX - sets the team and alignment; these should be "Arena_TeamA" and "Arena_TeamB"
		//			NOTE: there must be two DB_ArenaPresets_Player providing both "Arena_TeamA" and "Arena_TeamB" to allow PVP
		//		Trigger - the trigger point characters will be teleported when arena starts
		//			NOTE: Arena_TeamA and Arena_TeamB to start in different triggers
		
		//DB_ArenaPresets_Player("Driftwood","Arena_TeamA",(TRIGGERGUID)TRIGGERGUID_S_RC_DW_Arena_StartA_b78d7cc5-e889-4624-a75e-963cad782953);
		//DB_ArenaPresets_Player("Driftwood","Arena_TeamB",(TRIGGERGUID)TRIGGERGUID_S_RC_DW_Arena_StartB_e722e1da-2d01-49e4-89c2-4a073024049d);
		
		//	DB_ArenaPresets_Mobs((STRING)ArenaName,(CHARACTERGUID)NPC,(TRIGGERGUID)Trigger);
		//	When a preset is chosen, we look for which NPC and where they'll be teleported;
		// 	Here you want to list each NPC in arena, and their trigger - for each Preset
		//	Variables
		//		ArenaName - as mentioned before
		//		NPC - enemies who'll fight in the arena in that Preset
		//		Trigger - position the npc will be teleported
		
		//DB_ArenaPresets_Mobs("Driftwood",(CHARACTERGUID)CHARACTERGUID_S_RC_DW_UnderTavern_Dorotya_6fa62a51-5ac2-4b51-b3a8-0d7bf8e4b069,(TRIGGERGUID)TRIGGERGUID_S_RC_DW_Arena_StartB_e722e1da-2d01-49e4-89c2-4a073024049d);
		
		//	DB_ArenaMaster_RingGirl
		//	Initiates a final dialog when arena finished, before teleporting out
		//	Variables
		//		RingGirl - character used
		//		RingGirlDialog - dialog used for checking and initiating Arena fights
		//		ArenaName - as mentioned before
		//		ArenaMasterPosition - position where players will be teleported after arena
		
		//DB_ArenaMaster_RingGirl((CHARACTERGUID)CHARACTERGUID_S_RC_DW_Arena_RingGirl_dae14c53-e2ff-40ec-b637-a5ad688ec37d,"RC_DW_AD_Arena_RingGirl","Driftwood",(TRIGGERGUID)TRIGGERGUID_S_RC_DW_Arena_RingGirlTrig_a329f679-30a5-45f4-929f-424e080036c4);
		//DB_ArenaMaster_RingGirl((CHARACTERGUID)CHARACTERGUID_S_FTJ_RingGirl_Helper_2c6f3151-8d67-4af7-a4b7-e18b7c64ac94,"FTJ_AD_ArenaGirl","FortJoy",(TRIGGERGUID)TRIGGERGUID_S_FTJ_ArenaMid_5b46ec8d-8652-464f-a1b4-698d9155f6b3);
		
		//REGION Declarations
		
		DB_ArenaMaster((CHARACTERGUID)NULL_00000000-0000-0000-0000-000000000000,"NULL","NULL",(TRIGGERGUID)NULL_00000000-0000-0000-0000-000000000000);
		DB_ArenaPresets_Mobs("NULL",(CHARACTERGUID)NULL_00000000-0000-0000-0000-000000000000,(TRIGGERGUID)NULL_00000000-0000-0000-0000-000000000000);
		DB_ArenaChampionTag("NULL","NULL");
		DB_ArenaMaster_WinFlags("NULL","NULL","NULL");
		DB_ArenaPresets_Player("NULL","NULL",(TRIGGERGUID)NULL_00000000-0000-0000-0000-000000000000);
		DB_Arena_DisableLastManStanding("NULL");
		DB_Arena_ReviveCharAfter((CHARACTERGUID)NULL_00000000-0000-0000-0000-000000000000);
		DB_ArenaMaster_RingGirl((CHARACTERGUID)NULL_00000000-0000-0000-0000-000000000000,"NULL","NULL",(TRIGGERGUID)NULL_00000000-0000-0000-0000-000000000000);
		DB_Arena_MobIsAlreadyInArena((CHARACTERGUID)NULL_00000000-0000-0000-0000-000000000000);
		DB_Arena_FightToTheDeath("NULL");
		DB_ArenaMaster_SetFlags("NULL","NULL","NULL",(TRIGGERGUID)NULL_00000000-0000-0000-0000-000000000000);
		DB_Arena_NonLethal("NULL");
		
		//END_REGION
		
		DB_VariableTranslatedString("Arena_AvailablePlayer_1","Arena_AvailablePlayer_1_3b7981f5-c807-44bc-b2cd-a434ba7b6b35");
		DB_VariableTranslatedString("Arena_AvailablePlayer_2","Arena_AvailablePlayer_2_f3cb5f2b-c0ca-4b36-b671-dd64d481f45d");
		DB_VariableTranslatedString("Arena_AvailablePlayer_3","Arena_AvailablePlayer_3_ed640a14-91d4-472d-b92b-b042b8011fde");
		DB_VariableTranslatedString("Arena_AvailablePlayer_4","Arena_AvailablePlayer_4_3f666e1e-7f5e-43e8-8c02-3c61966147d3");
		
	}
	KB
	{
		//REGION Arena Masters
		IF
		DB_ArenaMaster_RingGirl((CHARACTERGUID)_Char,(STRING)_,(STRING)_,(TRIGGERGUID)_)
		THEN
		CharacterSetImmortal(_Char,1);
		SetOnStage(_Char,0);
		
		IF
		ObjectFlagSet(_Flag,_Char,_Inst)
		AND
		DB_Arena_AvailablePlayer(_Flag,_Target,_)
		THEN
		DebugText(_Char,_Flag);
		DB_Arena_PvpChallenge(_Char,_Target);
		
		IF
		ObjectFlagSet(_Flag,(CHARACTERGUID)_Char,_Inst) //Initiate Check
		AND
		DB_ArenaMaster_SetFlags((STRING)_Arena,(STRING)_Flag,(STRING)_Type,(TRIGGERGUID)_Trig)
		THEN
		//DebugText(_Char,_Arena);
		DB_ArenaMaster_SetUp(_Inst);
		Proc_Arena_CheckAvailableCharacters_1(_Arena,_Type,_Trig,_Char,_Inst);
		ObjectClearFlag(_Char,_Flag,_Inst);
		
		//Checking for other players
		IF
		DialogStarted(_Dialog,_Inst)
		AND
		DB_ArenaMaster(_,_Dialog,_,_)
		AND
		DialogGetInvolvedPlayer(_Inst,1,(CHARACTERGUID)_Initiator)
		AND
		CharacterGetReservedUserID(_Initiator,_InitiatorUser)
		AND
		NOT DB_ArenaMaster_CheckOtherPlayers_Initiated(_,_)
		THEN
		DB_ArenaMaster_CheckOtherPlayers_Initiated(_InitiatorUser,_Dialog);
		Proc_Arena_CheckOtherPlayers(_InitiatorUser,_Dialog);
		
		IF
		DialogEnded(_Dialog,_)
		AND
		DB_ArenaMaster_CheckOtherPlayers_Initiated(_InitiatorUser,_Dialog)
		THEN
		NOT DB_ArenaMaster_CheckOtherPlayers_Initiated(_InitiatorUser,_Dialog);
		
		PROC
		Proc_Arena_CheckOtherPlayers((INTEGER)_,(STRING)_)
		AND
		DB_IsPlayer(_Char)
		THEN
		UserClearFlag(_Char,"Arena_HasAvatar",0);
		PartyClearFlag(_Char,"Arena_PartyHasAvatar",0);
		
		PROC
		Proc_Arena_CheckOtherPlayers((INTEGER)_,(STRING)_)
		AND
		DB_Arena_CheckOtherPlayers_Count(_Int)
		THEN
		NOT DB_Arena_CheckOtherPlayers_Count(_Int);
		
		PROC
		Proc_Arena_CheckOtherPlayers((INTEGER)_,(STRING)_)
		AND
		DB_Arena_CheckOtherCharacters_Count(_Int)
		THEN
		NOT DB_Arena_CheckOtherCharacters_Count(_Int);
		
		PROC
		Proc_Arena_CheckOtherPlayers((INTEGER)_,(STRING)_)
		THEN
		GlobalClearFlag("ArenaDialog_SinglePlayer");
		GlobalClearFlag("ArenaDialog_SingleCharacter");
		GlobalClearFlag("Arena_AvailablePlayer_1");
		GlobalClearFlag("Arena_AvailablePlayer_2");
		GlobalClearFlag("Arena_AvailablePlayer_3");
		GlobalClearFlag("Arena_AvailablePlayer_4");
		GlobalClearFlag("Arena_ChallengePlayer_1");
		GlobalClearFlag("Arena_ChallengePlayer_2");
		GlobalClearFlag("Arena_ChallengePlayer_3");
		GlobalClearFlag("Arena_ChallengePlayer_4");
		GlobalClearFlag("ArenaDialog_NoOtherAvatars");
		
		PROC
		Proc_Arena_CheckOtherPlayers((INTEGER)_,(STRING)_)
		AND
		DB_Arena_AvailablePlayer(_ChallengeFlag,_Char,_User)
		THEN
		NOT DB_Arena_AvailablePlayer(_ChallengeFlag,_Char,_User);
		DebugText(_Char,"Proc_Arena_CheckOtherPlayers");
		
		PROC
		Proc_Arena_CheckOtherPlayers((INTEGER)_,(STRING)_)
		AND
		DB_IsPlayer(_Char)
		AND
		IsTagged(_Char,"AVATAR",1)
		THEN
		UserSetFlag(_Char,"Arena_HasAvatar");
		PartySetFlag(_Char,"Arena_PartyHasAvatar");
		
		IF
		GlobalFlagSet("ArenaDialog_SinglePlayer")
		THEN
		DebugText(CHARACTERGUID_S_FTJ_ArenaMaster_4eadc6c7-f934-43ad-bb74-c59358106114,"ArenaDialog_SinglePlayer");
		
		PROC
		Proc_Arena_CheckOtherPlayers((INTEGER)_,(STRING)_)
		THEN
		DB_Arena_CheckOtherCharacters_Count(0);
		
		PROC
		Proc_Arena_CheckOtherPlayers((INTEGER)_,(STRING)_)
		AND
		GetUserCount(1)
		THEN
		GlobalSetFlag("ArenaDialog_SinglePlayer");
		
		
		PROC
		Proc_Arena_CheckOtherPlayers((INTEGER)_,(STRING)_)
		AND
		GlobalGetFlag("ArenaDialog_SinglePlayer",0)
		THEN
		DB_Arena_CheckOtherPlayers_Count(0);
		
		
		PROC 
		Proc_Arena_CheckOtherPlayers((INTEGER)_InitiatorUser,(STRING)_)
		AND
		DB_IsPlayer(_Char)
		AND
		CharacterGetReservedUserID(_Char,_InitiatorUser)
		AND
		DB_Arena_CheckOtherCharacters_Count(_Int)
		AND
		IntegerSum(_Int,1,_Sum)
		THEN
		NOT DB_Arena_CheckOtherCharacters_Count(_Int);
		DB_Arena_CheckOtherCharacters_Count(_Sum);
		
		PROC 
		Proc_Arena_CheckOtherPlayers((INTEGER)_InitiatorUser,(STRING)_)
		AND
		DB_Arena_CheckOtherCharacters_Count(_Int)
		AND
		NOT _Int > 1
		THEN
		GlobalSetFlag("ArenaDialog_SingleCharacter");
		
		
		PROC 
		Proc_Arena_CheckOtherPlayers((INTEGER)_InitiatorUser,(STRING)_)
		AND
		GlobalGetFlag("ArenaDialog_SinglePlayer",0)
		AND
		DB_IsPlayer(_Char)
		AND
		IsTagged(_Char,"AVATAR",1)
		AND
		CharacterGetReservedUserID(_Char,_User)
		AND
		_User!=_InitiatorUser
		AND
		DB_Arena_CheckOtherPlayers_Count(_Int)
		AND
		IntegerSum(_Int,1,_Sum)
		AND
		IntegertoString(_Sum,_SumString)
		AND
		StringConcatenate("Arena_AvailablePlayer_",_SumString,_CheckFlag)
		AND
		StringConcatenate("Arena_ChallengePlayer_",_SumString,_ChallengeFlag)
		AND
		NOT DB_Arena_AvailablePlayer(_,_,_User)
		THEN
		NOT DB_Arena_CheckOtherPlayers_Count(_Int);
		DB_Arena_CheckOtherPlayers_Count(_Sum);
		GlobalSetFlag(_CheckFlag);
		DB_Arena_AvailablePlayer_SetDialogVar(_CheckFlag,_Char,_User);
		DB_Arena_AvailablePlayer(_ChallengeFlag,_Char,_User);
		DebugText(_Char,_ChallengeFlag);
		
		PROC 
		Proc_Arena_CheckOtherPlayers((INTEGER)_,(STRING)_Dialog)
		AND
		DB_Arena_AvailablePlayer_SetDialogVar(_CheckFlag,_Char,_User)
		AND
		DB_VariableTranslatedString(_CheckFlag,_Var)
		AND
		CharacterGetDisplayName(_Char,_handle,_ref)
		THEN
		DialogSetVariableTranslatedString(_Dialog,_Var,_handle,_ref);
		NOT DB_Arena_AvailablePlayer_SetDialogVar(_CheckFlag,_Char,_User);
		
		
		PROC 
		Proc_Arena_CheckOtherPlayers(_,_)
		AND
		NOT DB_Arena_AvailablePlayer(_,_,_)
		THEN
		GlobalSetFlag("ArenaDialog_NoOtherAvatars");
		
		
		//END_REGION
		
		//REGION Team Manager
		PROC
		Proc_Arena_CheckAvailableCharacters_1((STRING)_,(STRING)_,(TRIGGERGUID)_,(CHARACTERGUID)_,(INTEGER)_)
		THEN
		GlobalClearFlag("Arena_CharNotInRegion");
		GlobalClearFlag("Arena_CharNotAvailable");
		GlobalClearFlag("Arena_StartAfterDialog");
		
		PROC
		Proc_Arena_CheckAvailableCharacters_1((STRING)_,"User",(TRIGGERGUID)_Trig,(CHARACTERGUID)_Initiator,(INTEGER)_)
		AND
		CharacterGetReservedUserID(_Initiator,_User)
		AND
		DB_IsPlayer(_Char)
		AND
		CharacterGetReservedUserID(_Char,_User)
		THEN
		Proc_Arena_CheckAvailableCharacters_2(_Char,_Trig,_Initiator);
		
		PROC
		Proc_Arena_CheckAvailableCharacters_1((STRING)_,"Party",(TRIGGERGUID)_Trig,(CHARACTERGUID)_Initiator,(INTEGER)_)
		AND
		DB_IsPlayer(_Char)
		AND
		CharacterIsInPartyWith(_Char,_Initiator,1)
		THEN
		Proc_Arena_CheckAvailableCharacters_2(_Char,_Trig,_Initiator);
		
		PROC
		Proc_Arena_CheckAvailableCharacters_1((STRING)_,"PVP",(TRIGGERGUID)_Trig,(CHARACTERGUID)_Initiator,(INTEGER)_)
		AND
		DB_Arena_PvpChallenge(_Initiator,_Target)
		AND
		CharacterGetReservedUserID((CHARACTERGUID)_Target,_User)
		AND
		DB_IsPlayer(_Char)
		AND
		CharacterGetReservedUserID(_Char,_User)
		THEN
		Proc_Arena_CheckAvailableCharacters_2(_Char,_Trig,_Initiator);
		DebugText(_Char,"Proc_Arena_CheckAvailableCharacters_2");
		
		PROC
		Proc_Arena_CheckAvailableCharacters_1((STRING)_,"PVP",(TRIGGERGUID)_Trig,(CHARACTERGUID)_Initiator,(INTEGER)_)
		AND
		CharacterGetReservedUserID((CHARACTERGUID)_Initiator,_User)
		AND
		DB_IsPlayer(_Char)
		AND
		CharacterGetReservedUserID(_Char,_User)
		THEN
		Proc_Arena_CheckAvailableCharacters_2(_Char,_Trig,_Initiator);
		
		PROC
		Proc_Arena_CheckAvailableCharacters_2((CHARACTERGUID)_Char,(TRIGGERGUID)_Trig,(CHARACTERGUID)_)
		AND
		GlobalGetFlag("Arena_CharNotInRegion",0)
		AND
		NOT DB_InRegion(_Char,_Trig)
		AND
		NOT DB_Arena_PlayerParticipants("DriftwoodVoidwoken",_,_Char,_)
		AND
		NOT DB_Arena_PlayerParticipants("DriftwoodMurga",_,_Char,_)
		THEN
		//DebugText(_Char,"Arena_CharNotInRegion");
		GlobalSetFlag("Arena_CharNotInRegion");
		
		PROC
		Proc_Arena_CheckAvailableCharacters_2((CHARACTERGUID)_Char,(TRIGGERGUID)_Trig,(CHARACTERGUID)_Initiator)
		AND
		GlobalGetFlag("Arena_CharNotInRegion",0)
		AND
		GlobalGetFlag("Arena_CharNotAvailable",0)
		AND
		_Char!=_Initiator
		AND
		NOT DB_Arena_PlayerParticipants("DriftwoodVoidwoken",_,_Char,_)
		AND
		NOT DB_Arena_PlayerParticipants("DriftwoodMurga",_,_Char,_)
		AND
		NOT QRY_SpeakerIsAvailable(_Char)
		THEN
		GlobalSetFlag("Arena_CharNotAvailable");
		//DebugText(_Char,"Arena_CharNotAvailable");
		
		PROC
		Proc_Arena_CheckAvailableCharacters_1((STRING)_Arena,(STRING)_Type,(TRIGGERGUID)_,(CHARACTERGUID)_Initiator,(INTEGER)_Inst)
		AND
		GlobalGetFlag("Arena_CharNotInRegion",0)
		AND
		GlobalGetFlag("Arena_CharNotAvailable",0)
		THEN
		Proc_Arena_SetUpTeams(_Arena,_Type,_Initiator,_Inst);
		//DebugText(_Initiator,"Proc_Arena_SetUpTeams");
		
		//END_REGION
		
		//REGION Preset Manager; Player
		PROC
		Proc_Arena_SetUpTeams((STRING)_Arena,"Single",(CHARACTERGUID)_Initiator,(INTEGER)_Inst)
		THEN
		DB_Arena_PlayerParticipants(_Arena,_Inst,_Initiator,"Arena_TeamA");
		
		PROC
		Proc_Arena_SetUpTeams((STRING)_Arena,"User",(CHARACTERGUID)_Initiator,(INTEGER)_Inst)
		AND
		CharacterGetReservedUserID(_Initiator,_User)
		AND
		DB_IsPlayer(_Char)
		AND
		CharacterGetReservedUserID(_Char,_User)
		AND
		NOT DB_Arena_PlayerParticipants("DriftwoodVoidwoken",_,_Char,_)
		AND
		NOT DB_Arena_PlayerParticipants("DriftwoodMurga",_,_Char,_)
		THEN
		DB_Arena_PlayerParticipants(_Arena,_Inst,_Char,"Arena_TeamA");
		//DebugText(_Char,"User Arena_TeamA");
		
		PROC
		Proc_Arena_SetUpTeams((STRING)_Arena,"Party",(CHARACTERGUID)_Initiator,(INTEGER)_Inst)
		AND
		DB_IsPlayer(_Char)
		AND
		CharacterIsInPartyWith(_Char,_Initiator,1)
		AND
		NOT DB_Arena_PlayerParticipants("DriftwoodVoidwoken",_,_Char,_)
		AND
		NOT DB_Arena_PlayerParticipants("DriftwoodMurga",_,_Char,_)
		THEN
		DB_Arena_PlayerParticipants(_Arena,_Inst,_Char,"Arena_TeamA");
		//DebugText(_Char,"Party Arena_TeamA");
		
		PROC
		Proc_Arena_SetUpTeams((STRING)_Arena,"PVP",(CHARACTERGUID)_Initiator,(INTEGER)_Inst)
		AND
		CharacterGetReservedUserID(_Initiator,_User)
		AND
		DB_IsPlayer(_Char)
		AND
		CharacterGetReservedUserID(_Char,_User)
		THEN
		DB_Arena_PlayerParticipants(_Arena,_Inst,_Char,"Arena_TeamA");
		//DebugText(_Char,"Arena_TeamA");
		
		PROC
		Proc_Arena_SetUpTeams((STRING)_Arena,"PVP",(CHARACTERGUID)_Initiator,(INTEGER)_Inst)
		AND
		DB_Arena_PvpChallenge(_Initiator,_Target)
		AND
		CharacterGetReservedUserID((CHARACTERGUID)_Target,_User)
		AND
		DB_IsPlayer(_Char)
		AND
		CharacterGetReservedUserID(_Char,_User)
		THEN
		DB_Arena_PlayerParticipants(_Arena,_Inst,_Char,"Arena_TeamB");
		DebugText(_Char,"Arena_TeamB");
		
		
		PROC
		Proc_Arena_SetUpTeams((STRING)_Arena,"PVP",(CHARACTERGUID)_Initiator,(INTEGER)_Inst)
		AND
		NOT DB_Arena_PlayerParticipants(_,_Inst,_,"Arena_TeamB")
		THEN
		GlobalClearFlag("Arena_StartAfterDialog");
		DebugText(_Initiator,"NO PARTICIPANTS!");
		
		
		PROC
		Proc_Arena_SetUpTeams((STRING)_,(STRING)_,(CHARACTERGUID)_Char,(INTEGER)_Inst)
		AND
		NOT DB_Arena_PlayerParticipants(_,_Inst,_,_)
		THEN
		DebugText(_Char,"NO PARTICIPANTS!");
		//END_REGION
		
		//REGION Preset Manager; NPCs
		PROC
		Proc_Arena_SetUpTeams((STRING)_Arena,(STRING)_Type,(CHARACTERGUID)_Initiator,(INTEGER)_)
		AND
		_Type != "PVP"
		AND
		DB_ArenaPresets_Mobs((STRING)_Arena,(CHARACTERGUID)_Char,(TRIGGERGUID)_Trig)
		AND
		CharacterIsDead(_Char,1)
		THEN
		DebugText(_Initiator,"Mob is dead!"); //TODO what now?
		
		//TODO preset definitions & get preset
		PROC
		Proc_Arena_SetUpTeams((STRING)_Arena,(STRING)_Type,(CHARACTERGUID)_Initiator,(INTEGER)_Inst)
		AND
		_Type != "PVP"
		AND
		DB_ArenaPresets_Mobs(_Arena,_Char,_Trig)
		AND
		NOT CharacterIsDead(_Char,1)
		THEN
		DB_Arena_MobParticipants(_Inst,_Char,_Trig,"Arena_TeamB");
		
		PROC
		Proc_Arena_SetUpTeams((STRING)_,(STRING)_Type,(CHARACTERGUID)_Initiator,(INTEGER)_Inst)
		AND
		_Type != "PVP"
		AND
		NOT DB_Arena_MobParticipants(_Inst,_,_,_)
		THEN
		DebugText(_Initiator,"NO MOBS!");
		
		PROC
		Proc_Arena_SetUpTeams((STRING)_,(STRING)_Type,(CHARACTERGUID)_Initiator,(INTEGER)_Inst)
		AND
		_Type != "PVP"
		AND
		GlobalGetFlag("Arena_StartAfterDialog",0)
		AND
		DB_Arena_PlayerParticipants(_,_Inst,_,_)
		AND
		DB_Arena_MobParticipants(_Inst,_,_,_)
		THEN
		GlobalSetFlag("Arena_StartAfterDialog");
		
		PROC
		Proc_Arena_SetUpTeams((STRING)_,"PVP",(CHARACTERGUID)_Initiator,(INTEGER)_Inst)
		AND
		GlobalGetFlag("Arena_StartAfterDialog",0)
		AND
		DB_Arena_PlayerParticipants(_,_Inst,_Char,"Arena_TeamA")
		AND
		DB_Arena_PlayerParticipants(_,_Inst,_OtherChar,"Arena_TeamB")
		AND
		CharacterGetReservedUserID(_Char,_User)
		AND
		CharacterGetReservedUserID(_OtherChar,_User)
		THEN
		DB_Arena_PlayerParticipants_SameUser(1);
		DebugText(_Char,"same user");
		
		PROC
		Proc_Arena_SetUpTeams((STRING)_,"PVP",(CHARACTERGUID)_Initiator,(INTEGER)_Inst)
		AND
		NOT DB_Arena_PlayerParticipants_SameUser(1)
		AND
		GlobalGetFlag("Arena_StartAfterDialog",0)
		AND
		DB_Arena_PlayerParticipants(_,_Inst,_,"Arena_TeamA")
		AND
		DB_Arena_PlayerParticipants(_,_Inst,_,"Arena_TeamB")
		THEN
		GlobalSetFlag("Arena_StartAfterDialog");
		
		//Creates Global flag: Arena_[ArenaName]_PvpInitiated
		PROC
		Proc_Arena_SetUpTeams((STRING)_Arena,(STRING)_Type,(CHARACTERGUID)_Initiator,(INTEGER)_Inst)
		AND
		GlobalGetFlag("Arena_StartAfterDialog",1)
		AND
		DB_ArenaMaster_SetFlags((STRING)_Arena,(STRING)_Flag,(STRING)_Type,_)
		AND
		_Type == "Pvp"
		AND
		StringConcatenate("Arena_",_Arena,_ArenaFlag)
		AND
		StringConcatenate(_ArenaFlag,"_PvpInitiated",_NewFlag)
		THEN
		GlobalSetFlag(_NewFlag);
		
		//Creates User flag: Arena_[ArenaName]_PvpParticipated
		PROC
		Proc_Arena_SetUpTeams((STRING)_Arena,(STRING)_Type,(CHARACTERGUID)_Initiator,(INTEGER)_Inst)
		AND
		GlobalGetFlag("Arena_StartAfterDialog",1)
		AND
		DB_ArenaMaster_SetFlags((STRING)_Arena,(STRING)_Flag,(STRING)_Type,_)
		AND
		_Type == "Pvp"
		AND
		StringConcatenate("Arena_",_Arena,_ArenaFlag)
		AND
		StringConcatenate(_ArenaFlag,"_PvpParticipated",_NewFlag)
		AND
		DB_Arena_PlayerParticipants(_Arena,_Inst,_Char,_)
		THEN
		UserSetFlag(_Char,_NewFlag);
		
		//Creates Global flag: Arena_[ArenaName]_PveInitiated
		PROC
		Proc_Arena_SetUpTeams((STRING)_Arena,(STRING)_Type,(CHARACTERGUID)_Initiator,_)
		AND
		GlobalGetFlag("Arena_StartAfterDialog",1)
		AND
		DB_ArenaMaster_SetFlags((STRING)_Arena,(STRING)_Flag,(STRING)_Type,_)
		AND
		_Type != "Pvp"
		AND
		StringConcatenate("Arena_",_Arena,_ArenaFlag)
		AND
		StringConcatenate(_ArenaFlag,"_PveInitiated",_NewFlag)
		THEN
		GlobalSetFlag(_NewFlag);
		
		//Creates User flag: Arena_[ArenaName]_PveParticipated
		PROC
		Proc_Arena_SetUpTeams((STRING)_Arena,(STRING)_Type,(CHARACTERGUID)_Initiator,_)
		AND
		GlobalGetFlag("Arena_StartAfterDialog",1)
		AND
		DB_ArenaMaster_SetFlags((STRING)_Arena,(STRING)_Flag,(STRING)_Type,_)
		AND
		_Type != "Pvp"
		AND
		StringConcatenate("Arena_",_Arena,_ArenaFlag)
		AND
		StringConcatenate(_ArenaFlag,"_PveParticipated",_NewFlag)
		AND
		DB_Arena_PlayerParticipants(_Arena,_Inst,_Char,_)
		THEN
		UserSetFlag(_Char,_NewFlag);
		
		PROC
		Proc_Arena_SetUpTeams((STRING)_Arena,(STRING)_Type,(CHARACTERGUID)_Initiator,_)
		AND
		GlobalGetFlag("Arena_StartAfterDialog",1)
		AND
		DB_ArenaMaster_SetFlags((STRING)_Arena,(STRING)_Flag,(STRING)_Type,_)
		AND
		_Type != "Pvp"
		AND
		StringConcatenate("Arena_",_Arena,_ArenaFlag)
		AND
		StringConcatenate(_ArenaFlag,"_PveParticipated",_NewFlag)
		THEN
		GlobalSetFlag(_NewFlag);
		
		PROC
		Proc_Arena_SetUpTeams(_,_,(CHARACTERGUID)_Initiator,_)
		AND
		GlobalGetFlag("Arena_StartAfterDialog",1)
		THEN
		DialogRequestStop(_Initiator);
		
		
		//END_REGION
		
		
		//REGION Arena Logic; Start
		//TODO find a better place to start
		IF
		DialogEnded(_,_Inst)
		AND
		DB_ArenaMaster_SetUp(_Inst)
		AND
		GlobalGetFlag("Arena_StartAfterDialog",1)
		THEN
		Proc_Arena_Initiate(_Inst);
		Proc_Arena_ClearFlagsAndDatabases(_Inst);
		
		PROC
		Proc_Arena_Initiate((INTEGER)_Inst)
		THEN
		GlobalSetFlag("Arena_OnGoing");
		
		PROC
		Proc_Arena_Initiate((INTEGER)_Inst)
		AND
		DB_Arena_PlayerParticipants(_Arena,_Inst,_Char,_Team)
		AND
		DB_ArenaPresets_Player((STRING)_Arena,(STRING)_Team,(TRIGGERGUID)_Trig)
		AND
		GetFaction(_Char,_Faction)
		THEN
		DB_Arena_PreviousFaction(_Char,_Faction);
		DB_Arena_CharIsAlive(_Team,_Char);
		TeleportTo(_Char,_Trig,"",0);
		SetInArena(_Char,1);
		SetFaction(_Char,_Team); 
		
		
		PROC
		Proc_Arena_Initiate((INTEGER)_Inst)
		AND
		DB_Arena_MobParticipants(_Inst,_Char,_Trig,_Team)
		AND
		NOT DB_Arena_MobIsAlreadyInArena(_Char)
		AND
		GetFaction(_Char,_Faction)
		AND
		GetPosition(_Char,_X,_Y,_Z)
		THEN
		SetOnStage(_Char,1);
		DB_Arena_PreviousFaction(_Char,_Faction);
		DB_Arena_PreviousLocation(_Char,_X,_Y,_Z);
		TeleportTo(_Char,_Trig);
		
		PROC
		Proc_Arena_Initiate((INTEGER)_Inst)
		AND
		DB_Arena_MobParticipants(_Inst,_Char,_Trig,_Team)
		THEN
		DB_Arena_CharIsAlive(_Team,_Char);
		SetInArena(_Char,1);
		SetFaction(_Char,_Team); 
		
		//END_REGION
		
		//REGION Win conditions
		IF
		CharacterDying(_Char)
		AND
		GlobalGetFlag("Arena_RequestingLastManStanding",0)
		AND
		DB_Arena_CharIsAlive(_Team,_Char)
		AND
		NOT QRY_CharIsAboutToResurrect(_Char)
		THEN
		NOT DB_Arena_CharIsAlive(_Team,_Char);
		DB_Arena_CharWasAlive(_Team,_Char);
		Proc_Arena_CheckWinCondition();
		
		IF
		CharacterResurrected(_Char)
		AND
		DB_Arena_CharWasAlive(_Team,_Char)
		THEN
		DB_Arena_CharIsAlive(_Team,_Char);
		NOT DB_Arena_CharWasAlive(_Team,_Char);
		
		
		//REGION Non-Lethal Arena / Unconcious Mechanic
		
		IF
		DB_Arena_CharIsAlive(_Team,_Char)
		AND
		Qry_Arena_InNonLethalArena(_Char)
		THEN
		CharacterSetImmortal(_Char,1);
		
		IF
		CharacterReceivedDamage(_Char,_,_)
		AND
		Qry_Arena_InNonLethalArena(_Char)
		AND
		CharacterGetHitpointsPercentage(_Char,_Per)
		AND
		_Per < 1
		THEN
		ApplyStatus(_Char,"UNCONSCIOUS",-1.0,1);
		
		IF
		CharacterStatusApplied(_Char,"UNCONSCIOUS",_)
		AND
		Qry_Arena_InNonLethalArena(_Char)
		AND
		DB_Arena_CharIsAlive(_Team,_Char)
		THEN
		SetInArena(_Char,0);
		SetCanFight(_Char,0);
		SetCanJoinCombat(_Char,0);
		ObjectSetFlag(_Char,"GLO_BlockRegenAfterCombat");
		NOT DB_Arena_CharIsAlive(_Team,_Char);
		Proc_Arena_CheckWinCondition();
		
		
		QRY
		Qry_Arena_InNonLethalArena((CHARACTERGUID)_Char)
		AND
		DB_Arena_CharIsAlive(_,_Char)
		AND
		DB_ArenaPresets_Mobs(_Arena,_Char,_)
		AND
		DB_Arena_NonLethal(_Arena)
		THEN
		DB_NOOP(1);
		
		QRY
		Qry_Arena_InNonLethalArena((CHARACTERGUID)_Char)
		AND
		DB_Arena_CharIsAlive(_,_Char)
		AND
		DB_Arena_PlayerParticipants(_Arena,_,_Char,_)
		AND
		DB_Arena_NonLethal(_Arena)
		THEN
		DB_NOOP(1);
		
		
		//Clean Up
		PROC
		Proc_Arena_Win_TeleportOut()
		AND
		DB_Arena_NonLethal(_Arena)
		AND
		DB_Arena_PlayerParticipants(_Arena,_,_Char,_)
		THEN
		Proc_Arena_NonLethalCombatEnded(_Char);
		
		PROC
		Proc_Arena_Win_TeleportOut()
		AND
		DB_Arena_NonLethal(_Arena)
		AND
		DB_Arena_PreviousLocation(_Char,_X,_Y,_Z)
		AND
		DB_ArenaPresets_Mobs(_Arena,_Char,_)
		THEN
		TeleportToPosition(_Char,_X,_Y,_Z,"",1);
		NOT DB_Arena_PreviousLocation(_Char,_X,_Y,_Z);
		Proc_Arena_NonLethalCombatEnded(_Char);
		
		PROC
		Proc_Arena_NonLethalCombatEnded((CHARACTERGUID)_Char)
		THEN
		SetInArena(_Char,0);
		ObjectClearFlag(_Char,"GLO_BlockRegenAfterCombat");
		SetCanFight(_Char,1);
		SetCanJoinCombat(_Char,1);
		Proc_CharacterFullRestore(_Char);
		CharacterSetImmortal(_Char,0);
		
		//END_REGION
		
		PROC
		Proc_Arena_CheckWinCondition()
		THEN
		GlobalClearFlag("Arena_RequestingLastManStanding");
		
		PROC
		Proc_Arena_CheckWinCondition()
		AND
		NOT DB_Arena_CharIsAlive("Arena_TeamA",_)
		THEN
		Proc_Arena_Win("Arena_TeamB");
		
		PROC
		Proc_Arena_CheckWinCondition()
		AND
		NOT DB_Arena_CharIsAlive("Arena_TeamB",_)
		AND
		DB_Arena_PlayerParticipants(_Arena,_,_,_)
		AND
		NOT DB_Arena_DisableLastManStanding(_Arena)
		THEN
		Proc_Arena_CheckWinCondition_CheckForLMS();
		
		PROC
		Proc_Arena_CheckWinCondition()
		AND
		NOT DB_Arena_CharIsAlive("Arena_TeamB",_)
		AND
		GlobalGetFlag("Arena_RequestingLastManStanding",0)
		THEN
		Proc_Arena_Win("Arena_TeamA");
		
		PROC
		Proc_Arena_Win((STRING)_)
		AND
		DB_Arena_PlayerParticipants(_,_,_Char,_)
		THEN
		ProcSetInvulnerable(_Char,1);
		
		PROC
		Proc_Arena_Win((STRING)_)
		THEN
		Proc_Arena_Win_RingGirl();
		
		PROC
		Proc_Arena_Win((STRING)_)
		AND
		DB_Arena_PlayerParticipants(_Arena,_,_,_)
		THEN
		Proc_Arena_SetMobsOffStage(_Arena);
		
		PROC
		Proc_Arena_SetMobsOffStage((STRING)_Arena)
		THEN
		DB_NOOP(1);
		
		PROC
		Proc_Arena_Win((STRING)_Team)
		AND
		DB_Arena_PlayerParticipants(_Arena,_,_Char,_Team)
		AND
		CharacterIsDead(_Char,0)
		AND
		DB_ArenaMaster_WinFlags(_Arena,_Flag,_Clear)
		THEN
		UserSetFlag(_Char,_Flag);
		UserClearFlag(_Char,_Clear,0);
		
		
		PROC
		Proc_Arena_Win((STRING)_Team)
		AND
		DB_Arena_PlayerParticipants(_Arena,_Inst,_Char,_Team)
		AND
		DB_Arena_MobParticipants(_Inst,_,_,_)
		AND
		DB_Avatars(_Char)
		THEN
		Proc_Arena_SetChampionTag(_Char,_Arena);
		
		PROC
		Proc_Arena_Win((STRING)_Team)
		AND
		DB_Arena_PlayerParticipants(_Arena,_Inst,_Char,_Team)
		AND
		NOT DB_Arena_MobParticipants(_Inst,_,_,_)
		AND
		DB_Avatars(_Char)
		AND
		DB_Arena_PlayerParticipants(_Arena,_,_AnyChar,_)
		AND
		DB_ArenaChampionTag(_Arena,_Tag)
		AND
		IsTagged(_AnyChar,_Tag,1)
		THEN
		Proc_Arena_SetChampionTag((CHARACTERGUID)_Char,(STRING)_Arena);
		
		
		PROC
		Proc_Arena_SetChampionTag((CHARACTERGUID)_Player,(STRING)_Arena)
		AND
		DB_ArenaChampionTag(_Arena,_Tag)
		AND
		IsTagged(_Player,_Tag,0)
		THEN
		SetTag(_Player,_Tag);
		
		PROC
		Proc_Arena_SetChampionTag((CHARACTERGUID)_Player,(STRING)_Arena)
		AND
		DB_ArenaChampionTag(_Arena,_Tag)
		AND
		DB_IsPlayer(_Char)
		AND
		_Char != _Player
		THEN
		ClearTag(_Char,_Tag);
		
		PROC
		Proc_Arena_Win((STRING)_Team)
		AND
		DB_Arena_PlayerParticipants(_Arena,_,_Char,_Team)
		AND
		CharacterIsDead(_Char,1)
		AND
		DB_ArenaMaster_WinFlags(_Arena,_Clear,_Flag)
		AND
		UserGetFlag(_Char,_Clear,0)
		THEN
		UserSetFlag(_Char,_Flag);
		UserClearFlag(_Char,_Clear,0);
		
		
		PROC
		Proc_Arena_Win((STRING)_Team)
		AND
		DB_Arena_PlayerParticipants(_Arena,_,_Char,_OtherTeam)
		AND
		_OtherTeam!=_Team
		AND
		DB_ArenaMaster_WinFlags(_Arena,_Clear,_Flag)
		THEN
		UserSetFlag(_Char,_Flag);
		UserClearFlag(_Char,_Clear,0);
		
		PROC
		Proc_Arena_Win((STRING)_)
		AND
		DB_Arena_PreviousFaction(_Char,_Faction)
		THEN
		SetFaction(_Char,_Faction);
		//SetInArena(_Char,0);
		NOT DB_Arena_PreviousFaction(_Char,_Faction);
		
		PROC
		Proc_Arena_Win((STRING)_)
		AND
		GlobalGetFlag("Arnea_RingGirl_NoRingGirl",1)
		THEN
		Proc_Arena_Win_TeleportOut();
		
		PROC
		Proc_Arena_Win_TeleportOut()
		THEN
		GlobalClearFlag("Arena_RequestingLastManStanding");
		GlobalClearFlag("Arena_LastManStanding_AcceptWinner");
		GlobalClearFlag("Arena_LastManStanding_NoAccept");
		GlobalClearFlag("Arena_LastManStanding_Accept");
		
		PROC
		Proc_Arena_Win_TeleportOut()
		AND
		DB_Arena_PlayerParticipants(_,_,_Char,_)
		THEN
		CharacterRemoveSummons(_Char,1);
		RemoveHarmfulStatuses(_Char);
		CharacterSetHitpointsPercentage(_Char,100.0);
		ProcSetInvulnerable(_Char,0);
		DialogRequestStop(_Char);
		
		PROC
		Proc_Arena_Win_TeleportOut()
		//AND
		//GlobalGetFlag("Arnea_RingGirl_NoRingGirl",0)
		AND
		DB_Arena_PlayerParticipants(_,_,_Char,_)
		THEN
		FadeToBlack(_Char,2.0,1,"Placeholder");
		
		PROC
		Proc_Arena_Win_TeleportOut()
		THEN
		GlobalClearFlag("Arnea_RingGirl_NoRingGirl");
		
		PROC
		Proc_Arena_Win_TeleportOut() //TODO what happens if enemy wins
		AND
		DB_Arena_PlayerParticipants(_Arena,_,_Char,_)
		AND
		DB_ArenaMaster(_,_,_Arena,_TeleportTo)
		//AND
		//NOT DB_Arena_FightToTheDeath(_Arena)
		THEN
		SetInArena(_Char,0);
		CharacterSetSpectating(_Char,0);
		TeleportTo(_Char,_TeleportTo);
		CharacterFlushQueue(_Char);
		SetStoryEvent(_Char,"Arena_CharacterTeleportedOutOfArena");
		
		PROC
		Proc_Arena_Win_TeleportOut()
		AND
		DB_Arena_PlayerParticipants(_Arena,_,_Char,_)
		AND
		CharacterIsDead(_Char,1)
		AND
		NOT DB_Arena_FightToTheDeath(_Arena)
		THEN
		CharacterResurrectCustom(_Char,"");
		
		/* //TODO
		PROC
		Proc_Arena_Win_TeleportOut() //Do we revive enemies?
		AND
		DB_Arena_PreviousLocation(_Char,_X,_Y,_Z)
		AND
		CharacterIsDead(_Char,0)
		THEN
		SetInArena(_Char,0);
		CharacterSetSpectating(_Char,0);
		TeleportToPosition(_Char,_X,_Y,_Z,"",1);
		NOT DB_Arena_PreviousLocation(_Char,_X,_Y,_Z);
		*/
		PROC
		Proc_Arena_Win_TeleportOut() //Do we revive enemies?
		AND
		DB_Arena_PreviousLocation(_Char,_X,_Y,_Z)
		AND
		NOT DB_Arena_ReviveCharAfter(_Char)
		THEN
		NOT DB_Arena_PreviousLocation(_Char,_X,_Y,_Z);
		
		
		//End arena; Unless PVP
		PROC
		Proc_Arena_Win_TeleportOut()
		THEN
		Proc_Arena_Clear();
		
		//END_REGION
		
		//REGION Arena Girl
		
		
		PROC
		Proc_Arena_Win_RingGirl()
		AND
		DB_Arena_PlayerParticipants(_Arena,_,_,_)
		AND
		DB_ArenaMaster_RingGirl(_Char,_Dialog,_Arena,_Trig)
		AND
		GlobalGetFlag("Arnea_RingGirl_Initiated",0)
		THEN
		TeleportTo(_Char,_Trig);
		Foop(_Char);
		JumpToTurn(CHARACTERGUID_S_FTJ_RingGirl_Helper_2c6f3151-8d67-4af7-a4b7-e18b7c64ac94);
		GlobalSetFlag("Arnea_RingGirl_Initiated");
		SetInArena(_Char,1);
		SetStoryEvent(_Char,"Arnea_RingGirl_Appeared");
		//CharacterAppearAt(_Char,_Trig,1,"Arnea_RingGirl_Appeared");
		
		PROC
		Proc_Arena_Win_RingGirl()
		AND
		GlobalGetFlag("Arnea_RingGirl_Initiated",1)
		AND
		DB_Arena_PlayerParticipants(_,_,_Char,_)
		THEN
		CharacterSetSpectating(_Char,1);
		
		/* TEST! seems to work
		PROC
		Proc_Arena_Win_RingGirl()
		AND
		DB_Arena_PlayerParticipants(_Arena,_,_Char,_)
		AND
		NOT DB_ArenaMaster_RingGirl(_,_,_Arena,_)
		AND
		GlobalGetFlag("Arnea_RingGirl_NoRingGirl",0)
		THEN
		GlobalSetFlag("Arnea_RingGirl_NoRingGirl");
		DebugText(_Char,"No Arena Girl");
		*/
		
		/*
		PROC
		Proc_Arena_Win_RingGirl()
		AND
		GlobalGetFlag("Arnea_RingGirl_NoRingGirl",1)
		THEN
		GlobalClearFlag("Arnea_RingGirl_NoRingGirl");
		Proc_Arena_Win_TeleportOut();
		*/
		
		PROC
		Proc_Arena_Win_RingGirl()
		AND
		DB_Arena_PlayerParticipants(_Arena,_,_Char,_)
		AND
		NOT DB_ArenaMaster_RingGirl(_,_,_Arena,_)
		AND
		DB_Arena_CharIsAlive(_,_Char)
		THEN
		PlayAnimation(_Char,"Victory_01");
		FadeToBlack(_Char,2.0,0,"Placeholder");
		
		PROC
		Proc_Arena_Win_RingGirl()
		AND
		DB_Arena_PlayerParticipants(_Arena,_,_,_)
		AND
		NOT DB_ArenaMaster_RingGirl(_,_,_Arena,_)
		THEN
		TimerLaunch("Arena_PlayingVictoryAnimation",4000);
		
		IF
		TimerFinished("Arena_PlayingVictoryAnimation")
		THEN
		Proc_Arena_Win_TeleportOut();
		
		
		IF
		//ObjectTurnStarted(CHARACTERGUID_S_FTJ_RingGirl_Helper_2c6f3151-8d67-4af7-a4b7-e18b7c64ac94)
		StoryEvent((CHARACTERGUID)_,"Arnea_RingGirl_Appeared")
		AND
		DB_Arena_PlayerParticipants(_,_,_Char,_)
		THEN
		FadeToBlack(_Char,2.0,0,"Placeholder");
		
		
		IF
		//ObjectTurnStarted(CHARACTERGUID_S_FTJ_RingGirl_Helper_2c6f3151-8d67-4af7-a4b7-e18b7c64ac94)
		StoryEvent((CHARACTERGUID)_RingGirl,"Arnea_RingGirl_Appeared")
		AND
		DB_ArenaMaster_RingGirl(_RingGirl,_Dialog,_,_)
		THEN
		Proc_StartDialog(1,_Dialog,_RingGirl);
		
		IF
		AutomatedDialogEnded(_Dialog,_)
		AND
		DB_ArenaMaster_RingGirl(_Char,_Dialog,_,_)
		AND
		GlobalGetFlag("Arnea_RingGirl_Initiated",1)
		THEN
		GlobalClearFlag("Arnea_RingGirl_Initiated");
		SetInArena(_Char,0);
		Poof(_Char);
		Proc_Arena_Win_TeleportOut();
		
		
		
		//END_REGION
		
		
		
		//REGION Clear flags
		IF
		DialogEnded(_,_Inst)
		AND
		DB_ArenaMaster_SetUp(_Inst)
		AND
		GlobalGetFlag("Arena_StartAfterDialog",0)
		THEN
		Proc_Arena_ClearFlagsAndDatabases(_Inst);
		
		PROC
		Proc_Arena_ClearFlagsAndDatabases((INTEGER)_Inst)
		THEN
		NOT DB_Arena_PlayerParticipants_SameUser(1);
		GlobalClearFlag("Arena_CharNotInRegion");
		GlobalClearFlag("Arena_CharNotAvailable");
		GlobalClearFlag("Arena_StartAfterDialog");
		NOT DB_ArenaMaster_SetUp(_Inst);
		GlobalClearFlag("Arena_LastManStanding_NoAccept");
		GlobalClearFlag("Arena_LastManStanding_AcceptWinner");
		
		
		//Clearing after combat
		PROC
		Proc_Arena_Clear()
		THEN
		GlobalClearFlag("Arena_OnGoing");
		NOT DB_Arena_PlayerParticipants_SameUser(1);
		
		PROC
		Proc_Arena_Clear()
		AND
		DB_Arena_CharIsAlive(_Team,_Char)
		THEN
		NOT DB_Arena_CharIsAlive(_Team,_Char);
		
		PROC
		Proc_Arena_Clear()
		AND
		DB_Arena_CharWasAlive(_Team,_Char)
		THEN
		NOT DB_Arena_CharWasAlive(_Team,_Char);
		
		PROC
		Proc_Arena_Clear()
		AND
		DB_Arena_MobParticipants(_Inst,_Char,_Trig,_Team)
		THEN
		NOT DB_Arena_MobParticipants(_Inst,_Char,_Trig,_Team);
		
		PROC
		Proc_Arena_Clear()
		AND
		DB_Arena_PlayerParticipants(_Arena,_Inst,_Char,_Team)
		THEN
		NOT DB_Arena_PlayerParticipants(_Arena,_Inst,_Char,_Team);
		
		PROC
		Proc_Arena_Clear()
		AND
		DB_Arena_LastManStandingTeams(_Char,_OtherId,_OtherTeam)
		THEN
		NOT DB_Arena_LastManStandingTeams(_Char,_OtherId,_OtherTeam);
		
		//Clearing Player checks
		IF
		DialogEnded(_Dialog,_)
		AND
		DB_ArenaMaster(_,_Dialog,_,_)
		THEN
		Proc_Arena_ClearPlayerCheck();
		
		PROC
		Proc_Arena_ClearPlayerCheck()
		AND
		DB_Arena_PvpChallenge(_Char,_Target)
		THEN
		NOT DB_Arena_PvpChallenge(_Char,_Target);
		
		PROC
		Proc_Arena_ClearPlayerCheck()
		AND
		DB_Arena_AvailablePlayer(_Flag,_Char,_User)
		THEN
		NOT DB_Arena_AvailablePlayer(_Flag,_Char,_User);
		DebugText(_Char,"Proc_Arena_ClearPlayerCheck");
		
		PROC
		Proc_Arena_ClearPlayerCheck()
		AND
		DB_IsPlayer(_Char)
		THEN
		ObjectClearFlag(_Char,"Arena_ChallengePlayer_1");
		ObjectClearFlag(_Char,"Arena_ChallengePlayer_2");
		ObjectClearFlag(_Char,"Arena_ChallengePlayer_3");
		ObjectClearFlag(_Char,"Arena_ChallengePlayer_4");
		
		PROC
		Proc_Arena_ClearPlayerCheck()
		AND
		DB_Arena_CheckOtherPlayers_Count(_Int)
		THEN
		NOT DB_Arena_CheckOtherPlayers_Count(_Int);
		
		PROC
		Proc_Arena_ClearPlayerCheck()
		THEN
		GlobalClearFlag("ArenaDialog_SinglePlayer");
		GlobalClearFlag("Arena_AvailablePlayer_1");
		
		//END_REGION
		
		
		//flag character if she fought in an arena
		PROC
		Proc_Arena_Initiate((INTEGER)_Inst)
		AND
		DB_Arena_PlayerParticipants(_,_Inst,_Char,_)
		AND
		ObjectGetFlag(_Char,"Arena_CharacterFoughtInArena",0)
		THEN
		ObjectSetFlag(_Char,"Arena_CharacterFoughtInArena");
		
		PROC
		Proc_Arena_Initiate((INTEGER)_Inst)
		AND
		DB_Arena_PlayerParticipants(_Arena,_Inst,_Char,_)
		AND
		StringConcatenate("Arena_CharacterFoughtIn_",_Arena,_String)
		AND
		ObjectGetFlag(_Char,_String,0)
		THEN
		ObjectSetFlag(_Char,_String);
		
		PROC
		Proc_Arena_Initiate((INTEGER)_Inst)
		AND
		DB_Arena_PlayerParticipants(_Arena,_,_Char,_)
		AND
		ObjectGetFlag(_Char,"Arena_CharacterFoughtIn_Driftwood",0)
		AND
		StringContains(_Arena,"Driftwood",1)
		THEN 
		ObjectSetFlag(_Char,"Arena_CharacterFoughtIn_Driftwood");
		
		
		
		//REGION save games and drop outs
		IF 
		SavegameLoaded(_,_,_,_)
		AND
		DB_Arena_PlayerParticipants(_,_,_,_)
		THEN
		Proc_ArenaSavegameLoaded_CheckForPvpPlayers();
		
		PROC
		Proc_ArenaSavegameLoaded_CheckForPvpPlayers()
		AND
		DB_Arena_PlayerParticipants(_Arena,_Inst,_CharA,_TeamA)
		AND
		DB_Arena_PlayerParticipants(_Arena,_Inst,_CharB,_TeamB)
		AND
		_TeamA != _TeamB
		AND
		_CharA != _CharB
		AND
		CharacterGetReservedUserID(_CharA,_User)
		AND
		CharacterGetReservedUserID(_CharB,_User)
		THEN
		Proc_ArenaSavegameLoaded_CheckForPvpPlayers_MergeTeam(_CharA,_CharB);
		
		PROC
		Proc_ArenaSavegameLoaded_CheckForPvpPlayers_MergeTeam((CHARACTERGUID)_CharA,(CHARACTERGUID)_CharB)
		AND
		DB_Arena_PlayerParticipants(_Arena,_Inst,_CharA,_TeamA)
		AND
		DB_Arena_PlayerParticipants(_Arena,_Inst,_CharB,_TeamB)
		THEN
		NOT DB_Arena_PlayerParticipants(_Arena,_Inst,_CharB,_TeamB);
		DB_Arena_PlayerParticipants(_Arena,_Inst,_CharB,_TeamA);
		
		
		PROC
		Proc_ArenaSavegameLoaded_CheckForPvpPlayers_MergeTeam((CHARACTERGUID)_,(CHARACTERGUID)_CharB)
		AND
		DB_Arena_PlayerParticipants(_Arena,_Inst,_CharB,_Team)
		AND
		DB_Arena_CharIsAlive(_OldTeam,_CharB)
		THEN
		NOT DB_Arena_CharIsAlive(_OldTeam,_CharB);
		DB_Arena_CharIsAlive(_Team,_CharB);
		
		PROC
		Proc_ArenaSavegameLoaded_CheckForPvpPlayers_MergeTeam(_,_)
		AND
		DB_Arena_LastManStandingTeams(_Char,_Id,_Team)
		THEN
		NOT DB_Arena_LastManStandingTeams(_Char,_Id,_Team);
		
		PROC
		Proc_ArenaSavegameLoaded_CheckForPvpPlayers()
		THEN
		Proc_Arena_CheckWinCondition();
		
		IF
		UserDisconnected(_User,_,_)
		AND
		DB_Arena_PlayerParticipants(_,_,_,_)
		THEN 
		Proc_ArenaSavegameLoaded_CheckForPvpPlayers();
		//END_REGION
		
		
		//REGION global blindfolds
		IF
		ItemTemplateEquipped("EQ_Clothing_UNIQUE_Blindfolds_A_60884e3d-45cb-4849-b35e-d24064386b9f",_Char)
		THEN
		ApplyStatus(_Char,"PERMANENT_BLIND",-1.0,1);
		
		IF
		CharacterStatusRemoved(_Char,"PERMANENT_BLIND",_)
		AND
		GetItemForItemTemplateInInventory(_Char,"EQ_Clothing_UNIQUE_Blindfolds_A_60884e3d-45cb-4849-b35e-d24064386b9f",_Item)
		AND
		CharacterGetEquippedItem(_Char,"Helmet",_Item)
		AND
		HasActiveStatus(_Char,"PERMANENT_BLIND",0)
		THEN
		ApplyStatus(_Char,"PERMANENT_BLIND",-1.0,1);
		
		IF
		CharacterResurrected(_Char)
		AND
		GetItemForItemTemplateInInventory(_Char,"EQ_Clothing_UNIQUE_Blindfolds_A_60884e3d-45cb-4849-b35e-d24064386b9f",_Item)
		AND
		CharacterGetEquippedItem(_Char,"Helmet",_Item)
		THEN
		ApplyStatus(_Char,"PERMANENT_BLIND",-1.0,1);
		
		IF
		ItemTemplateUnEquipped("EQ_Clothing_UNIQUE_Blindfolds_A_60884e3d-45cb-4849-b35e-d24064386b9f",_Char)
		THEN
		RemoveStatus(_Char,"PERMANENT_BLIND");
		
		//END_REGION
		
		
		//REGION set tag
		
		//END_REGION
		
		//REGION 
		IF
		CharacterReservedUserIDChanged(_Char,_,_User)
		AND
		DB_Arena_PlayerParticipants(_,_,_Char,_)
		AND
		GlobalGetFlag("Arena_RequestingLastManStanding",0)
		THEN
		Proc_Arena_PVP_Reassigned(_User,_Char);
		
		PROC
		Proc_Arena_PVP_Reassigned((INTEGER)_User,(CHARACTERGUID)_Char)
		AND
		DB_Arena_PlayerParticipants(_Arena,_Inst,_Char,_Team)
		AND
		DB_IsPlayer(_OtherChar)
		AND
		_Char != _OtherChar
		AND
		CharacterGetReservedUserID(_OtherChar,_User)
		AND
		DB_Arena_PlayerParticipants(_Arena,_Inst,_OtherChar,_OtherTeam)
		AND
		_Team != _OtherTeam
		THEN
		NOT DB_Arena_PlayerParticipants(_Arena,_Inst,_Char,_Team);
		DB_Arena_PlayerParticipants(_Arena,_Inst,_Char,_OtherTeam);
		SetFaction(_Char,_OtherTeam);
		
		PROC
		Proc_Arena_PVP_Reassigned((INTEGER)_User,(CHARACTERGUID)_Char)
		AND
		DB_Arena_PlayerParticipants(_Arena,_Inst,_Char,_Team)
		AND
		DB_Arena_CharIsAlive(_CheckTeam,_Char)
		AND
		_CheckTeam != _Team
		THEN
		NOT DB_Arena_CharIsAlive(_CheckTeam,_Char);
		DB_Arena_CharIsAlive(_Team,_Char);
		
		PROC
		Proc_Arena_PVP_Reassigned(_,_)
		THEN
		Proc_Arena_CheckWinCondition();
		
		//END_REGION
		
	}
	EXIT
	{
		
	}
}
Goal(55).Title("GLO_Arena_LMS");
Goal(55)
{
	INIT
	{
		DB_LastManStandingTeamList("PVP_1");
		DB_LastManStandingTeamList("PVP_2");
		DB_LastManStandingTeamList("PVP_3");
		DB_LastManStandingTeamList("PVP_4");
		
		
	}
	KB
	{
		PROC
		Proc_Arena_CheckWinCondition_CheckForLMS()
		AND
		DB_Arena_PlayerParticipants(_Arena,_Inst,_Char,_Team)
		AND
		IsTagged(_Char,"AVATAR",1)
		AND
		CharacterGetReservedUserID(_Char,_User)
		AND
		DB_Arena_PlayerParticipants(_Arena,_Inst,_UserCharacters,_Team)
		AND
		CharacterGetReservedUserID(_UserCharacters,_User)
		AND
		CharacterIsDead(_UserCharacters,0)
		AND
		DB_Arena_PlayerParticipants(_Arena,_Inst,_OtherChar,_Team)
		AND
		IsTagged(_OtherChar,"AVATAR",1)
		AND
		CharacterGetReservedUserID(_OtherChar,_OtherUser)
		AND
		_OtherUser != _User
		AND
		DB_Arena_PlayerParticipants(_Arena,_Inst,_OtherUserCharacters,_Team)
		AND
		CharacterGetReservedUserID(_OtherUserCharacters,_OtherUser)
		AND
		CharacterIsDead(_OtherUserCharacters,0)
		AND
		GlobalGetFlag("Arena_RequestingLastManStanding",0)
		THEN
		GlobalSetFlag("Arena_RequestingLastManStanding");
		Proc_Arena_SetUp_LastManStanding_InitiateDialog_1();
		
		PROC
		Proc_Arena_SetUp_LastManStanding_InitiateDialog_1()
		AND
		DB_Arena_PlayerParticipants(_,_,_Char,_)
		AND
		ObjectGetFlag(_Char,"Arena_LastManStanding_Accept",1)
		THEN
		ObjectClearFlag(_Char,"Arena_LastManStanding_Accept");
		
		PROC
		Proc_Arena_SetUp_LastManStanding_InitiateDialog_1()
		AND
		DB_IsPlayer(_Char)
		THEN
		UserClearFlag(_Char,"ArenaLMS_HasAvatar",0);
		UserClearFlag(_Char,"ArenaLMS_AvatarIsDead",0);
		
		
		PROC
		Proc_Arena_SetUp_LastManStanding_InitiateDialog_1()
		AND
		DB_LastManStanding_InitiateDialog_Count(_Int)
		THEN
		NOT DB_LastManStanding_InitiateDialog_Count(_Int);
		
		PROC
		Proc_Arena_SetUp_LastManStanding_InitiateDialog_1()
		THEN
		DB_LastManStanding_InitiateDialog_Count(1);
		
		PROC
		Proc_Arena_SetUp_LastManStanding_InitiateDialog_1()
		AND
		DB_LastManStanding_InitiateDialog_Speaker(_Count,_Char)
		THEN
		NOT DB_LastManStanding_InitiateDialog_Speaker(_Count,_Char);
		
		PROC
		Proc_Arena_SetUp_LastManStanding_InitiateDialog_1()
		THEN
		DB_LastManStanding_InitiateDialog_Speaker(2,NULL_00000000-0000-0000-0000-000000000000);
		DB_LastManStanding_InitiateDialog_Speaker(3,NULL_00000000-0000-0000-0000-000000000000);
		DB_LastManStanding_InitiateDialog_Speaker(4,NULL_00000000-0000-0000-0000-000000000000);
		DB_LastManStanding_InitiateDialog_Speaker(5,NULL_00000000-0000-0000-0000-000000000000);
		
		PROC
		Proc_Arena_SetUp_LastManStanding_InitiateDialog_1()
		AND
		DB_Arena_PlayerParticipants(_,_,_Char,_)
		AND
		IsTagged(_Char,"AVATAR",1)
		THEN
		UserSetFlag(_Char,"ArenaLMS_HasAvatar");
		
		PROC
		Proc_Arena_SetUp_LastManStanding_InitiateDialog_1()
		AND
		DB_Arena_PlayerParticipants(_,_,_Char,_)
		AND
		IsTagged(_Char,"AVATAR",1)
		AND
		CharacterIsDead(_Char,1)
		THEN
		UserSetFlag(_Char,"ArenaLMS_AvatarIsDead");
		
		PROC
		Proc_Arena_SetUp_LastManStanding_InitiateDialog_1()
		AND
		DB_Arena_PlayerParticipants(_,_,_Char,_)
		AND
		CharacterIsDead(_Char,0)
		AND
		DB_LastManStanding_InitiateDialog_Count(_Count)
		AND
		IntegerSum(_Count,1,_NewCount)
		THEN
		UserClearFlag(_Char,"ArenaLMS_UserMadeDecision",0);
		DB_LastManStanding_InitiateDialog_Speaker(_NewCount,_Char);
		NOT DB_LastManStanding_InitiateDialog_Speaker(_NewCount,NULL_00000000-0000-0000-0000-000000000000);
		NOT DB_LastManStanding_InitiateDialog_Count(_Count);
		DB_LastManStanding_InitiateDialog_Count(_NewCount);
		
		PROC
		ProcForceLeaveCombat((CHARACTERGUID)_Char)
		THEN
		LeaveCombat(_Char);
		
		PROC
		ProcForceLeaveCombat((CHARACTERGUID)_Char)
		AND
		DB_CombatCharacters(_Char,_ID)
		THEN
		NOT DB_CombatCharacters(_Char,_ID);
		
		PROC
		ProcForceLeaveCombat((CHARACTERGUID)_Char)
		AND
		DB_CombatObjects(_Char,_ID)
		THEN
		NOT DB_CombatObjects(_Char,_ID);
		
		
		PROC
		Proc_Arena_SetUp_LastManStanding_InitiateDialog_1()
		AND
		DB_Arena_PlayerParticipants(_,_,_Char,_)
		THEN
		ProcForceLeaveCombat(_Char);
		
		PROC
		Proc_Arena_SetUp_LastManStanding_InitiateDialog_1()
		AND
		DB_LastManStanding_InitiateDialog_Speaker(_,_Char)
		THEN
		RemoveStatus(_Char,"CHARMED");
		
		PROC
		Proc_Arena_SetUp_LastManStanding_InitiateDialog_1()
		AND
		DB_Arena_PlayerParticipants(_Arena,_,_,_)
		AND
		DB_ArenaMaster(_Speaker1,_Dialog,_Arena,_)
		AND
		StringConcatenate(_Dialog,"_LastManStanding",(STRING)_NewDialog)
		AND
		DB_LastManStanding_InitiateDialog_Speaker(2,_Speaker2)
		AND
		DB_LastManStanding_InitiateDialog_Speaker(3,_Speaker3)
		AND
		DB_LastManStanding_InitiateDialog_Speaker(4,_Speaker4)
		AND
		DB_LastManStanding_InitiateDialog_Speaker(5,_Speaker5)
		AND
		QRY_StartDialog(0,_NewDialog,_Speaker1,_Speaker2,_Speaker3,_Speaker4,_Speaker5)
		THEN
		DB_NOOP(1);
		
		
		IF
		GlobalFlagSet("Arena_LastManStanding_CheckDialogResults")
		THEN
		Proc_Arena_SetUp_CheckDialogResults();
		GlobalClearFlag("Arena_LastManStanding_CheckDialogResults");
		
		PROC
		Proc_Arena_SetUp_CheckDialogResults()
		THEN
		GlobalClearFlag("Arena_LastManStanding_NoAccept");
		GlobalClearFlag("Arena_LastManStanding_AcceptWinner");
		
		PROC
		Proc_Arena_SetUp_CheckDialogResults()
		AND
		DB_Arena_LastManStanding_AcceptCount(_Count)
		THEN
		NOT DB_Arena_LastManStanding_AcceptCount(_Count);
		
		PROC
		Proc_Arena_SetUp_CheckDialogResults()
		THEN
		DB_Arena_LastManStanding_AcceptCount(0);
		
		PROC
		Proc_Arena_SetUp_CheckDialogResults()
		AND
		DB_Arena_PlayerParticipants(_,_,_Char,_)
		AND
		ObjectGetFlag(_Char,"Arena_LastManStanding_Accept",1)
		AND
		DB_Arena_LastManStanding_AcceptCount(_Count)
		AND
		IntegerSum(_Count,1,_NewCount)
		THEN
		NOT DB_Arena_LastManStanding_AcceptCount(_Count);
		DB_Arena_LastManStanding_AcceptCount(_NewCount);
		
		PROC
		Proc_Arena_SetUp_CheckDialogResults()
		AND
		DB_Arena_LastManStanding_AcceptCount(0)
		THEN
		GlobalSetFlag("Arena_LastManStanding_NoAccept");
		GlobalClearFlag("Arena_RequestingLastManStanding");
		
		PROC
		Proc_Arena_SetUp_CheckDialogResults()
		AND
		DB_Arena_LastManStanding_AcceptCount(1)
		AND
		DB_Arena_PlayerParticipants(_,_,_Char,_)
		AND
		ObjectGetFlag(_Char,"Arena_LastManStanding_Accept",1)
		THEN
		GlobalSetFlag("Arena_LastManStanding_AcceptWinner");
		GlobalClearFlag("Arena_RequestingLastManStanding");
		
		//REGION
		IF
		DialogEnded(_Dialog,_Inst)
		AND
		GlobalGetFlag("Arena_RequestingLastManStanding",1)
		AND
		DB_ArenaMaster(_,_ArenaDialog,_Arena,_)
		AND
		StringContains(_Dialog,_ArenaDialog,1)
		AND
		DB_Arena_PlayerParticipants(_Arena,_,_,_)
		THEN
		Proc_Arena_SetUp_LastManStanding_1();
		
		IF
		DialogEnded(_Dialog,_Inst)
		AND
		GlobalGetFlag("Arena_LastManStanding_AcceptWinner",1)
		AND
		DB_ArenaMaster(_,_ArenaDialog,_Arena,_)
		AND
		StringContains(_Dialog,_ArenaDialog,1)
		AND
		DB_Arena_PlayerParticipants(_Arena,_,_,_)
		THEN
		Proc_Arena_LastManStanding_SetDialogWinner();
		GlobalClearFlag("Arena_LastManStanding_AcceptWinner");
		
		IF
		DialogEnded(_Dialog,_Inst)
		AND
		GlobalGetFlag("Arena_LastManStanding_NoAccept",1)
		AND
		DB_ArenaMaster(_,_ArenaDialog,_Arena,_)
		AND
		StringContains(_Dialog,_ArenaDialog,1)
		AND
		DB_Arena_PlayerParticipants(_Arena,_,_,_)
		THEN
		Proc_Arena_LastManStanding_SetDialogWinner();
		
		PROC
		Proc_Arena_LastManStanding_SetDialogWinner()
		AND
		DB_Arena_PlayerParticipants(_Arena,_Id,_Char,_Team)
		THEN
		NOT DB_Arena_PlayerParticipants(_Arena,_Id,_Char,_Team);
		DB_Arena_PlayerParticipants(_Arena,_Id,_Char,"Arena_TeamB");
		
		PROC
		Proc_Arena_LastManStanding_SetDialogWinner()
		AND
		DB_Arena_PlayerParticipants(_,_,_Char,_)
		AND
		ObjectGetFlag(_Char,"Arena_LastManStanding_Accept",1)
		AND
		CharacterGetReservedUserID(_Char,_User)
		AND
		DB_Arena_PlayerParticipants(_Arena,_Id,_AnyChar,_Team)
		AND
		CharacterGetReservedUserID(_AnyChar,_User)
		THEN
		NOT DB_Arena_PlayerParticipants(_Arena,_Id,_AnyChar,_Team);
		DB_Arena_PlayerParticipants(_Arena,_Id,_AnyChar,"Arena_TeamA");
		
		PROC
		Proc_Arena_LastManStanding_SetDialogWinner()
		THEN
		Proc_Arena_Win("Arena_TeamA");
		
		//END_REGION
		
		//REGION initiate last man standing
		PROC
		Proc_Arena_SetUp_LastManStanding_1()
		AND
		DB_Arena_PlayerParticipants(_,_,_Char,_)
		AND
		UserGetFlag(_Char,"Arena_LastManStanding_Accept",0)
		AND
		CharacterGetReservedUserID(_Char,_User)
		AND
		DB_Arena_PlayerParticipants(_,_,_AnyChar,_)
		AND
		CharacterGetReservedUserID(_AnyChar,_User)
		THEN
		Proc_Arena_SetUp_LastManStanding_RemoveChar(_AnyChar);
		//CharacterDie(_AnyChar,0,"Explode");
		
		PROC 
		Proc_Arena_SetUp_LastManStanding_RemoveChar((CHARACTERGUID)_Char)
		AND
		DB_Arena_PlayerParticipants(_,_,_Char,_)
		AND
		CharacterIsDead(_Char,1)
		THEN
		CharacterResurrectCustom(_Char,"");
		
		PROC //Wait for Ring Girl
		Proc_Arena_SetUp_LastManStanding_RemoveChar((CHARACTERGUID)_Char)
		AND
		DB_Arena_PlayerParticipants(_,_,_Char,_)
		THEN
		RemoveHarmfulStatuses(_Char);
		
		PROC
		Proc_Arena_SetUp_LastManStanding_RemoveChar((CHARACTERGUID)_Char)
		AND
		DB_Arena_PlayerParticipants(_Arena,_,_Char,_)
		AND
		DB_ArenaMaster(_,_,_Arena,_TeleportTo)
		THEN
		FadeToBlack(_Char,2.0,1,"Placeholder");
		SetInArena(_Char,0);
		CharacterSetSpectating(_Char,0);
		TeleportTo(_Char,_TeleportTo);
		
		PROC
		Proc_Arena_SetUp_LastManStanding_RemoveChar((CHARACTERGUID)_Char)
		AND
		DB_Arena_CharIsAlive(_Team,_Char)
		THEN
		NOT DB_Arena_CharIsAlive(_Team,_Char);
		
		PROC
		Proc_Arena_SetUp_LastManStanding_RemoveChar((CHARACTERGUID)_Char)
		AND
		DB_Arena_PlayerParticipants(_Arena,_Inst,_Char,_Team)
		THEN
		NOT DB_Arena_PlayerParticipants(_Arena,_Inst,_Char,_Team);
		
		PROC
		Proc_Arena_SetUp_LastManStanding_RemoveChar((CHARACTERGUID)_Char)
		AND
		DB_Arena_PreviousFaction(_Char,_Faction)
		THEN
		SetFaction(_Char,_Faction);
		NOT DB_Arena_PreviousFaction(_Char,_Faction);
		
		
		PROC
		Proc_Arena_SetUp_LastManStanding_1()
		THEN
		Proc_Arena_SetUp_LastManStanding_2();
		
		PROC
		Proc_Arena_SetUp_LastManStanding_2()
		AND
		DB_Arena_PlayerParticipants(_,_,_Char,_)
		AND
		CharacterIsDead(_Char,0)
		AND
		CharacterGetReservedUserID(_Char,_User)
		AND
		GetUserProfileID(_User,_Id)
		AND
		DB_LastManStandingTeamList(_Team)
		AND
		NOT DB_Arena_LastManStandingTeams(_,_,_Team)
		AND
		NOT DB_Arena_LastManStandingTeams(_,_Id,_)
		AND
		NOT DB_Arena_LastManStandingTeams(_Char,_,_)
		THEN
		DB_Arena_LastManStandingTeams(_Char,_Id,_Team);
		
		PROC
		Proc_Arena_SetUp_LastManStanding_2()
		AND
		DB_Arena_PlayerParticipants(_,_,_Char,_)
		AND
		CharacterGetReservedUserID(_Char,_User)
		AND
		GetUserProfileID(_User,_Id)
		AND
		DB_Arena_LastManStandingTeams(_,_Id,_Team)
		AND
		NOT DB_Arena_LastManStandingTeams(_Char,_,_)
		THEN
		DB_Arena_LastManStandingTeams(_Char,_Id,_Team);
		
		PROC
		Proc_Arena_SetUp_LastManStanding_1()
		AND
		DB_Arena_LastManStandingTeams(_Char,_,_Team)
		THEN
		SetFaction(_Char,_Team);
		
		//END_REGION
		
		//REGION win conditions
		IF
		CharacterDying(_Char)
		AND
		GlobalGetFlag("Arena_RequestingLastManStanding",1)
		AND
		DB_Arena_LastManStandingTeams(_Char,_User,_Team)
		THEN
		NOT DB_Arena_LastManStandingTeams(_Char,_User,_Team);
		Proc_Arena_LastManStanding_CheckWinCondition();
		
		IF
		CharacterResurrected(_Char)
		AND
		GlobalGetFlag("Arena_RequestingLastManStanding",1)
		AND
		CharacterGetReservedUserID(_Char,_User)
		AND
		GetUserProfileID(_User,_Id)
		AND
		DB_Arena_LastManStandingTeams(_,_Id,_Team)
		AND 
		NOT DB_Arena_LastManStandingTeams(_Char,_,_)
		THEN
		DB_Arena_LastManStandingTeams(_Char,_Id,_Team);
		
		
		PROC
		Proc_Arena_LastManStanding_CheckWinCondition()
		THEN
		NOT DB_Arena_LastManStanding_NoWin(1);
		
		PROC
		Proc_Arena_LastManStanding_CheckWinCondition()
		AND
		DB_Arena_LastManStandingTeams(_,_,_User)
		AND
		DB_Arena_LastManStandingTeams(_,_,_OtherUser)
		AND
		_User != _OtherUser
		THEN
		DB_Arena_LastManStanding_NoWin(1);
		
		PROC
		Proc_Arena_LastManStanding_CheckWinCondition()
		AND
		NOT DB_Arena_LastManStanding_NoWin(1)
		THEN
		Proc_Arena_LastManStanding_SetWinState();
		
		PROC
		Proc_Arena_LastManStanding_SetWinState()
		AND
		DB_Arena_PlayerParticipants(_Arena,_ArenaID,_Char,_Team)
		AND
		CharacterGetReservedUserID(_Char,_User)
		AND
		GetUserProfileID(_User,_ProfileId)
		AND
		DB_Arena_LastManStandingTeams(_,_ProfileId,_)
		THEN
		NOT DB_Arena_PlayerParticipants(_Arena,_ArenaID,_Char,_Team);
		DB_Arena_PlayerParticipants(_Arena,_ArenaID,_Char,"Arena_TeamA");
		
		PROC
		Proc_Arena_LastManStanding_SetWinState()
		AND
		DB_Arena_PlayerParticipants(_Arena,_ID,_Char,_Team)
		AND
		CharacterGetReservedUserID(_Char,_User)
		AND
		GetUserProfileID(_User,_ProfileId)
		AND
		DB_Arena_LastManStandingTeams(_,_OtherProfileId,_)
		AND
		_ProfileId != _OtherProfileId
		THEN
		NOT DB_Arena_PlayerParticipants(_Arena,_ID,_Char,_Team);
		DB_Arena_PlayerParticipants(_Arena,_ID,_Char,"Arena_TeamB");
		
		PROC
		Proc_Arena_LastManStanding_SetWinState()
		THEN
		Proc_Arena_Win("Arena_TeamA");
		GlobalClearFlag("Arena_RequestingLastManStanding");
		
		PROC
		Proc_Arena_Clear()
		AND
		DB_IsPlayer(_Char)
		THEN
		ObjectClearFlag(_Char,"Arena_LastManStanding_Accept",0);
		//END_REGION
		
		//REGION
		IF
		CharacterReservedUserIDChanged(_Char,_,_User)
		AND
		GlobalGetFlag("Arena_RequestingLastManStanding",1)
		THEN
		Proc_Arena_LastManStandingTeams_Reassigned(_User,_Char);
		
		PROC
		Proc_Arena_LastManStandingTeams_Reassigned((INTEGER)_User,(CHARACTERGUID)_Char)
		AND
		GetUserProfileID(_User,_Id)
		AND
		DB_Arena_LastManStandingTeams(_,_Id,_Team)
		AND
		DB_Arena_LastManStandingTeams(_Char,_OtherId,_OtherTeam)
		THEN
		NOT DB_Arena_LastManStandingTeams(_Char,_OtherId,_OtherTeam);
		DB_Arena_LastManStandingTeams(_Char,_Id,_Team);
		SetFaction(_Char,_Team);
		
		PROC
		Proc_Arena_LastManStandingTeams_Reassigned((INTEGER)_User,(CHARACTERGUID)_Char)
		AND
		DB_Arena_LastManStandingTeams(_Char,_OtherId,_Team)
		AND
		GetUserProfileID(_User,_Id)
		AND
		NOT DB_Arena_LastManStandingTeams(_,_Id,_)
		THEN
		NOT DB_Arena_LastManStandingTeams(_Char,_OtherId,_Team);
		DB_Arena_LastManStandingTeams(_Char,_Id,_Team);
		//SetFaction(_Char,_Team);
		
		
		PROC
		Proc_Arena_LastManStandingTeams_Reassigned(_,_Char)
		AND
		DB_Arena_LastManStandingTeams(_Char,_,_)
		THEN
		Proc_Arena_LastManStanding_CheckWinCondition();
		
		//END_REGION
		
	}
	EXIT
	{
		
	}
}
Goal(56).Title("GLO_BidirShovelTunnel");
Goal(56)
{
	INIT
	{
		// Support for a bidirectional tunnel that can be opened up from either side by shovelling
		// Usage:
		//  DB_BidirShovelPileTunnel(IDString,Side1ShovelTrigger,Side1ShovelPileObject,Side1TunnelEntranceObject,Side2ShovelTrigger,Side2ShovelPileObject,Side2TunnelEntranceObject);
		//
		// As soon as one side is opened up, so is the other side. Can't easily use simply two shovel
		// piles with the same ID, because then the dirt pile on the other side won't be removed. Also
		// avoids conflicts in case people shovel on both sides at the same time.
		//
		// When the tunnel is opened on side 1/2, ProcBidirShovelTunnelOpenedOnSide(1/2) is called
		// (only one of these will be called per tunnel)
		
	}
	KB
	{
		//REGION Convert tunnel into two shovel areas
		IF
		DB_BidirShovelPileTunnel((STRING)_IDString,(TRIGGERGUID)_Side1ShovelTrigger,(ITEMGUID)_Side1ShovelPileObject,(ITEMGUID)_Side1TunnelEntranceObject,(TRIGGERGUID)_Side2ShovelTrigger,(ITEMGUID)_Side2ShovelPileObject,(ITEMGUID)_Side2TunnelEntranceObject)
		AND
		StringConcatenate(_IDString,"___side1",_Side1IDString)
		AND
		StringConcatenate(_IDString,"___side2",_Side2IDString)
		THEN
		DB_BidirShovelTunnelExit(_IDString,_Side1IDString);
		DB_BidirShovelTunnelExit(_IDString,_Side2IDString);
		DB_ShovelArea((TRIGGERGUID)_Side1ShovelTrigger,(STRING)_Side1IDString,(ITEMGUID)_Side1ShovelPileObject);
		DB_ShovelArea((TRIGGERGUID)_Side2ShovelTrigger,(STRING)_Side2IDString,(ITEMGUID)_Side2ShovelPileObject);
		DB_ShovelRewardItemSpawn((STRING)_Side1IDString,(ITEMGUID)_Side1TunnelEntranceObject);
		DB_ShovelRewardItemSpawn((STRING)_Side2IDString,(ITEMGUID)_Side2TunnelEntranceObject);
		//END_REGION
		
		//REGION User hooks
		PROC
		ProcBidirShovelTunnelOpenedOnSide((CHARACTERGUID)_,(STRING)_,(INTEGER)_)
		THEN
		DB_NOOP(1);
		
		PROC
		ProcShovelRewards(_Player,_ThisSideIDString)
		AND
		DB_BidirShovelTunnelExit(_IDString,_ThisSideIDString)
		AND
		StringContains(_ThisSideIDString,"__side1",1)
		THEN
		ProcBidirShovelTunnelOpenedOnSide(_Player,_IDString,1);
		
		PROC
		ProcShovelRewards(_Player,_ThisSideIDString)
		AND
		DB_BidirShovelTunnelExit(_IDString,_ThisSideIDString)
		AND
		StringContains(_ThisSideIDString,"__side2",1)
		THEN
		ProcBidirShovelTunnelOpenedOnSide(_Player,_IDString,2);
		//END_REGION
		
		//REGION If one side is opened up, open the other one too
		PROC
		PROC_ShovelTunnelOpenUpOtherSide((CHARACTERGUID)_Player, (STRING)_IDString)
		AND
		DB_BidirShovelTunnelExit(_IDString,_OtherSideIDString)
		AND
		DB_ShovelArea(_OtherTrigger,_OtherSideIDString,_OtherPileObject)
		AND
		// avoid issues if someone is digging up the other side at the same time
		NOT DB_Shovelling_Mound(_,_OtherPileObject)
		THEN
		NOT DB_BidirShovelTunnelExit(_IDString,_OtherSideIDString);
		SetOnStage(_OtherPileObject,0);
		NOT DB_ShovelArea(_OtherTrigger,_OtherSideIDString,_OtherPileObject);
		// Won't trigger code below again, because all DB_BidirShovelTunnelExit() for this _IDString have been cleared
		ProcShovelRewards(_Player,_OtherSideIDString);
		
		PROC
		ProcShovelRewards(_Player,_ThisSideIDString)
		AND
		DB_BidirShovelTunnelExit(_IDString,_ThisSideIDString)
		AND
		DB_BidirShovelPileTunnel(_IDString,_Side1ShovelTrigger,_Side1ShovelPileObject,_Side1TunnelEntranceObject,_Side2ShovelTrigger,_Side2ShovelPileObject,_Side2TunnelEntranceObject)
		THEN
		NOT DB_BidirShovelTunnelExit(_IDString,_ThisSideIDString);
		// Only DB_BidirShovelTunnelExit(_IDString,_) definition left now is for the other side
		PROC_ShovelTunnelOpenUpOtherSide(_Player,_IDString);
		NOT DB_BidirShovelPileTunnel(_IDString,_Side1ShovelTrigger,_Side1ShovelPileObject,_Side1TunnelEntranceObject,_Side2ShovelTrigger,_Side2ShovelPileObject,_Side2TunnelEntranceObject);
		
		//END_REGION
		
	}
	EXIT
	{
		
	}
}
Goal(57).Title("GLO_Checkpoints");
Goal(57)
{
	INIT
	{
		/* Uses the databases
		DB_CheckPoint(_Guard1, _Guard2, _Trigger1, _Trigger2, _Trigger3, _Flag, _Crime, _OutTrigger, _UserLevel)
		DB_CheckPoint(_Guard1, _Guard2, _Trigger1, _Trigger2, _Trigger3, _Flag, _Crime, _OutTrigger)
		DB_CheckPoint(_Guard1, _Guard2, _Trigger1, _Trigger2, _Trigger3, _Flag, _Crime)
		and
		DB_CheckPoint(_Guard1, _Guard2, _Trigger1, _Trigger2, _Trigger3, _Flag)
		for a checkpoint with two warnings. In Trigger 1, Guard 1 warns the player, and typically offers them the option to earn the right to pass
		the checkpoint, getting the _Flag. In Trigger 2, Guard 2 gives the player a final warning.
		In Trigger 3, the player (if they don't have the _Flag) counts as Trespassing.
		
		The optional _Crime parameter allows you to register a custom crime rather than the default Trespassing crime.
		The optional _OutTrigger parameter makes it possible for the player to choose the "leave" option when confronted with their trespassing.
		The optional _UserLevel parameter, if 1, makes the checkpoint operate on the user level.
		
		Guards should have the SneakSpotter script.
		*/
		
	}
	KB
	{
		//REGION Database registering
		IF
		DB_CheckPoint((CHARACTERGUID)_Guard1, (CHARACTERGUID)_Guard2, (TRIGGERGUID)_Trigger1, (TRIGGERGUID)_Trigger2, (TRIGGERGUID)_Trigger3, (STRING)_Flag)
		THEN
		DB_CheckPoint(_Guard1, _Guard2, _Trigger1, _Trigger2, _Trigger3, _Flag, "Trespassing");
		
		IF
		DB_CheckPoint((CHARACTERGUID)_Guard1, (CHARACTERGUID)_Guard2, (TRIGGERGUID)_Trigger1, (TRIGGERGUID)_Trigger2, (TRIGGERGUID)_Trigger3, (STRING)_Flag, (STRING)_Crime)
		THEN
		DB_CheckPoint(_Guard1, _Guard2, _Trigger1, _Trigger2, _Trigger3, _Flag, _Crime, (TRIGGERGUID)NULL_00000000-0000-0000-0000-000000000000);
		
		IF
		DB_CheckPoint(_Guard1, _Guard2, _Trigger1, _Trigger2, _Trigger3, _Flag, _Crime, _OutTrigger)
		THEN
		DB_CheckPoint(_Guard1, _Guard2, _Trigger1, _Trigger2, _Trigger3, _Flag, _Crime, _OutTrigger, 0);
		
		IF
		DB_CheckPoint(_Guard1, _Guard2, _Trigger1, _Trigger2, _Trigger3, _, _Crime, _OutTrigger, _UserLevel)
		THEN
		DB_CheckPointGuard(_Guard1, _Trigger1);
		DB_CheckPointGuard(_Guard2, _Trigger2);
		DB_TrespassTrigger(_Trigger3, _OutTrigger, _Crime);
		
		IF
		DB_CheckPointGuard((CHARACTERGUID)_Guard, (TRIGGERGUID)_Trigger)
		THEN
		DB_SneakTriggerSpotter(_Trigger, _Guard);
		
		//END_REGION
		
		//REGION General Logic with Guards addressing player
		IF
		ObjectEnteredCombat((CHARACTERGUID)_Guard, _)
		AND
		DB_CheckPointGuard(_Guard, _)
		THEN
		ObjectClearFlag(_Guard, "GLO_CP_WarningSomeone", 0);
		
		IF
		DialogEnded(_, _ID)
		AND
		DB_DialogNPCs(_ID, _Guard, _)
		AND
		DB_CheckPointGuard((CHARACTERGUID)_Guard, _)
		THEN
		ObjectClearFlag(_Guard, "GLO_CP_WarningSomeone", 0);
		
		IF
		CharacterLeftTrigger(_, _Trigger)
		AND
		QRY_AnyRegionActive()
		AND
		DB_CheckPointGuard(_Guard, _Trigger)
		AND
		NOT DB_InRegion(_, _Trigger)
		THEN
		SetStoryEvent(_Guard, "RestartSpotting");
		DB_SneakTriggerSpotter(_Trigger, _Guard);
		
		PROC
		ProcCharInTriggerSpotted(_Player, _Trigger2)
		AND
		DB_CheckPoint(_, _Guard2, _, _Trigger2, _, _Flag, _, _, 0)
		AND
		NOT PartyGetFlag(_Player, _Flag, 1) //If none of the party members have been allowed to enter.
		AND
		QRY_SpeakerIsAvailable(_Guard2)
		AND
		DB_IsPlayer(_Player)
		THEN
		ObjectSetFlag(_Guard2, "GLO_CP_WarningSomeone", 0);
		PROC_CheckPointDialogue(_Player, _Guard2);
		
		PROC
		ProcCharInTriggerSpotted(_Player, _Trigger2)
		AND
		DB_CheckPoint(_, _Guard2, _, _Trigger2, _, _Flag, _, _, 1)
		AND
		NOT UserGetFlag(_Player, _Flag, 1) //If none of the party members have been allowed to enter.
		AND
		QRY_SpeakerIsAvailable(_Guard2)
		AND
		DB_IsPlayer(_Player)
		THEN
		ObjectSetFlag(_Guard2, "GLO_CP_WarningSomeone", 0);
		PROC_CheckPointDialogue(_Player, _Guard2);
		
		PROC
		ProcCharInTriggerSpotted((CHARACTERGUID)_Player, _Trigger)
		AND
		DB_CheckPoint(_Guard1, _, _Trigger, _, _, _Flag, _, _, 0)
		AND
		NOT PartyGetFlag(_Player, _Flag, 1) //If none of the party members have been allowed to enter.
		AND
		CharacterIsControlled(_Player, 1)
		AND
		DB_IsPlayer(_Player)
		AND
		QRY_SpeakerIsAvailable(_Guard1)
		AND
		ObjectGetFlag(_Guard1, "GLO_CP_WarningSomeone", 0)
		THEN
		ObjectSetFlag(_Guard1, "GLO_CP_WarningSomeone", 0);
		PROC_CheckPointDialogue(_Player, _Guard1);
		
		PROC
		ProcCharInTriggerSpotted((CHARACTERGUID)_Player, _Trigger)
		AND
		DB_CheckPoint(_Guard1, _, _Trigger, _, _, _Flag, _, _, 1)
		AND
		NOT UserGetFlag(_Player, _Flag, 1) //If none of the party members have been allowed to enter.
		AND
		CharacterIsControlled(_Player, 1)
		AND
		DB_IsPlayer(_Player)
		AND
		QRY_SpeakerIsAvailable(_Guard1)
		AND
		ObjectGetFlag(_Guard1, "GLO_CP_WarningSomeone", 0)
		THEN
		ObjectSetFlag(_Guard1, "GLO_CP_WarningSomeone", 0);
		PROC_CheckPointDialogue(_Player, _Guard1);
		
		PROC
		PROC_CheckPointDialogue((CHARACTERGUID)NULL_00000000-0000-0000-0000-000000000000, (CHARACTERGUID)NULL_00000000-0000-0000-0000-000000000000)
		THEN
		DB_NOOP(0);
		//END_REGION
		
		//REGION If the players have the appropriate flag, they do not count as trespassing.
		QRY
		QRY_CRIME_BlockRegisterCrime(_Player,_Crime,_Trigger, _, _, _)
		AND
		DB_CheckPoint(_, _, _, _, (TRIGGERGUID)_Trigger, _Flag, _Crime, _, 0)
		AND
		PartyGetFlag(_Player, _Flag, 1)
		THEN
		DB_NOOP(0);
		
		QRY
		QRY_CRIME_BlockRegisterCrime(_Player,_Crime,_Trigger, _, _, _)
		AND
		DB_CheckPoint(_, _, _, _, (TRIGGERGUID)_Trigger, _Flag, _Crime, _, 1)
		AND
		UserGetFlag(_Player, _Flag, 1)
		THEN
		DB_NOOP(0);
		
		IF
		ObjectFlagSet(_Flag, _Player, _)
		AND
		DB_CheckPoint(_, _, _, _, _Trigger, _Flag, _Crime, _, _)
		THEN
		NOT DB_PlayerTrespassing((CHARACTERGUID)_Player,_Trigger);
		CharacterStopCrime((CHARACTERGUID)_Player, _Crime, _Trigger);
		
		IF
		ObjectFlagCleared(_Flag, _Player, _)
		AND
		DB_CheckPoint(_, _, _, _, _Trigger, _Flag, _Crime, _, _)
		AND
		DB_InRegion((CHARACTERGUID)_Player, _Trigger)
		THEN
		ProcCharacterRegisterCrime((CHARACTERGUID)_Player,_Crime,_Trigger,NULL_00000000-0000-0000-0000-000000000000,0,NULL_00000000-0000-0000-0000-000000000000);
		//END_REGION
		
	}
	EXIT
	{
		
	}
}
Goal(58).Title("GLO_Follower");
Goal(58)
{
	INIT
	{
		/*How to use
		- Make sure Owner and Follower are Global
		- Give follower the GEN_Follower script (Either use the build in follow Behaviour or create own customized follow script)
		- Add Follower to DB_Followers and add the Char flag that is set on a char to make owner.
		- Add follower to DB_FollowerIgnoreRegions if you want it not to appear in certain regions
		- Add follower to DB_FollowerDisapearInTrigger if you don't want the specific follower to show up in certain triggers
		- Add trigger to DB_HideAllFollowersInTrigger if you want no followers to show up in this trigger (Such as HoE)
		
		
		- Setting the owner flag will make that char an owner
		- Clearing the flag will remove it as an owner
		- Setting the owner flag on another char automaticly clears the owner flag on prev owner
		
		- You can get followers owners with DB_FollowerOwners(owner,_follower) (Don't add chars in this DB)
		*/
		
		//REGION Follower DB (Set follower in this DB)
		//DB_GLO_Followers(GlobalCharFollower,ownerFlag); (Follower and owner should be global)
		//END_REGION
		
		
		//REGION Follower dont go to Region (Makes sure Follower is not taken here)
		//DB_FollowerIgnoreRegion(_region,_follower); (_region is string)
		
		//END_REGION
		
		//REGION ALL followers dont go to region
		//DB_AllFollowersIgnoreRegion(_region);
		DB_AllFollowersIgnoreRegion("LV_HoE_Main");
		
		//END_REGION
		
		//REGION Dont have specific follower in Trigger (Set this to make sure specific followers dont appear in this trigger)
		//Disapear on entering trigger, Appear again after leaving trigger.
		//DB_FollowerHideInTrigger((TRIGGERGUID)_trigger,(CHARACTERGUID)_follower); (Trigger should be global)
		
		//END_REGION
		
		
		//REGION Dont have any followers appear in trigger (Such as in HoE)
		//Disapear on entering trigger, Appear again after leaving trigger.
		//DB_HideAllFollowersInTrigger((TRIGGERGUID)_trigger);(Trigger should be global)
		
		//END_REGION
		
		//REGION Have specific Followers always Appear in trigger (For Regions that dont allow followers)
		//Specific Follower is enabled in trigger but disabled when leaving the trigger
		//DB_FollowerShowInTrigger((TRIGGERGUID)_trigger,(CHARACTERGUID)_follower) (Trigger should be global)
		//END_REGION
		
		//REGION Have Followers always Appear in trigger (For Regions that dont allow followers)
		//Follower is enabled in trigger but disabled when leaving the trigger
		//DB_ShowAllFollowersInTrigger((TRIGGERGUID)_trigger) (Trigger should be global)
		//END_REGION
		
	}
	KB
	{
		//REGION OnInit set script vars
		//Set script vars
		IF
		DB_Followers((GUIDSTRING)_follower,(STRING)_ownerFlag)
		THEN
		SetVarFixedString(_follower,"ownerFlag",_ownerFlag); 
		//END_REGION
		
		
		//REGION Setting/Removing Owner
		//Add owner to DB
		IF
		ObjectFlagSet(_ownerFlag,_owner,_)
		AND
		DB_Followers(_follower,_ownerFlag)
		THEN
		DB_FollowerOwners(_owner,_follower);
		
		//Remove owner form DB
		IF
		ObjectFlagCleared(_ownerFlag,_owner,_)
		AND
		DB_Followers(_follower,_ownerFlag)
		THEN
		NOT DB_FollowerOwners(_owner,_follower);
		//END_REGION
		
		//REGION Teleport Follower
		IF
		StoryEvent(_follower,"GLO_TeleportFollower") 
		AND
		DB_Followers(_follower,_)
		AND
		GetVarObject(_follower,"owner",_owner)
		THEN
		DialogRequestStop(_follower);
		CharacterPurgeQueue((CHARACTERGUID)_follower);
		TeleportTo(_follower,_owner);
		//END_REGION
		
		//REGION Make follower appear (With Appear animation)
		IF
		StoryEvent(_follower,"GLO_MakeFollowerAppear") 
		AND
		DB_Followers(_follower,_)
		AND
		GetVarObject(_follower,"owner",_owner)
		AND
		GetVarInteger(_follower,"playAppearAnimation",_playSpawnAnimation)
		THEN
		CharacterPurgeQueue((CHARACTERGUID)_follower);
		CharacterAppearAt((CHARACTERGUID)_follower,_owner,_playSpawnAnimation,"GLO_FollowerHasAppeared"); 
		//END_REGION
		
		//REGION On owner went off/On stage
		//Owner went off stage
		IF
		CharacterWentOnStage(_owner,0)
		AND
		DB_FollowerOwners(_owner,_follower)
		THEN
		DialogRequestStop(_follower);
		SetOnStage(_follower,0);
		
		
		//Owner went on stage
		IF
		CharacterWentOnStage(_owner,1)
		AND
		DB_FollowerOwners(_owner,_follower)
		AND
		GetVarInteger(_follower,"playAppearAnimation",_playSpawnAnimation)
		THEN
		CharacterPurgeQueue((CHARACTERGUID)_follower);
		CharacterAppearAt((CHARACTERGUID)_follower,_owner,_playSpawnAnimation,"GLO_FollowerHasAppeared");
		//END_REGION
		
		
		//REGION On Region swap (Player only)
		IF
		RegionStarted(_region)
		AND
		DB_FollowerOwners(_owner,_follower)
		AND
		DB_IsPlayer((CHARACTERGUID)_owner)
		AND
		NOT DB_FollowerIgnoreRegion(_region,_follower)
		AND
		NOT DB_AllFollowersIgnoreRegion(_region)
		THEN
		TeleportTo(_follower,_owner);
		//END_REGION
		
		
		//REGION Hide/show specific follower in/out trigger
		//Register for disappear trigger
		IF
		DB_FollowerOwners(_owner,_follower)
		AND
		DB_FollowerHideInTrigger(_trigger,(CHARACTERGUID)_follower)
		THEN
		TriggerRegisterForCharacter((TRIGGERGUID)_trigger,(CHARACTERGUID)_owner);
		
		
		//Unregister for disappear trigger
		IF
		ObjectFlagCleared(_ownerFlag,_owner,_)
		AND
		DB_Followers(_follower,_ownerFlag)
		AND
		DB_FollowerHideInTrigger(_trigger,(CHARACTERGUID)_follower)
		THEN
		TriggerUnregisterForCharacter((TRIGGERGUID)_trigger,(CHARACTERGUID)_owner);
		
		
		//Trigger to make followers disapear (Used for places like HoE)
		IF
		CharacterEnteredTrigger(_owner,_trigger)
		AND
		DB_FollowerOwners(_owner,_)
		AND
		DB_FollowerHideInTrigger(_trigger,(CHARACTERGUID)_follower)
		THEN
		DialogRequestStop(_follower);
		SetOnStage(_follower,0);
		
		//Appear again on leaving trigger
		IF
		CharacterLeftTrigger(_owner,_trigger)
		AND
		DB_FollowerOwners(_owner,_)
		AND
		DB_FollowerHideInTrigger(_trigger,(CHARACTERGUID)_follower)
		AND
		GetVarInteger(_follower,"playAppearAnimation",_playSpawnAnimation)
		THEN
		PROC_HideFollowers_Reappear(_follower, _owner, _playSpawnAnimation);
		//END_REGION
		
		//REGION Show/hide specific follower in/out trigger
		//Register for appear trigger
		IF
		DB_FollowerOwners(_owner,_follower)
		AND
		DB_FollowerShowInTrigger(_trigger,_follower)
		THEN
		TriggerRegisterForCharacter((TRIGGERGUID)_trigger,(CHARACTERGUID)_owner);
		
		
		//Unregister for appear trigger
		IF
		ObjectFlagCleared(_ownerFlag,_owner,_)
		AND
		DB_Followers(_follower,_ownerFlag)
		AND
		DB_FollowerShowInTrigger(_trigger,_follower)
		THEN
		TriggerUnregisterForCharacter((TRIGGERGUID)_trigger,(CHARACTERGUID)_owner);
		
		
		//Trigger to make followers apear (Used for regions that don't allow followers)
		IF
		CharacterEnteredTrigger(_owner,_trigger)
		AND
		DB_FollowerOwners(_owner,_follower)
		AND
		DB_FollowerShowInTrigger(_trigger,_follower)
		AND
		GetVarInteger(_follower,"playAppearAnimation",_playSpawnAnimation)
		THEN
		CharacterPurgeQueue((CHARACTERGUID)_follower);
		CharacterAppearAt((CHARACTERGUID)_follower,_owner,_playSpawnAnimation,"GLO_FollowerHasAppeared");
		
		
		//Disapear again on leaving trigger
		IF
		CharacterLeftTrigger(_owner,_trigger)
		AND
		DB_FollowerOwners(_owner,_)
		AND
		DB_FollowerShowInTrigger(_trigger,_follower)
		THEN
		DialogRequestStop(_follower);
		SetOnStage(_follower,0);
		//END_REGION
		
		
		//REGION Hide/show all followers in/out trigger
		//Register for disappear trigger
		IF
		DB_FollowerOwners(_owner,_)
		AND
		DB_HideAllFollowersInTrigger(_trigger)
		THEN
		TriggerRegisterForCharacter((TRIGGERGUID)_trigger,(CHARACTERGUID)_owner);
		
		
		//Unregister for disappear trigger
		IF
		ObjectFlagCleared(_ownerFlag,_owner,_)
		AND
		DB_Followers(_follower,_ownerFlag)
		AND
		DB_HideAllFollowersInTrigger(_trigger)
		THEN
		TriggerUnregisterForCharacter((TRIGGERGUID)_trigger,(CHARACTERGUID)_owner);
		
		
		//Trigger to make followers disapear (Used for places like HoE)
		IF
		CharacterEnteredTrigger(_owner,_trigger)
		AND
		DB_FollowerOwners(_owner,_follower)
		AND
		DB_HideAllFollowersInTrigger(_trigger)
		THEN
		DialogRequestStop(_follower);
		SetOnStage(_follower,0);
		
		//Appear again on leaving trigger
		IF
		CharacterLeftTrigger(_owner,_trigger)
		AND
		DB_FollowerOwners(_owner,_follower)
		AND
		DB_HideAllFollowersInTrigger(_trigger)
		AND
		GetVarInteger(_follower,"playAppearAnimation",_playSpawnAnimation)
		THEN
		PROC_HideFollowers_Reappear(_follower, _owner, _playSpawnAnimation);
		
		PROC
		PROC_HideFollowers_Reappear((GUIDSTRING)_follower, (GUIDSTRING)_owner, (INTEGER)_playSpawnAnimation)
		AND
		QRY_AnyRegionActive()
		THEN
		CharacterPurgeQueue((CHARACTERGUID)_follower);
		CharacterAppearAt((CHARACTERGUID)_follower,_owner,_playSpawnAnimation,"GLO_FollowerHasAppeared");
		
		PROC
		PROC_HideFollowers_Reappear((GUIDSTRING)_follower, (GUIDSTRING)_owner, (INTEGER)_playSpawnAnimation)
		AND
		NOT QRY_AnyRegionActive()
		THEN
		CharacterPurgeQueue((CHARACTERGUID)_follower);
		SetOnStage((CHARACTERGUID)_follower, 1);
		//END_REGION
		
		//REGION Show/Hide all followers in/out trigger
		//Register for disappear trigger
		IF
		DB_FollowerOwners(_owner,_)
		AND
		DB_ShowAllFollowersInTrigger(_trigger)
		THEN
		TriggerRegisterForCharacter((TRIGGERGUID)_trigger,(CHARACTERGUID)_owner);
		
		
		//Unregister for disappear trigger
		IF
		ObjectFlagCleared(_ownerFlag,_owner,_)
		AND
		DB_Followers(_follower,_ownerFlag)
		AND
		DB_ShowAllFollowersInTrigger(_trigger)
		THEN
		TriggerUnregisterForCharacter((TRIGGERGUID)_trigger,(CHARACTERGUID)_owner);
		
		
		//Trigger to make followers appear (Used for Regions that don't allow followers)
		IF
		CharacterEnteredTrigger(_owner,_trigger)
		AND
		DB_FollowerOwners(_owner,_follower)
		AND
		DB_ShowAllFollowersInTrigger(_trigger)
		AND
		GetVarInteger(_follower,"playAppearAnimation",_playSpawnAnimation)
		THEN
		CharacterPurgeQueue((CHARACTERGUID)_follower);
		CharacterAppearAt((CHARACTERGUID)_follower,_owner,_playSpawnAnimation,"GLO_FollowerHasAppeared");
		
		
		//Disappear again on leaving trigger
		IF
		CharacterLeftTrigger(_owner,_trigger)
		AND
		DB_FollowerOwners(_owner,_follower)
		AND
		DB_ShowAllFollowersInTrigger(_trigger)
		THEN
		DialogRequestStop(_follower);
		SetOnStage(_follower,0);
		
		//END_REGION
		
		/* Doesn't work
		//REGION Set follower level
		IF
		DB_FollowerOwners(_owner,_follower)
		AND
		GetVarInteger(_follower,"setLevelSameAsOwner",1)
		AND
		CharacterGetLevel((CHARACTERGUID)_owner,_level)
		AND
		IntegertoString(_level,_string)
		THEN
		CharacterLevelUpTo((CHARACTERGUID)_follower,_level);
		DebugBreak(_string);
		
		//END_REGION
		*/
		
		//REGION Follower Level up with owner
		IF
		CharacterLeveledUp(_owner)
		AND
		DB_FollowerOwners(_owner,_follower)
		AND
		GetVarInteger(_follower,"levelUpWithOwner",1)
		THEN
		CharacterLevelUp((CHARACTERGUID)_follower);
		//END_REGION
		
		
		//REGION Party followers queries/procs
		QRY
		QRY_IsSummonOrPartyFollower((CHARACTERGUID)_Character)
		AND
		CharacterIsSummon(_Character,1)
		THEN
		DB_NOOP(1);
		
		QRY
		QRY_IsSummonOrPartyFollower((CHARACTERGUID)_Character)
		AND
		CharacterIsPartyFollower(_Character,1)
		THEN
		DB_NOOP(1);
		
		//END_REGION
		
	}
	EXIT
	{
		
	}
}
Goal(59).Title("GLO_PartyPresets");
Goal(59)
{
	INIT
	{
		
	}
	KB
	{
		//REGION Party Preset handling
		 
		QRY
		QryIsDebugProfileAvatar((CHARACTERGUID)_Char)
		AND
		DB_DebugProfileChar(_Char)
		AND
		IsTagged(_Char,"AVATAR",1)
		THEN
		DB_Noop(1);
		
		PROC
		ProcTryClearAvatarTag((CHARACTERGUID)_Char)
		AND
		NOT DB_DebugAVATARFound(_Char)
		THEN
		ClearTag(_Char,"AVATAR");
		
		IF
		CharacterLoadedInPreset(_Char)
		AND
		NOT DB_GLO_PartyPresets_Block(1)
		THEN
		NOT DB_DoNotFace(_Char);
		SetOnStage(_Char,1);
		DB_DebugProfileChar(_Char);
		ProcSelectDebugAVATAR(_Char);
		
		IF
		PartyPresetLoaded(_Profile)
		AND
		NOT DB_GLO_PartyPresets_Block(1)
		THEN
		ProcSetupDebugParty();
		ProcDoDebugSetup(_Profile);
		
		IF
		PartyPresetLoaded(_)
		AND
		NOT DB_GLO_PartyPresets_Block(1)
		AND
		DB_DebugAVATARFound(_Char)
		THEN
		NOT DB_DebugAVATARFound(_Char);
		
		IF
		DB_DebugAVATARFound((CHARACTERGUID)_Char)
		THEN
		ProcMarkUndeadOrigin(_Char);
		
		PROC
		ProcSetupDebugParty()
		THEN
		ProcVerifyDebugAvatar();
		
		//clear old party
		PROC
		ProcSetupDebugParty()
		AND
		DB_IsPlayer(_Char)
		AND
		NOT DB_GenericOrigins(_Char)
		AND
		NOT QryIsDebugProfileAvatar(_Char)
		THEN
		NOT DB_IsPlayer(_Char);
		ProcUnRegisterPlayerTriggers(_Char);
		ProcTryClearAvatarTag(_Char);
		DB_GLO_PartyMembers_BlockReturnToRecruitmentPosition(_Char);
		PROC_GLO_PartyMembers_Remove(_Char,NULL_00000000-0000-0000-0000-000000000000,1,0);
		NOT DB_GLO_PartyMembers_BlockReturnToRecruitmentPosition(_Char);
		
		PROC
		ProcSetupDebugParty()
		AND
		DB_IsPlayer(_Char)
		AND
		DB_GenericOrigins(_Char)
		AND
		NOT DB_DebugProfileChar(_Char)
		THEN
		NOT DB_IsPlayer(_Char);
		ProcUnRegisterPlayerTriggers(_Char);
		ProcTryClearAvatarTag(_Char);
		DB_GLO_PartyMembers_BlockReturnToRecruitmentPosition(_Char);
		PROC_GLO_PartyMembers_Remove(_Char,NULL_00000000-0000-0000-0000-000000000000,1,0);
		NOT DB_GLO_PartyMembers_BlockReturnToRecruitmentPosition(_Char);
		
		//setup new one
		PROC
		ProcSetupDebugParty()
		AND
		DB_DebugProfileChar(_Char)
		AND
		NOT DB_IsPlayer(_Char)
		THEN
		ObjectSetFlag(_Char,"GLO_CompanionHasBeenRecruited");
		ProcAddDebugCharToParty(_Char);
		
		PROC
		ProcSelectDebugAVATAR((CHARACTERGUID)_Char)
		AND
		NOT DB_DebugAVATARFound(_)
		AND
		IsTagged(_Char,"AVATAR",1)
		THEN
		DB_DebugAVATARFound(_Char);
		
		PROC
		ProcVerifyDebugAvatar()
		AND
		NOT DB_DebugAVATARFound(_)
		AND
		CharacterGetHostCharacter(_Host)
		THEN
		SetTag(_Host,"AVATAR");
		DB_DebugAVATARFound(_Host);
		
		PROC
		ProcVerifyDebugAvatar()
		AND
		DB_DebugAVATARFound(_Char)
		AND
		NOT DB_GLO_PartyMembers_DefaultFaction(_Char,_)
		AND
		GetFaction(_Char,_PlayerFaction)
		THEN
		DB_GLO_PartyMembers_DefaultFaction(_Char,_PlayerFaction);
		
		PROC
		ProcAddDebugCharToParty((CHARACTERGUID)_Char)
		AND
		DB_DebugAVATARFound(_Host)
		AND
		IsTagged(_Char,"AVATAR",0)
		THEN
		PROC_GLO_PartyMembers_Add(_Char,_Host);
		ObjectSetFlag(_Char,"GLO_HasSelectedPreset");
		
		PROC
		ProcAddDebugCharToParty((CHARACTERGUID)_Origin)
		AND
		DB_DebugAVATARFound(_Host)
		AND
		IsTagged(_Origin,"AVATAR",1)
		AND
		DB_GLO_PartyMembers_DefaultFaction(_Origin,_PlayerFaction)
		THEN
		ProcCharacterDisableAllCrimes(_Origin);
		ProcAssignCharacterToPlayer(_Origin,_Host);
		ProcRegisterPlayerTriggers(_Origin);
		SetFaction(_Origin,_PlayerFaction);
		DB_IsPlayer(_Origin);
		ProcRemoveAllDialogEntriesForSpeaker(_Origin);
		SetHasDialog(_Origin,0);
		NOT DB_GLO_PartyMembers_DefaultFaction(_Origin,_PlayerFaction);
		CharacterAttachToGroup(_Origin,_Host);
		Proc_CheckPartyFull();
		
		PROC
		ProcAddDebugCharToParty((CHARACTERGUID)_Char)
		AND
		NOT DB_DebugAVATARFound(_)
		AND
		GetFaction(_Char,_PlayerFaction)
		THEN
		CharacterMakePlayer(_Char, NULL_00000000-0000-0000-0000-000000000000);
		MakePlayerActive(_Char);
		SetTag(_Char,"AVATAR");
		DB_DebugAVATARFound(_Char);
		DB_GLO_PartyMembers_DefaultFaction(_Char,_PlayerFaction);
		ProcAddDebugCharToParty(_Char);
		
		PROC
		ProcSetupDebugParty()
		AND
		DB_DebugProfileChar(_Char)
		AND
		CharacterHasTalent(_Char,"AnimalEmpathy",1)
		THEN
		SetTag(_Char,"PETPAL");
		
		//END_REGION
		//REGION Logic
		PROC
		ProcDoDebugSetup((STRING)_Region)
		THEN
		DB_InDebugSetup(1);
		ProcDebugResetPreviousRegion();
		ProcDebugSetCurrentRegion(_Region);
		ProcDebugGiveTags(_Region);
		ProcDebugGiveGlobalFlags(_Region);
		ProcDebugGivePlayerCharacterFlags(_Region);
		ProcDebugGiveObjectFlags(_Region);
		FireOsirisEvents();
		NOT DB_InDebugSetup(1);
		
		PROC
		ProcDebugResetPreviousRegion()
		AND
		DB_DebugPreviousRegion(_Region)
		THEN
		ProcDebugRemoveObjectFlags(_Region);
		ProcDebugRemovePlayerCharacterFlags(_Region);
		ProcDebugRemoveGlobalFlags(_Region);
		ProcDebugRemoveTags(_Region);
		
		PROC
		ProcDebugSetCurrentRegion((STRING)_)
		AND
		DB_DebugPreviousRegion(_Region)
		THEN
		NOT DB_DebugPreviousRegion(_Region);
		
		PROC
		ProcDebugSetCurrentRegion((STRING)_Region)
		THEN
		DB_DebugPreviousRegion(_Region);
		
		//REGION Adding
		PROC
		ProcDebugGiveTag((CHARACTERGUID)_Player,(STRING)_Tag,1)
		AND
		IsTagged(_Player,"AVATAR",1)
		THEN
		SetTag(_Player,_Tag);
		
		PROC
		ProcDebugGiveTag((CHARACTERGUID)_Player,(STRING)_Tag,0)
		THEN
		SetTag(_Player,_Tag);
		
		PROC
		ProcDebugGiveTags((STRING)_Region)
		AND
		DB_DebugTags((STRING)_Region,(STRING)_Tag,(INTEGER)_AvatarOnly)
		AND
		DB_IsPlayer(_Player)
		THEN
		ProcDebugGiveTag(_Player,_Tag,_AvatarOnly);
		
		PROC
		ProcDebugGiveGlobalFlags((STRING)_Region)
		AND
		DB_DebugGlobalFlags((STRING)_Region,(STRING)_Flag)
		THEN
		GlobalSetFlag(_Flag);
		
		PROC
		ProcDebugGivePlayerCharacterFlags((STRING)_Region)
		AND
		DB_DebugPlayerCharacterFlags((STRING)_Region,(STRING)_Flag)
		AND
		DB_IsPlayer(_Player)
		THEN
		ObjectSetFlag(_Player,_Flag,0);
		
		PROC
		ProcDebugGiveObjectFlags((STRING)_Region)
		AND
		DB_DebugObjectFlags((STRING)_Region,(GUIDSTRING)_Object,(STRING)_Flag)
		THEN
		ObjectSetFlag(_Object,_Flag,0);
		//END_REGION
		
		//REGION Removing
		PROC
		ProcDebugRemoveTags((STRING)_Region)
		AND
		DB_DebugTags(_Region,_Tag,_)
		AND
		DB_IsPlayer(_Player)
		THEN
		ClearTag(_Player,_Tag);
		
		PROC
		ProcDebugRemoveGlobalFlags((STRING)_Region)
		AND
		DB_DebugGlobalFlags(_Region,_Flag)
		THEN
		GlobalClearFlag(_Flag);
		
		PROC
		ProcDebugRemovePlayerCharacterFlags((STRING)_Region)
		AND
		DB_DebugPlayerCharacterFlags(_Region,_Flag)
		AND
		DB_IsPlayer(_Player)
		THEN
		ObjectClearFlag(_Player,_Flag,0);
		
		PROC
		ProcDebugRemoveObjectFlags((STRING)_Region)
		AND
		DB_DebugObjectFlags(_Region,_Object,_Flag)
		THEN
		ObjectClearFlag(_Object,_Flag,0);
		
		//END_REGION
		
		//END_REGION
		
		
		
	}
	EXIT
	{
		
	}
}
Goal(60).Title("GLO_Resting");
Goal(60)
{
	INIT
	{
		DB_RestTemplates("FUR_Humans_Camping_Sleepingbag_B_4d7216c9-c21e-4ab0-b98e-97d744798912","STORY_PartyRest",10.0,17.0);
		
	}
	KB
	{
		IF
		CharacterUsedItemTemplate(_Character,_Temp,_)
		AND
		DB_RestTemplates(_Temp,_Consume,_PartyRadius,_SafeRadius)
		THEN
		UserRest(_Character,_Consume,_PartyRadius,_SafeRadius);
		
	}
	EXIT
	{
		
	}
}
Goal(61).Title("GLO_SavegamePatchHelpers");
Goal(61)
{
	INIT
	{
		
	}
	KB
	{
		QRY
		QRY_VersionIsOlderThan((INTEGER)_Major,(INTEGER)_Minor,(INTEGER)_Rev,(INTEGER)_Build,(INTEGER)_CompMajor,(INTEGER)_CompMinor,(INTEGER)_CompRev,(INTEGER)_CompBuild)
		AND
		_Major < _CompMajor
		THEN
		DB_Noop(1);
		
		QRY
		QRY_VersionIsOlderThan((INTEGER)_Major,(INTEGER)_Minor,(INTEGER)_Rev,(INTEGER)_Build,(INTEGER)_CompMajor,(INTEGER)_CompMinor,(INTEGER)_CompRev,(INTEGER)_CompBuild)
		AND
		_Major == _CompMajor
		AND
		_Minor < _CompMinor
		THEN
		DB_Noop(1);
		
		QRY
		QRY_VersionIsOlderThan((INTEGER)_Major,(INTEGER)_Minor,(INTEGER)_Rev,(INTEGER)_Build,(INTEGER)_CompMajor,(INTEGER)_CompMinor,(INTEGER)_CompRev,(INTEGER)_CompBuild)
		AND
		_Major == _CompMajor
		AND
		_Minor == _CompMinor
		AND
		_Rev < _CompRev
		THEN
		DB_Noop(1);
		
		QRY
		QRY_VersionIsOlderThan((INTEGER)_Major,(INTEGER)_Minor,(INTEGER)_Rev,(INTEGER)_Build,(INTEGER)_CompMajor,(INTEGER)_CompMinor,(INTEGER)_CompRev,(INTEGER)_CompBuild)
		AND
		_Major == _CompMajor
		AND
		_Minor == _CompMinor
		AND
		_Rev == _CompRev
		AND
		_Build < _CompBuild
		THEN
		DB_Noop(1);
		
	}
	EXIT
	{
		
	}
}
Goal(62).Title("QRY_Characters");
Goal(62)
{
	INIT
	{
		
	}
	KB
	{
		QRY
		QRY_SpeakerBlockedBycombat((GUIDSTRING)_Char,(INTEGER)_Ignore)
		AND
		ObjectIsCharacter(_Char,1)
		AND
		_Ignore == 0
		AND
		CharacterIsInCombat((CHARACTERGUID)_Char,1)
		THEN
		DB_NOOP(1);
		
		QRY
		QRY_SpeakerIsAvailable((GUIDSTRING)_Item)
		AND
		ObjectExists(_Item,1)
		AND
		ObjectIsItem(_Item,1)
		AND
		QRY_SpeakerIsAvailable(_Item,0)
		THEN
		DB_NOOP(1);
		
		QRY
		QRY_SpeakerIsAvailable((GUIDSTRING)_Char)
		AND
		ObjectIsCharacter(_Char,1)
		AND
		QRY_SpeakerIsAvailable((GUIDSTRING)_Char, 0)
		THEN
		DB_NOOP(1);
		
		QRY
		QRY_SpeakerIsDead((GUIDSTRING)_Char)
		AND
		ObjectIsCharacter(_Char,1)
		AND
		CharacterIsDeadOrFeign((CHARACTERGUID)_Char,1)
		THEN
		DB_NOOP(1);
		
		QRY
		QRY_SpeakerIsDead((GUIDSTRING)_Item)
		AND
		ObjectIsItem(_Item,1)
		AND
		ItemIsDestroyed((ITEMGUID)_Item,1)
		THEN
		DB_NOOP(1);
		
		QRY
		QRY_HasInteractionDisabled((GUIDSTRING)_Char)
		AND
		ObjectIsCharacter(_Char,1)
		AND
		CharacterIsPolymorphInteractionDisabled((CHARACTERGUID)_Char,1)
		THEN
		DB_NOOP(1);
		
		QRY
		QRY_SpeakerIsAvailable((GUIDSTRING)_Char, (INTEGER)_IgnoreCombat)
		AND
		NOT QRY_SpeakerIsDead(_Char)
		AND
		IsSpeakerReserved(_Char,0)
		AND
		NOT QRY_HasInteractionDisabled(_Char)
		AND
		NOT QRY_SpeakerBlockedBycombat(_Char,_IgnoreCombat)
		THEN
		DB_NOOP(1);
		
		QRY
		QRY_SpeakerIsAvailable(NULL_00000000-0000-0000-0000-000000000000)
		THEN
		DB_NOOP(1);
		
		QRY
		QRY_CharacterIsNotDisabled((CHARACTERGUID)_Character)
		AND
		HasActiveStatus(_Character,"FROZEN",0)
		AND
		HasActiveStatus(_Character,"STUNNED",0)
		AND
		HasActiveStatus(_Character,"FEAR",0)
		AND
		HasActiveStatus(_Character,"PETRIFIED",0)
		AND
		HasActiveStatus(_Character,"KNOCKED_DOWN",0)
		THEN
		DB_NOOP(1);
		
		QRY
		QRY_SpeakerIsAvailableForCombat((CHARACTERGUID)_Char)
		AND
		CharacterIsDeadOrFeign(_Char,0)
		AND
		IsSpeakerReserved(_Char,0)
		THEN
		DB_NOOP(1);
		
		
		QRY
		QRY_SpeakerIsAvailableAndInDialogRange((CHARACTERGUID)_Char,(CHARACTERGUID)_SourceCharacter)
		AND
		CharacterIsDeadOrFeign(_Char,0)
		AND
		IsSpeakerReserved(_Char,0)
		AND
		CharacterIsInCombat(_Char,0)
		AND
		GetDistanceTo(_Char,_SourceCharacter,_Distance)
		AND
		_Distance < 10.0
		THEN
		DB_NOOP(1);
		
		QRY
		Query_IsPlayerHiding((CHARACTERGUID)_Char)
		AND
		HasActiveStatus(_Char,"SNEAKING",1)
		THEN
		DB_NOOP(1);
		
		QRY
		Query_IsPlayerHiding((CHARACTERGUID)_Char)
		AND
		HasActiveStatus(_Char,"INVISIBLE",1)
		THEN
		DB_NOOP(1);
		
		QRY
		QRY_CharacterIsNull((CHARACTERGUID)_Char)
		AND
		_Char == NULL_00000000-0000-0000-0000-000000000000
		THEN
		DB_NOOP(1);
		
		//REGION Find a player with petpal to talk to
		QRY
		QRY_PetPallerInDialogRange((CHARACTERGUID)_Char)
		AND
		DB_QRYRTN_PetPallerInDialogRange(_Petpaller)
		THEN
		NOT DB_QRYRTN_PetPallerInDialogRange(_Petpaller);
		
		QRY
		QRY_PetPallerInDialogRange((CHARACTERGUID)_Char)
		AND
		DB_IsPlayer(_Player)
		AND
		NOT DB_QRYRTN_PetPallerInDialogRange(_)
		AND
		CharacterHasTalent(_Player,"AnimalEmpathy",1)
		AND
		QRY_SpeakerIsAvailableAndInDialogRange(_Player,_Char)
		THEN
		DB_QRYRTN_PetPallerInDialogRange(_Player);
		
		QRY
		QRY_PetPallerInDialogRange((CHARACTERGUID)_Char)
		THEN
		DB_NOOP(1);
		//END_REGION
		
	}
	EXIT
	{
		
	}
}
Goal(63).Title("RallyingEnemies");
Goal(63)
{
	INIT
	{
		RE_Start_Internal_CompleteIfStarted();
		
	}
	KB
	{
		PROC
			RE_Internal_StartRallyingEnemies()
		THEN
			GoalCompleted;
		
		IF
			GameEventSet("GAMEEVENT_GameStarted")
		THEN
			RE_Internal_StartRallyingEnemies();
		
		PROC
			RE_Start_Internal_CompleteIfStarted()
		AND
			DB_StoryStarted(_)
		THEN
			RE_Internal_StartRallyingEnemies();
		
		IF
			SavegameLoaded(_,_,_,_)
		AND
			DB_StoryStarted(_)
		THEN
			RE_Internal_StartRallyingEnemies();
		
	}
	EXIT
	{
		
	}
}
Goal(64).Title("ReactiveImmunities");
Goal(64)
{
	INIT
	{
		DB_RE_ReactiveImmunity("FROZEN","RALLY_FROZEN",1);
		DB_RE_ReactiveImmunity("STUNNED","RALLY_STUNNED",2);
		DB_RE_ReactiveImmunity("PETRIFIED","RALLY_PETRIFIED",3);
		DB_RE_ReactiveImmunity("CHICKEN","RALLY_PETRIFIED",3);
		DB_RE_ReactiveImmunity("KNOCKED_DOWN","RALLY_KNOCKED_DOWN",4);
		DB_RE_ReactiveImmunity("SLEEPING","RALLY_SLEEP",5);
		DB_RE_ReactiveImmunity("FEAR","RALLY_SLEEP",5);
		DB_RE_ReactiveImmunity("CHARMED","RALLY_CHARMED",6);
		DB_RE_ReactiveImmunity("MADNESS","RALLY_CHARMED",6);
		
	}
	KB
	{
		IF
		CharacterStatusRemoved((CHARACTERGUID)_Char,(STRING)_Status,_)
		AND
		DB_RE_ReactiveImmunity(_Status,_Reaction,_)
		AND
		CharacterIsPlayer(_Char, 0)
		AND
		QRY_RE_WalkingItOff(_Char)
		AND
		DB_RE_Walker(_Char,_Turns)
		THEN
		ApplyStatus(_Char,(STRING)_Reaction,(REAL)_Turns,0);
		NOT DB_RE_Walker(_Char,_Turns);
		
		QRY
		QRY_RE_WalkingItOff((CHARACTERGUID)_Char)
		AND
		CharacterHasTalent(_Char,"WalkItOff",0)
		THEN
		DB_RE_Walker(_Char,12.0);
		
		QRY
		QRY_RE_WalkingItOff((CHARACTERGUID)_Char)
		AND
		CharacterHasTalent(_Char,"WalkItOff",1)
		THEN
		DB_RE_Walker(_Char,18.0);
		
		IF
		ObjectEnteredCombat((CHARACTERGUID)_Char,_)
		AND
		IsBoss(_Char,1)
		AND
		NOT DB_RE_BossBuff(_Char,_)
		AND
		Random(6,(INTEGER)_Random)
		THEN
		DB_RE_BossBuff(_Char,_Random);
		PROC_RE_RandomBuff(_Char);
		
		PROC
		PROC_RE_RandomBuff((CHARACTERGUID)_Char)
		AND
		DB_RE_BossBuff(_Char,_Random)
		AND
		DB_RE_ReactiveImmunity(_,_Status,_Random)
		THEN
		ApplyStatus(_Char,(STRING)_Status,-1.0,0);
		
	}
	EXIT
	{
		
	}
}
Goal(65).Title("Sandbox");
Goal(65)
{
	INIT
	{
		DB_CheckLevelStart("_TMPL_Sandbox");
		
	}
	KB
	{
		IF
		RegionStarted("_TMPL_Sandbox")
		THEN
		GoalCompleted;
		
		IF
		DB_CheckLevelStart("_TMPL_Sandbox")
		AND
		DB_CurrentLevel("_TMPL_Sandbox")
		THEN
		GoalCompleted;
		
	}
	EXIT
	{
		NOT DB_CheckLevelStart("_TMPL_Sandbox");
		
	}
}
Goal(66).Title("Shared_CombatDialogs");
Goal(66)
{
	INIT
	{
		
	}
	KB
	{
		//REGION Interrupt repeated automated dialogs for characters entering combat
		IF
		ObjectEnteredCombat(_Char,_)
		AND
		DB_DialogNPCs(_ID,_Char,_)
		AND
		DB_DialogName(_DialogName, _ID)
		AND
		NOT DB_CombatDialogs_NoStop((STRING)_DialogName)
		AND
		DialogGetCategory(_ID,"Repeated automated NPC Dialog")
		THEN
		ProcForceStopDialog(_Char);
		//END_REGION
		
		
	}
	EXIT
	{
		
	}
}
Goal(67).Title("Z_Shared_Campaign_At_End");
Goal(67)
{
	INIT
	{
		// Name starts with Z_ to ensure the shared CC code executes after that of the "Start" goal of the various mods,
		// which define the DB_Origins databases
		
	}
	KB
	{
		IF
		GameModeStarted("Campaign",_IsEditorMode)
		THEN
		GoalCompleted;
		PROC_Z_Shared_GameModeStarted("Campaign", _IsEditorMode);
		
	}
	EXIT
	{
		
	}
}
Goal(68).Title("Z_Shared_CharacterCreation");
Goal(68)
{
	INIT
	{
		// Configuration: define the following in a top-level goal of your mod (or variants)
		
		// * Information on how to transition from character creation to the first level: Identifier, Start trigger (make global!), name of movie to play (can be empty string)
		//     Example: DB_CharacterCreationTransitionInfo("TUT_Tutorial_A",(TRIGGERGUID)TRIGGERGUID_StartPoint_000__000_fe2995bf-aa16-8ce7-33a2-8cb8cf228152,"CS_Intro");
		// * Default:
		//     None
		
		// * Identifier used to look up entry in DB_CharacterCreationTransitionInfo above (does not actually have to be a level name)
		//     Example: DB_GLO_FirstLevelAfterCharacterCreation("TUT_Tutorial_A");
		// * Default:
		//     None
		
		// * Dummy characters assigned to players while they are in the character creation level (normally no need to define/change)
		//     Example: DB_CharacterCreationDummy((CHARACTERGUID)S_GLO_CharacterCreationDummy_001_da072fe7-fdd5-42ae-9139-8bd4b9fca406);
		// * Default if not defined when this goal initialises (these characters are from SYS_Character_Creation_A):
		//     DB_CharacterCreationDummy((CHARACTERGUID)S_GLO_CharacterCreationDummy_001_da072fe7-fdd5-42ae-9139-8bd4b9fca406);
		//     DB_CharacterCreationDummy((CHARACTERGUID)S_GLO_CharacterCreationDummy_002_361dacdc-4135-4d3f-a9a2-3cad46ca246a);
		//     DB_CharacterCreationDummy((CHARACTERGUID)S_GLO_CharacterCreationDummy_003_dded8c22-b28e-45c1-a074-eb0954602c8a);
		//     DB_CharacterCreationDummy((CHARACTERGUID)S_GLO_CharacterCreationDummy_004_5f93cae7-6c10-4da1-b9a5-0efafc168c8e);
		
		// * Generic origin characters assigned to players when they create a custom character (DB needs exactly 4 elements) (normally no need to define/change)
		//     Example: DB_GenericOrigins((CHARACTERGUID)S_Player_GenericOrigin_7b6c1f26-fe4e-40bd-a5d0-e6ff58cef4fe);
		// * Default if none defined when this goal initialises:
		//     DB_GenericOrigins((CHARACTERGUID)S_Player_GenericOrigin_7b6c1f26-fe4e-40bd-a5d0-e6ff58cef4fe);
		//     DB_GenericOrigins((CHARACTERGUID)S_Player_GenericOrigin2_c451954c-73bf-46ce-a1d1-caa9bbdc3cfd);
		//     DB_GenericOrigins((CHARACTERGUID)S_Player_GenericOrigin3_41a06985-7851-4c29-8a78-398ccb313f39);
		//     DB_GenericOrigins((CHARACTERGUID)S_Player_GenericOrigin4_41a594ed-b768-4289-9f17-59f701cc6910);
		
		// * Alignments used for the generic "origin" characters defined above while these characters are NPCs (without these, PROC_GLO_PartyMembers_Add() won't work)
		//     Example: DB_OriginNPCAlignment((CHARACTERGUID)S_Player_GenericOrigin_7b6c1f26-fe4e-40bd-a5d0-e6ff58cef4fe, "Generic_Companions_1");
		// * Default if *DB_GenericOrigins* not defined when this goal initialises:
		//     DB_OriginNPCAlignment((CHARACTERGUID)S_Player_GenericOrigin_7b6c1f26-fe4e-40bd-a5d0-e6ff58cef4fe, "Generic_Companions_1");
		//     DB_OriginNPCAlignment((CHARACTERGUID)S_Player_GenericOrigin2_c451954c-73bf-46ce-a1d1-caa9bbdc3cfd, "Generic_Companions_2");
		//     DB_OriginNPCAlignment((CHARACTERGUID)S_Player_GenericOrigin3_41a06985-7851-4c29-8a78-398ccb313f39, "Generic_Companions_3");
		//     DB_OriginNPCAlignment((CHARACTERGUID)S_Player_GenericOrigin4_41a594ed-b768-4289-9f17-59f701cc6910, "Generic_Companions_4");
		
		// * Origins, i.e., predefined characters that a player can choose from during character creation
		//     DB_Origins((CHARACTERGUID)CHARACTERGUID_S_Player_Fane_8d93bf2c-94f5-4d61-9aa3-19aa24fc3540);
		//   Default:
		//     None. Note: if you nor any mod you depend on defines any, then you must overload PROC_SelectRandomStartOrigin
		//       and make it assign a character to a player to enable testing in the editor (unless you define a character
		//       with the IsPlayer flag set to true in the sidebar).
		
		PROC_Shared_CharacterCreation_Init();
		
	}
	KB
	{
		//REGION Init defaults
		PROC
		PROC_Shared_CharacterCreation_Init()
		AND
		NOT DB_CharacterCreationDummy(_)
		THEN
		DB_CharacterCreationDummy((CHARACTERGUID)S_GLO_CharacterCreationDummy_001_da072fe7-fdd5-42ae-9139-8bd4b9fca406);
		DB_CharacterCreationDummy((CHARACTERGUID)S_GLO_CharacterCreationDummy_002_361dacdc-4135-4d3f-a9a2-3cad46ca246a);
		DB_CharacterCreationDummy((CHARACTERGUID)S_GLO_CharacterCreationDummy_003_dded8c22-b28e-45c1-a074-eb0954602c8a);
		DB_CharacterCreationDummy((CHARACTERGUID)S_GLO_CharacterCreationDummy_004_5f93cae7-6c10-4da1-b9a5-0efafc168c8e);
		
		PROC
		PROC_Shared_CharacterCreation_Init()
		AND
		NOT DB_GenericOrigins(_)
		THEN
		DB_GenericOrigins((CHARACTERGUID)S_Player_GenericOrigin_7b6c1f26-fe4e-40bd-a5d0-e6ff58cef4fe);
		DB_GenericOrigins((CHARACTERGUID)S_Player_GenericOrigin2_c451954c-73bf-46ce-a1d1-caa9bbdc3cfd);
		DB_GenericOrigins((CHARACTERGUID)S_Player_GenericOrigin3_41a06985-7851-4c29-8a78-398ccb313f39);
		DB_GenericOrigins((CHARACTERGUID)S_Player_GenericOrigin4_41a594ed-b768-4289-9f17-59f701cc6910);
		DB_OriginNPCAlignment((CHARACTERGUID)S_Player_GenericOrigin_7b6c1f26-fe4e-40bd-a5d0-e6ff58cef4fe, "Generic_Companions_1");
		DB_OriginNPCAlignment((CHARACTERGUID)S_Player_GenericOrigin2_c451954c-73bf-46ce-a1d1-caa9bbdc3cfd, "Generic_Companions_2");
		DB_OriginNPCAlignment((CHARACTERGUID)S_Player_GenericOrigin3_41a06985-7851-4c29-8a78-398ccb313f39, "Generic_Companions_3");
		DB_OriginNPCAlignment((CHARACTERGUID)S_Player_GenericOrigin4_41a594ed-b768-4289-9f17-59f701cc6910, "Generic_Companions_4");
		
		PROC
		PROC_Shared_CharacterCreation_Init()
		AND
		DB_GenericOrigins(_Orig)
		THEN
		SetTag(_Orig,"GENERIC");
		
		//END_REGION
		
		//REGION Make all non-selected characters NPCs again after CC
		PROC
		PROC_CheckRemoveOtherOrigins()
		AND
		NOT DB_InCharacterCreation(1)
		AND
		QueryOnlyOnce("SetupNonSelectedOrigins")
		THEN
		ProcRemoveOtherOrigins();
		
		PROC
		ProcRemoveOtherOrigins()
		AND
		DB_Origins((CHARACTERGUID)_Origin)
		AND
		IsTagged(_Origin,"AVATAR",0)
		THEN
		PROC_GLO_PartyMembers_Remove(_Origin,1);
		
		PROC
		ProcRemoveOtherOrigins()
		AND
		DB_GenericOrigins(_GenericOrigin)
		AND
		IsTagged(_GenericOrigin,"AVATAR",0)
		THEN
		CharacterMakeNPC(_GenericOrigin);
		SetOnStage(_GenericOrigin,0);
		//END_REGION
		
		//REGION Lobby level support
		// The lobby takes place in a level that is neither character creation nor
		// a game level, and all players in the lobby need to have a (dummy)
		// character available
		IF
		RegionStarted(_Level)
		AND
		IsGameLevel(_Level,0)
		AND
		IsCharacterCreationLevel(_Level,0)
		AND
		DB_CharacterCreationDummy(_Dummy)
		AND
		// Automatically teleported to lobby by code because it's a global player character
		_Dummy != CHARACTERGUID_S_GLO_CharacterCreationDummy_001_da072fe7-fdd5-42ae-9139-8bd4b9fca406
		THEN
		TeleportTo(_Dummy,CHARACTERGUID_S_GLO_CharacterCreationDummy_001_da072fe7-fdd5-42ae-9139-8bd4b9fca406);
		CharacterMakePlayer(_Dummy);
		//END_REGION
		
		//REGION CC: Start
		IF
		CharacterCreationStarted(_)
		THEN
		PROC_Shared_CharacterCreationStarted();
		
		PROC
		PROC_Shared_CharacterCreationStarted()
		AND
		CharacterGetHostCharacter(_Char)
		AND
		CharacterGetReservedUserID(_Char, _UserID)
		AND
		GetUserProfileID(_UserID, _Profile)
		THEN
		ProcAssignDummyToUser(CHARACTERGUID_S_GLO_CharacterCreationDummy_001_da072fe7-fdd5-42ae-9139-8bd4b9fca406, _Profile);
		
		PROC
		PROC_Shared_CharacterCreationStarted()
		AND
		DB_AssignedDummyForUser(_, CHARACTERGUID_S_GLO_CharacterCreationDummy_001_da072fe7-fdd5-42ae-9139-8bd4b9fca406)
		THEN
		DB_InCharacterCreation(1);
		
		PROC
		PROC_Shared_CharacterCreationStarted()
		AND
		NOT DB_InCharacterCreation(1)
		THEN
		DB_InCharacterCreation(0);
		
		//END_REGION
		
		//REGION CC: Make all selectable characters players and move them to the CC level
		IF
		DB_InCharacterCreation(1)
		THEN
		// This dummy is special because it has IsPlayer set to true, and code will automatically teleport
		// all global IsPlayer characters to the character creation level -> use this one as an anchor
		// to teleport all other characters to
		PROC_SetupOriginCharacters(CHARACTERGUID_S_GLO_CharacterCreationDummy_001_da072fe7-fdd5-42ae-9139-8bd4b9fca406);
		
		// Make all generic origins players and move them to the CC level
		PROC
		PROC_SetupOriginCharacters((GUIDSTRING)_Dest)
		AND
		DB_GenericOrigins((CHARACTERGUID)_Org)
		THEN
		SetOnStage(_Org,1);
		TeleportTo(_Org,_Dest);
		CharacterMakePlayer(_Org, NULL_00000000-0000-0000-0000-000000000000);
		
		// Same for the origins
		PROC
		PROC_SetupOriginCharacters((GUIDSTRING)_Dest)
		AND
		DB_Origins(_Orgs)
		THEN
		TeleportTo(_Orgs,_Dest);
		CharacterMakePlayer(_Orgs, NULL_00000000-0000-0000-0000-000000000000);
		
		// and the dummies (in case this is a custom CC level)
		PROC
		PROC_SetupOriginCharacters((GUIDSTRING)_Dest)
		AND
		DB_CharacterCreationDummy(_Dummy)
		AND
		_Dummy != CHARACTERGUID_S_GLO_CharacterCreationDummy_001_da072fe7-fdd5-42ae-9139-8bd4b9fca406
		THEN
		TeleportTo(_Dummy, CHARACTERGUID_S_GLO_CharacterCreationDummy_001_da072fe7-fdd5-42ae-9139-8bd4b9fca406);
		
		//END_REGION
		
		//REGION CC: Assign dummies to all connected players
		IF
		DB_InCharacterCreation(1)
		THEN
		IterateUsers("_CCUserSetup");
		
		IF
		UserEvent(_User,"_CCUserSetup")
		AND
		GetUserProfileID(_User,_UserName)
		AND
		DB_CharacterCreationDummy(_Dummy)
		AND
		NOT DB_AssignedDummyForUser(_,_Dummy)
		AND
		NOT DB_AssignedDummyForUser(_UserName,_)
		THEN
		ProcAssignDummyToUser(_Dummy,_UserName);
		
		IF
		UserEvent(_User,"_CCUserSetup")
		AND
		GetUserProfileID(_User,_UserName)
		AND
		DB_AssignedDummyForUser(_UserName,_Dummy)
		THEN
		PROC_CheckModSwitchInLobby(_Dummy);
		CharacterAssignToUser(_User,_Dummy);
		MakePlayerActive(_Dummy);
		
		//added in case you switch mod from the lobby, which will cause the dummies to revert back to NPCs
		PROC
		PROC_CheckModSwitchInLobby((CHARACTERGUID)_Dummy)
		AND
		CharacterIsPlayer(_Dummy,0)
		THEN
		CharacterMakePlayer(_Dummy);
		PROC_AddDummyToCC(_Dummy);
		
		PROC
		PROC_AddDummyToCC((CHARACTERGUID)_Dummy)
		AND
		CharacterAddToCharacterCreation(_Dummy,0,_)
		THEN
		DB_Noop(1);
		//END_REGION
		
		//REGION CC: Selecting/deselecting characters
		PROC
		ProcRemovePreviousSelectedCharacter((STRING)_UserProfile)
		AND
		DB_SelectedCC((CHARACTERGUID)_Char,(STRING)_UserProfile)
		THEN
		ClearTag(_Char,"AVATAR");
		NOT DB_IsPlayer(_Char);
		ProcUnRegisterPlayerTriggers(_Char);
		NOT DB_SelectedCC(_Char,_UserProfile);
		
		PROC
		ProcSetSelectedCharCreationPlayer((CHARACTERGUID)_Char,(STRING)_UserProfile)
		THEN
		ProcRemovePreviousSelectedCharacter(_UserProfile);
		SetTag(_Char,"AVATAR");
		DB_IsPlayer(_Char);
		ProcRegisterPlayerTriggers(_Char);
		DB_SelectedCC(_Char,_UserProfile);
		
		PROC
		ProcRemovePreviousDummy((STRING)_UserProfile)
		AND
		DB_AssignedDummyForUser(_UserProfile,_Dummy)
		THEN
		NOT DB_AssignedDummyForUser(_UserProfile,_Dummy);
		DB_AvailableDummy(_Dummy);
		
		PROC
		ProcAssignDummyToUser((CHARACTERGUID)_Dummy,(STRING)_UserName)
		AND
		NOT DB_AvailableDummy(_Dummy)
		THEN
		CharacterMakePlayer(_Dummy, NULL_00000000-0000-0000-0000-000000000000);
		
		PROC
		ProcAssignDummyToUser((CHARACTERGUID)_Dummy,(STRING)_UserName)
		AND
		NOT DB_AvailableDummy(_Dummy)
		AND
		CharacterAddToCharacterCreation(_Dummy,0,1)
		THEN
		DB_AssignedDummyForUser(_UserName,_Dummy);
		
		PROC
		ProcAssignDummyToUser((CHARACTERGUID)_Dummy,(STRING)_UserName)
		AND
		DB_AvailableDummy(_Dummy)
		THEN
		DB_AssignedDummyForUser(_UserName,_Dummy);
		
		PROC
		ProcAssignDummyToUser((CHARACTERGUID)_Dummy,(STRING)_UserName)
		THEN
		NOT DB_AvailableDummy(_Dummy);
		
		IF
		CharacterSelectedInCharCreation(_Char,_UserID)
		AND
		GetUserProfileID(_UserID,_UserProfile)
		THEN
		ProcSetSelectedCharCreationPlayer(_Char,_UserProfile);
		
		IF
		CharacterCreationFinished((CHARACTERGUID)NULL_00000000-0000-0000-0000-000000000000)
		AND
		DB_CharacterCreationDummy(_Npc)
		THEN
		PROC_RemoveCCDummy(_Npc);
		
		PROC
		PROC_RemoveCCDummy((CHARACTERGUID)_Dummy)
		THEN
		CharacterMakeNPC(_Dummy);
		SetOnStage(_Dummy,0);
		NOT DB_IsPlayer(_Dummy);
		//END_REGION
		
		//REGION CC: connecting/disconnecting
		IF
		UserDisconnected(_UserID,_,_UserProfile)
		AND
		DB_InCharacterCreation(1)
		THEN
		ProcRemovePreviousSelectedCharacter(_UserProfile);
		ProcRemovePreviousDummy(_UserProfile);
		
		IF
		UserConnected(_,_,_UserName)
		AND
		DB_InCharacterCreation(1)
		AND
		DB_CharacterCreationDummy(_Dummy)
		AND
		NOT DB_AssignedDummyForUser(_,_Dummy)
		AND
		NOT DB_AssignedDummyForUser(_UserName,_)
		THEN
		ProcAssignDummyToUser(_Dummy,_UserName);
		
		IF
		UserConnected(_UserID,_,_UserName)
		AND
		DB_InCharacterCreation(1)
		AND
		DB_AssignedDummyForUser(_UserName,_Dummy)
		THEN
		CharacterAssignToUser(_UserID,_Dummy);
		MakePlayerActive(_Dummy);
		
		//END_REGION
		
		//REGION CC: Finished
		// CharacterCreationFinished(NULL) means that everyone is ready 
		IF
		CharacterCreationFinished((CHARACTERGUID)NULL_00000000-0000-0000-0000-000000000000)
		AND
		DB_InCharacterCreation(1)
		AND
		DB_GLO_FirstLevelAfterCharacterCreation((STRING)_FirstLevel)
		AND
		DB_CharacterCreationTransitionInfo(_FirstLevel,(TRIGGERGUID)_StartTrigger,(STRING)_Movie)
		AND
		DB_IsPlayer(_Char)
		AND
		IsTagged(_Char,"AVATAR",1)
		THEN
		NOT DB_DoNotFace(_Char);
		ProcMovePartyToStart(_Char,_StartTrigger,_Movie);
		
		// Sony event realtime multiplayer blocked
		IF
		CharacterCreationFinished((CHARACTERGUID)NULL_00000000-0000-0000-0000-000000000000)
		AND
		DB_InCharacterCreation(1)
		AND
		DB_IsPlayer(_Player)
		THEN
		SonyRealtimeMultiplayerEvent(_Player,"BLOCK");
		
		IF
		CharacterCreationFinished((CHARACTERGUID)NULL_00000000-0000-0000-0000-000000000000)
		AND
		DB_InCharacterCreation(1)
		THEN
		//force remove this
		NOT DB_InCharacterCreation(1);
		PROC_CheckRemoveOtherOrigins();
		
		PROC
		ProcMovePartyToStart((CHARACTERGUID)_NewChar,(TRIGGERGUID)_StartTrigger,(STRING)_Movie)
		THEN
		NOT DB_AlreadyTeleported(1);
		
		PROC
		ProcMovePartyToStart((CHARACTERGUID)_NewChar,(TRIGGERGUID)_StartTrigger,(STRING)_Movie)
		AND
		DB_TeleportedToStartCharacters(_Char)
		AND
		CharacterIsInPartyWith(_Char,_NewChar,1)
		THEN
		DB_AlreadyTeleported(1);
		
		PROC
		ProcMovePartyToStart((CHARACTERGUID)_NewChar,(TRIGGERGUID)_StartTrigger,(STRING)_Movie)
		AND
		NOT DB_AlreadyTeleported(1)
		THEN
		DB_TeleportedToStartCharacters(_NewChar);
		PROC_GLO_CharacterCreationTeleportWithOptionalMovie(_NewChar,_StartTrigger,_Movie);
		
		PROC
		PROC_GLO_CharacterCreationTeleportWithOptionalMovie((CHARACTERGUID)_NewChar,(TRIGGERGUID)_StartTrigger,(STRING)_Movie)
		AND
		_Movie != ""
		THEN
		CharacterTeleportPartiesToTriggerWithMovie(_StartTrigger,"",_Movie);
		
		PROC
		PROC_GLO_CharacterCreationTeleportWithOptionalMovie((CHARACTERGUID)_NewChar,(TRIGGERGUID)_StartTrigger,(STRING)_Movie)
		AND
		_Movie == ""
		THEN
		CharacterTeleportPartiesToTrigger(_StartTrigger,"");
		
		PROC
		PROC_Shared_CharacterCreationFinished()
		THEN
		DB_NOOP(1);
		
		IF
		CharacterCreationFinished(_)
		THEN
		PROC_Shared_CharacterCreationFinished();
		GoalCompleted;
		//END_REGION
		
		//REGION Skipping CC: select a random start origin
		PROC
		PROC_SelectRandomStartOrigin()
		AND
		SysCount("DB_Origins", 1, _Count)
		AND
		_Count > 0
		AND
		Random(_Count,_Rand)
		THEN
		DB_SelectedStartOrigin(_Rand);
		
		PROC
		PROC_SelectRandomStartOrigin()
		THEN
		DB_RandomOriginCounter(0);
		
		PROC
		PROC_SelectRandomStartOrigin()
		AND
		DB_Origins(_Org)
		THEN
		CharacterPurgeQueue(_Org);
		
		PROC
		PROC_SelectRandomStartOrigin()
		AND
		DB_SelectedStartOrigin(_Rand)
		AND
		DB_Origins(_Org)
		AND
		DB_RandomOriginCounter(_Ctr)
		THEN
		PROC_TrySelectRandomStartOrigin(_Ctr,_Rand,_Org);
		
		PROC
		PROC_TrySelectRandomStartOrigin((INTEGER)_Ctr,(INTEGER)_Desired,(CHARACTERGUID)_Org)
		AND
		_Ctr == _Desired
		THEN
		SetOnStage(_Org,1);
		CharacterMakePlayer(_Org, NULL_00000000-0000-0000-0000-000000000000);
		DB_IsPlayer(_Org);
		SetTag(_Org, "AVATAR");
		CharacterPurgeQueue(_Org);
		TeleportTo(_Org,CHARACTERGUID_S_GLO_CharacterCreationDummy_001_da072fe7-fdd5-42ae-9139-8bd4b9fca406,"ChosenPlayerTeleported",1);
		DB_ChosenOriginWaitingForTeleport(_Org);
		MakePlayerActive(_Org);
		ProcSetupGenericOrigin(_Org);
		
		PROC
		ProcSetupGenericOrigin((CHARACTERGUID)_Org)
		THEN
		DB_NOOP(1);
		
		IF
		StoryEvent((CHARACTERGUID)_Player,"ChosenPlayerTeleported")
		AND
		DB_ChosenOriginWaitingForTeleport(_Player)
		THEN
		NOT DB_ChosenOriginWaitingForTeleport(_Player);
		
		PROC
		PROC_TrySelectRandomStartOrigin((INTEGER)_Ctr,(INTEGER)_Desired,(CHARACTERGUID)_Org)
		AND
		IntegerSum(1,_Ctr,_New)
		AND
		DB_RandomOriginCounter(_Old)
		THEN
		NOT DB_RandomOriginCounter(_Old);
		DB_RandomOriginCounter(_New);
		
		PROC
		PROC_SelectRandomStartOrigin()
		AND
		DB_RandomOriginCounter(_Ctr)
		THEN
		NOT DB_RandomOriginCounter(_Ctr);
		//END_REGION
		
		//REGION Skipping CC: detect & set up
		// Started game mode in a level inside the editor
		// (second parameter == 1 means "In Editor")
		PROC
		PROC_Z_Shared_GameModeStarted("Campaign", 1)
		THEN
		DB_InCharacterCreation(0);
		
		// Direct teleport to a level from the main menu from the game
		IF
		RegionStarted(_Lvl)
		AND
		IsGameLevel(_Lvl,1)
		THEN
		DB_InCharacterCreation(0);
		
		// Skipping character creation -> turn all dummies into NPCs
		// (at least one dummy has the IsPlayer flag statically
		//  turned on in its properties)
		IF
		DB_InCharacterCreation(0)
		AND
		DB_CharacterCreationDummy(_Npc)
		AND
		DB_CurrentLevel(_)
		THEN
		PROC_RemoveCCDummy(_Npc);
		
		// Skipping character creation ->
		// select a random starting origin and remove the others
		IF
		DB_InCharacterCreation(0)
		AND
		DB_CurrentLevel(_)
		THEN
		PROC_SelectRandomStartOrigin();
		PROC_CheckRemoveOtherOrigins();
		
		// All done!
		IF
		DB_InCharacterCreation(0)
		AND
		DB_CurrentLevel(_)
		THEN
		GoalCompleted;
		PROC_Shared_CharacterCreationFinished();
		//END_REGION
		
	}
	EXIT
	{
		
	}
}
Goal(69).Title("Z_Shared_CharacterCreation_AfterEvents");
Goal(69)
{
	INIT
	{
		// Events to handle between the end of character creation and before the next level starts
		
	}
	KB
	{
		//REGION Disconnects between end of CC and start of game
		IF
		UserDisconnected(_UserID,_,_UserProfile)
		AND
		NOT DB_InCharacterCreation(1)
		AND
		DB_SelectedCC(_Char,_UserProfile)
		THEN
		PROC_GLO_PartyMembers_Remove(_Char,1);
		ClearTag(_Char,"AVATAR");
		NOT DB_IsPlayer(_Char);
		ProcUnRegisterPlayerTriggers(_Char);
		NOT DB_SelectedCC(_Char,_UserProfile);
		PROC_RemoveIfGenericOrigin(_Char);
		
		// Generic origins don't appear anywhere in the game if they are not players
		// -> if a player that selected one during CC disconnects before the first
		// game level starts, set it off-stage again after making it an NPC.
		PROC
		PROC_RemoveIfGenericOrigin((CHARACTERGUID)_Char)
		AND
		DB_GenericOrigins(_Char)
		THEN
		SetOnStage(_Char,0);
		//END_REGION
		
		//REGION Prevent teleport race in case of auto-selected origin
		// In case a RegionStarted event arrives between starting and ending
		// the teleport of the randomly selected origin to the dummy, cancel
		// the teleport because the origin was a player already at this time
		// and hence it will automatically be teleported to the current level
		// already (and the dummy may no longer be a player and be left behind
		// in the previous level)
		IF
		RegionStarted(_)
		AND
		DB_ChosenOriginWaitingForTeleport(_Player)
		THEN
		NOT DB_ChosenOriginWaitingForTeleport(_Player);
		CharacterPurgeQueue(_Player);
		//END_REGION
		
		//REGION Complete
		IF
		RegionStarted(_Level)
		AND
		IsGameLevel(_Level, 1)
		THEN
		GoalCompleted;
		//END_REGION
		
	}
	EXIT
	{
		
	}
}
Goal(70).Title("ZZZ_LastGoal");
Goal(70)
{
	INIT
	{
		
	}
	KB
	{
		PROC
		ProcClearAutomatedDialog((INTEGER)_Inst)
		THEN
		ProcClearDialogPlayers(_Inst);
		ProcClearDialogNPCs(_Inst);
		ProcClearDialogCounts(_Inst);
		NOT DB_AutomatedDialog(_Inst);
		
		IF
		VoiceBarkEnded(_,_Inst)
		THEN
		NOT DB_AutomatedDialogIsVB(_Inst);
		ProcClearAutomatedDialog(_Inst);
		
		IF
		AutomatedDialogEnded(_,_Inst)
		AND
		NOT DB_AutomatedDialogIsVB(_Inst)
		THEN
		ProcClearAutomatedDialog(_Inst);
		
		IF
		AutomatedDialogEnded(_Dialog,_Inst)
		THEN
		NOT DB_DialogName(_Dialog,_Inst);
		NOT DB_DialogRequestFailed(_Dialog,_Inst);
		
		IF
		DialogEnded(_Dialog,_Inst)
		THEN
		ProcClearDialogPlayers(_Inst);
		ProcClearDialogNPCs(_Inst);
		ProcClearDialogCounts(_Inst);
		NOT DB_DialogName(_Dialog,_Inst);
		NOT DB_MarkedForDelete(_Inst);
		NOT DB_DialogRequestFailed(_Dialog,_Inst);
		
		IF
		DialogActorLeft(_Dialog,_Inst,_Actor)
		AND
		DB_DialogPlayers(_Inst,_Actor,_Index)
		THEN
		NOT DB_DialogPlayers(_Inst,_Actor,_Index);
		ProcClearPlayerIfNotInOtherDialog(_Inst,_Actor);
		
		IF
		DialogActorLeft(_Dialog,_Inst,_Actor)
		AND
		DB_DialogNPCs(_Inst,_Actor,_Index)
		THEN
		NOT DB_DialogNPCs(_Inst,_Actor,_Index);
		ProcClearNPCIfNotInOtherDialog(_Inst,_Actor);
		
		IF
		DialogActorLeft(_Dialog,_Inst,_Actor)
		THEN
		ProcSetNumberOfInvolvedActors(_Inst);
		
		PROC
		ProcClearDialogPlayers((INTEGER)_Inst)
		AND
		DB_DialogPlayers(_Inst,_Player,_Index)
		THEN
		NOT DB_DialogPlayers(_Inst,_Player,_Index);
		
		PROC
		ProcClearDialogNPCs((INTEGER)_Inst)
		AND
		DB_DialogNPCs(_Inst,_Player,_Index)
		THEN
		NOT DB_DialogNPCs(_Inst,_Player,_Index);
		
		PROC
		ProcClearDialogCounts((INTEGER)_Inst)
		AND
		DB_DialogNumPlayers(_Inst,_NumPlayers)
		AND
		DB_DialogNumNPCs(_Inst,_NumNPCs)
		THEN
		NOT DB_DialogNumPlayers(_Inst,_NumPlayers);
		NOT DB_DialogNumNPCs(_Inst,_NumNPCs);
		
		IF
		CharacterCreationFinished(_)
		THEN
		NOT DB_InCharacterCreation(1);
		NotifyCharacterCreationFinished();
		
	}
	EXIT
	{
		
	}
}
Goal(11).SubGoal(20);
Goal(11).SubGoal(21);
Goal(11).SubGoal(22);
Goal(11).SubGoal(35);
Goal(11).SubGoal(36);
Goal(11).SubGoal(37);
Goal(11).SubGoal(38);
Goal(11).SubGoal(54);
Goal(11).SubGoal(55);
Goal(11).SubGoal(58);
Goal(11).SubGoal(59);
Goal(11).SubGoal(66);
Goal(20).SubGoals(AND);
Goal(21).SubGoals(AND);
Goal(22).SubGoals(AND);
Goal(35).SubGoals(AND);
Goal(36).SubGoals(AND);
Goal(37).SubGoals(AND);
Goal(38).SubGoals(AND);
Goal(54).SubGoals(AND);
Goal(55).SubGoals(AND);
Goal(58).SubGoals(AND);
Goal(59).SubGoals(AND);
Goal(66).SubGoals(AND);
Goal(12).SubGoal(3);
Goal(12).SubGoal(5);
Goal(12).SubGoal(9);
Goal(12).SubGoal(10);
Goal(12).SubGoal(16);
Goal(12).SubGoal(17);
Goal(12).SubGoal(24);
Goal(12).SubGoal(39);
Goal(12).SubGoal(40);
Goal(12).SubGoal(47);
Goal(12).SubGoal(49);
Goal(12).SubGoal(53);
Goal(12).SubGoal(57);
Goal(12).SubGoal(65);
Goal(3).SubGoals(AND);
Goal(5).SubGoals(AND);
Goal(9).SubGoals(AND);
Goal(10).SubGoals(AND);
Goal(16).SubGoals(AND);
Goal(17).SubGoals(AND);
Goal(24).SubGoals(AND);
Goal(39).SubGoals(AND);
Goal(40).SubGoals(AND);
Goal(47).SubGoals(AND);
Goal(49).SubGoals(AND);
Goal(53).SubGoals(AND);
Goal(57).SubGoals(AND);
Goal(65).SubGoals(AND);
Goal(63).SubGoal(64);
Goal(64).SubGoals(AND);
Goal(65).SubGoal(48);
Goal(48).SubGoals(AND);
Goal(67).SubGoal(68);
Goal(67).SubGoal(69);
Goal(68).SubGoals(AND);
Goal(69).SubGoals(AND);

